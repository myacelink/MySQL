# ===============================================================================
# ========================== Replication Parameter  =============================
# ===============================================================================
# 
# -------------------------------------------------------------------------------
# -------------Replication Master Options and Variables--------------------------
# -------------------------------------------------------------------------------
# 
# @ --show-slave-auth-info
# 
# Property : Value
# Command-Line Format : --show-slave-auth-info[={OFF|ON}]
# Type : Boolean
# Default Value : OFF
#
# --report-user 및 --report-password 옵션으로 시작한 슬레이브에 대한 마스터 서버의 SHOW SLAVE HOSTS 출력에 슬레이브 사용자 이름 및 비밀번호를 표시합니다.
#
# * Apply Option
# show-slave-auth-info=OFF
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_enabled
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-enabled[={OFF|ON}]
# System Variable : rpl_semi_sync_master_enabled
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 마스터에서 반동기 복제를 사용할지 여부를 제어합니다. 플러그인을 활성화 또는 비활성화 하려면 이 변수를 각각 ON 또는 OFF (또는 1 또는 0)로 설정하십시오. 기본 설정은 OFF입니다.
# 이 변수는 마스터 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_master_enabled=OFF
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_timeout
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-timeout=#
# System Variable : rpl_semi_sync_master_timeout
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10000
#
# 시간 초과 및 비동기 복제로 되돌리기 전에 마스터가 슬레이브로부터 승인을 받기 위해 커밋을 기다리는 시간을 제어하는 밀리 초 단위의 값입니다. 기본값은 10000 (10 초)입니다.
# 
# 이 변수는 마스터 측 반동기 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_master_timeout=10000
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_trace_level
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-trace-level=#
# System Variable : rpl_semi_sync_master_trace_level
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 32
# 
# 마스터에서 반 동기식 복제 디버그 추적 수준입니다. 네 가지 수준이 정의됩니다.
# 1 = 일반 수준 (예 : 시간 함수 실패)
# 16 = 세부 수준 (보다 자세한 정보)
# 32 = 순 대기 수준 (네트워크 대기에 대한 자세한 정보)
# 64 = 기능 수준 (기능 입력 및 종료에 대한 정보)
# 
# 이 변수는 마스터 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.#
# * Apply Option
# rpl_semi_sync_master_trace_level=32
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_wait_for_slave_count
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-wait-for-slave-count=#
# System Variable : rpl_semi_sync_master_wait_for_slave_count
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1
# Minimum Value : 1
# Maximum Value : 65535
# 
# 진행하기 전에 마스터가 트랜잭션 당 수신해야하는 슬레이브 승인 수입니다.
# 기본적으로 rpl_semi_sync_master_wait_for_slave_count는 1입니다.
# 이는 단일 슬레이브 승인을받은 후 반 동기식 복제가 진행됨을 의미합니다. 이 변수의 작은 값에 성능이 가장 좋습니다.
# 
# 예를 들어, rpl_semi_sync_master_wait_for_slave_count가 2 인 경우, 2 개의 슬레이브가 rpl_semi_sync_master_timeout에 의해
# 구성된 시간 초과 기간 전에 반동기 복제가 진행되도록 트랜잭션 수신을 승인해야합니다.
# 시간 초과 기간 동안 적은 수의 슬레이브가 트랜잭션 수신을 확인하면 마스터는 일반 복제로 돌아갑니다.
# 
# 노트
# 이 동작은 rpl_semi_sync_master_wait_no_slave에 따라 다릅니다.
# 
# 이 변수는 마스터 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_master_wait_for_slave_count=1
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_wait_no_slave
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-wait-no-slave[={OFF|ON}]
# System Variable : rpl_semi_sync_master_wait_no_slave
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 시간 초과 기간 동안 슬레이브 수가 rpl_semi_sync_master_wait_for_slave_count에 의해 구성된 슬레이브 수보다 적더라도
# rpl_semi_sync_master_timeout으로 구성된 시간 초과 기간 동안 마스터가 대기하는지 여부를 제어합니다.
# 
# rpl_semi_sync_master_wait_no_slave의 값이 ON (기본값) 인 경우 제한 시간 동안 슬레이브 카운트가 rpl_semi_sync_master_wait_for_slave_count보다 작게 떨어질 수 있습니다.
# 시간 종료 기간이 만료되기 전에 충분한 슬레이브가 트랜잭션을 승인하면 반 동기식 복제가 계속됩니다.
# 
# rpl_semi_sync_master_wait_no_slave의 값이 OFF 인 경우, rpl_semi_sync_master_timeout에 의해 구성된 시간 초과 기간 동안
# 언제라도 슬레이브 카운트가 rpl_semi_sync_master_wait_for_slave_count에 구성된 수보다 작게 떨어지면 마스터는 일반 복제로 되돌아갑니다.
# 
# 이 변수는 마스터 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_master_wait_no_slave=ON
# 
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_wait_point
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-wait-point=value
# System Variable : rpl_semi_sync_master_wait_point
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : AFTER_SYNC
# Valid Values  : AFTER_SYNC, AFTER_COMMIT
# 
# 이 변수는 트랜잭션을 커밋 한 클라이언트에 상태를 반환하기 전에 세미 동기식 복제 마스터가 트랜잭션 수신의 슬레이브 승인을 기다리는 지점을 제어합니다. 이 값들은 허용됩니다 :
# + AFTER_SYNC (기본값) : 마스터는 각 트랜잭션을 이진 로그 및 슬레이브에 기록하고 이진 로그를 디스크에 동기화합니다.
# 마스터는 동기화 후 트랜잭션 수신에 대한 슬레이브 승인을 기다립니다. 승인을 받으면 마스터는 트랜잭션을 스토리지 엔진에 커밋하고 결과를 클라이언트에 반환 한 다음 진행할 수 있습니다.
# + AFTER_COMMIT : 마스터는 각 트랜잭션을 이진 로그에 기록하고 슬레이브는 이진 로그를 동기화하고 트랜잭션을 스토리지 엔진에 커밋합니다.
# 마스터는 커밋 후 트랜잭션 수신에 대한 슬레이브 승인을 기다립니다. 승인을 받으면 마스터는 결과를 클라이언트에 반환 한 다음 진행할 수 있습니다.
# 
# 이러한 설정의 복제 특성은 다음과 같이 다릅니다.
# + AFTER_SYNC를 사용하면 모든 클라이언트가 커밋 된 트랜잭션을 동시에 볼 수 있습니다.
# 슬레이브에 의해 승인되고 마스터의 스토리지 엔진에 커밋 된 후. 따라서 모든 클라이언트는 마스터에서 동일한 데이터를 봅니다.
# 마스터 장애가 발생하면 마스터에서 커밋 된 모든 트랜잭션이 슬레이브로 복제됩니다 (중계 로그에 저장 됨).
# 슬레이브가 최신 상태이므로 마스터 충돌 및 슬레이브 장애 조치는 손실이 없습니다.
# 그러나이 시나리오에서 마스터를 다시 시작할 수 없으며 이진 로그 복구 후 외부화 될 때 슬레이브와 충돌하는 커밋되지 않은 트랜잭션이 바이너리 로그에 포함될 수 있기 때문에 버려야합니다.
# + AFTER_COMMIT를 사용하면 트랜잭션을 발행하는 클라이언트는 서버가 스토리지 엔진에 커밋하고 슬레이브 승인을받은 후에 만 ​​반환 상태를 얻습니다.
# 커밋 후 및 슬레이브 승인 전에 다른 클라이언트는 커밋 클라이언트 전에 커밋 된 트랜잭션을 볼 수 있습니다.
# 
# 슬레이브가 트랜잭션을 처리하지 않는 문제가 발생하면 마스터 충돌 및 슬레이브 장애 조치가 발생하는 경우 해당 클라이언트가 마스터에서 본 것과 관련하여 데이터가 손실 될 수 있습니다.
# 
# 이 변수는 마스터 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
# rpl_semi_sync_master_wait_point는 MySQL 5.7.2에서 추가되었습니다. 이전 버전의 경우 반동기 마스터 동작은 AFTER_COMMIT 설정과 같습니다.
# 
# 이 변경 사항은 세미 동기식 인터페이스 버전을 증가시키기 때문에 버전 호환성 제약이 도입되었습니다.
# MySQL 5.7.2 이상의 서버는 이전 버전의 반 동기식 복제 플러그인과 작동하지 않으며, 이전 버전의 서버는 MySQL 5.7.2 이상의 반 동기식 복제 플러그인과 작동하지 않습니다.
#
# * Apply Option
# rpl_semi_sync_master_wait_point=AFTER_SYNC
# 
# 
# ---------------------------------------------------------------------------
# -----------Replication Slave Options and Variables-------------------------
# ---------------------------------------------------------------------------
# 
# @ --master-info-file=file_name
# 
# Property : Value
# Command-Line Format : --master-info-file=file_name
# Type : File name
# Default Value : master.info
# 
# 슬레이브가 마스터에 대한 정보를 기록하는 파일에 사용할 이름입니다.
# 기본 이름은 데이터 디렉토리의 master.info입니다.
# 이 파일의 형식에 대한 자세한 내용은 16.2.4.2 절“슬레이브 상태 로그”를 참조하십시오.
#
# * Apply Option
# master-info-file=file_name=master.info
# 
# --------------------------------------------
# 
# @ --max-relay-log-size=size
# 
# Property : Value
# Command-Line Format : --max-relay-log-size=#
# System Variable : max_relay_log_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 1073741824
# 
# 서버가 릴레이 로그 파일을 자동으로 회전시키는 크기입니다. 이 값이 0이 아니면 릴레이 로그의 크기가이 값을 초과하면 자동으로 회전됩니다.
# 이 값이 0(기본값)이면 릴레이 로그 회전이 발생하는 크기는 max_binlog_size 값에 의해 결정됩니다. 자세한 내용은 16.2.4.1 절“슬레이브 릴레이 로그”를 참조하십시오.
#
# * Apply Option
# max-relay-log-size=-1
# 
# --------------------------------------------
# 
# @ --relay-log-purge={0|1}
# 
# Property : Value
# Command-Line Format : --relay-log-purge[={OFF|ON}]
# System Variable : relay_log_purge
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 더 이상 필요하지 않은 즉시 릴레이 로그 자동 제거를 비활성화하거나 활성화하십시오. 기본값은 1(사용)입니다.
# SET GLOBAL relay_log_purge = N을 사용하여 동적으로 변경할 수있는 전역 변수입니다.
# --relay-log-recovery 옵션을 활성화 할 때 릴레이 로그 제거를 비활성화하면 데이터 일관성이 위험 해집니다.
#
# * Apply Option
# relay-log-purge=ON
# 
# --------------------------------------------
# 
# @ --relay-log-space-limit=size
# 
# Property : Value
# Command-Line Format : --relay-log-space-limit=#
# System Variable : relay_log_space_limit
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 이 옵션은 슬레이브에있는 모든 릴레이 로그의 총 크기에 대한 상한을 바이트 단위로 설정합니다. 값이 0이면 "제한 없음"을 의미합니다.
# 디스크 공간이 제한된 슬레이브 서버 호스트에 유용합니다.
# 한계에 도달하면, I / O 스레드는 SQL 스레드가 사용되지 않은 일부 릴레이 로그를 따라 잡을 때까지 마스터 서버에서 2 진 로그 이벤트 읽기를 중지합니다.
# 이 한계는 절대적인 것은 아닙니다. SQL 스레드가 릴레이 로그를 삭제하기 전에 더 많은 이벤트가 필요한 경우가 있습니다.
# 이 경우 I / O 스레드가 제한을 초과하면 SQL 스레드가 일부 릴레이 로그를 삭제할 수있을 때까지 교착 상태가 발생할 수 있습니다.
# --relay-log-space-limit 값을 --max-relay-log-size 값 (또는 --max-relay-log-size가 0 인 경우 --max-binlog-size 값의 두 배 미만으로 설정하지 않아야합니다.).
# 이 경우 --relay-log-space-limit가 초과되어 I / O 스레드가 여유 공간을 기다릴 가능성이 있지만 SQL 스레드에는 제거 할 릴레이 로그가없고 I / O를 만족시킬 수 없습니다.
# 실. 그러면 I / O 스레드가 --relay-log-space-limit를 일시적으로 무시합니다.
#
# * Apply Option
# relay-log-relay-log-space-limit=0
# 
# --------------------------------------------
# 
# @ --replicate-do-db=db_name
# 
# Property : Value
# Command-Line Format : --replicate-do-db=name
# Type : String
# 
# 데이터베이스 이름을 사용하여 복제 필터를 만듭니다. 이러한 필터는 CHANGE REPLICATION FILTER REPLICATE_DO_DB를 사용하여 만들 수도 있습니다.
# 이 필터링의 정확한 효과는 명령문 기반 복제 또는 행 기반 복제의 사용 여부에 따라 다르며 다음 몇 단락에서 설명됩니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 
# ### Statement-based replication. ###
# 기본 데이터베이스 (USE에서 선택한 데이터베이스)가 db_name 인 명령문으로 복제를 제한하도록 슬레이브 SQL 스레드에 지시하십시오.
# 둘 이상의 데이터베이스를 지정하려면 각 데이터베이스에 대해이 옵션을 여러 번 사용하십시오.
# 그러나 이렇게하면 다른 데이터베이스 (또는 데이터베이스 없음)가 선택된 동안 UPDATE some_db.some_table SET foo = 'bar'와 같은 데이터베이스 간 문을 복제하지 않습니다.
# 
# 경고
# 여러 데이터베이스를 지정하려면이 옵션의 여러 인스턴스를 사용해야합니다. 데이터베이스 이름은 쉼표를 포함 할 수 있으므로 쉼표로 구분 된 목록을 제공하면 목록이 단일 데이터베이스의 이름으로 취급됩니다.
# 
# 명령문 기반 복제를 사용할 때 예상대로 작동하지 않는 예 : 슬레이브가 --replicate-do-db = sales로 시작되고 마스터에서 다음 명령문을 발행하면 UPDATE 문이 복제되지 않습니다.
# 
# USE prices;
# UPDATE sales.january SET amount=amount+1000;
# 이“기본 데이터베이스 만 검사”동작의 주된 이유는 명령문만으로는 복제 여부를 알기가 어렵 기 때문입니다 (예 : 다중 테이블 DELETE 문 또는 다중 테이블 UPDATE 문을 사용하는 경우) 여러 데이터베이스에서).
# 필요하지 않은 경우 모든 데이터베이스가 아닌 기본 데이터베이스 만 확인하는 것이 더 빠릅니다.
# 
# 
# ### Row-based replication. ###
# 슬레이브 SQL 스레드에게 복제를 데이터베이스 db_name으로 제한하도록 지시합니다. db_name에 속하는 테이블 만 변경됩니다. 현재 데이터베이스는 이에 영향을 미치지 않습니다.
# 슬레이브가 --replicate-do-db = sales로 시작되고 행 기반 복제가 적용되고 마스터에서 다음 명령문이 실행된다고 가정하십시오.
# 
# USE prices;
# UPDATE sales.february SET amount=amount+100;
# 슬레이브의 영업 데이터베이스에있는 2 월 테이블은 UPDATE 문에 따라 변경됩니다. 이것은 USE 문이 발행되었는지 여부에 관계없이 발생합니다.
# 그러나 마스터에서 다음 명령문을 발행해도 행 기반 복제 및 --replicate-do-db = sales를 사용할 때 슬레이브에 영향을 미치지 않습니다.
# 
# USE prices;
# UPDATE prices.march SET amount=amount-25;
# USE 가격 명세서가 USE 판매로 변경 되더라도 UPDATE 문의 효과는 여전히 복제되지 않습니다.
# 
# 여러 데이터베이스를 참조하는 문과 관련하여 행 기반 복제와 달리 행 기반 복제와 달리 --replicate-do-db가 문 기반 복제에서 처리되는 방식의 또 다른 중요한 차이점입니다.
# 슬레이브가 --replicate-do-db = db1로 시작되고 마스터에서 다음 명령문이 실행된다고 가정하십시오.
# 
# USE db1;
# UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
# 명령문 기반 복제를 사용하는 경우 두 테이블이 모두 슬레이브에서 업데이트됩니다. 그러나 행 기반 복제를 사용하는 경우 table1 만 슬레이브에서 영향을받습니다.
# table2는 다른 데이터베이스에 있으므로 슬레이브의 table2는 UPDATE에 의해 변경되지 않습니다. 이제 USE db1 문 대신 USE db4 문이 사용되었다고 가정합니다.
# 
# USE db4;
# UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
# 이 경우 명령문 기반 복제를 사용할 때 UPDATE 문은 슬레이브에 영향을 미치지 않습니다. 그러나 행 기반 복제를 사용하는 경우 UPDATE는 슬레이브의 table1을 변경하지만 table2는 변경하지 않습니다.
# 즉, --replicate-do-db로 이름 지정된 데이터베이스의 테이블 만 변경되고 기본값은 선택됩니다. 데이터베이스는이 동작에 영향을 미치지 않습니다.
# 
# 데이터베이스 간 업데이트가 필요하면 --replicate-wild-do-table = db_name. %를 대신 사용하십시오. 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
# 
# 노트
# 이 옵션은 --binlog-do-db가 이진 로깅에 영향을 미치는 것과 같은 방식으로 복제에 영향을 미치며 --replicate-do-db가 복제 동작에 미치는 영향에 대한 복제 형식의 영향은 복제 형식의 영향과 동일합니다.
# --binlog-do-db의 동작이 옵션은 BEGIN, COMMIT 또는 ROLLBACK 문에는 영향을 미치지 않습니다.
#
# * Apply Option
# replicate-do-db=db_name
#
# --------------------------------------------
# 
# @ --replicate-ignore-db=db_name
# 
# Property : Value
# Command-Line Format : --replicate-ignore-db=name
# Type : String
# 
# 데이터베이스 이름을 사용하여 복제 필터를 만듭니다. 이러한 필터는 CHANGE REPLICATION FILTER REPLICATE_IGNORE_DB를 사용하여 만들 수도 있습니다.
# --replicate-do-db와 마찬가지로이 필터링의 정확한 효과는 명령문 기반 또는 행 기반 복제의 사용 여부에 따라 다르며 다음 몇 단락에서 설명됩니다.
# 
# Note
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# ### Statement-based replication. ###
# 기본 데이터베이스 (USE가 선택한 데이터베이스)가 db_name 인 명령문을 복제하지 않도록 슬레이브 SQL 스레드에 지시합니다.
# 
# ### Row-based replication. ###
# 슬레이브 SQL 스레드가 db_name 데이터베이스의 테이블을 갱신하지 않도록 지시합니다. 기본 데이터베이스는 영향을 미치지 않습니다.
# 
# 명령문 기반 복제를 사용할 때 다음 예제는 예상대로 작동하지 않습니다. 슬레이브가 --replicate-ignore-db = sales로 시작되고 마스터에서 다음 명령문을 발행한다고 가정하십시오.
# 
# USE prices;
# UPDATE sales.january SET amount=amount+1000;
# --replicate-ignore-db는 기본 데이터베이스 (USE 문으로 결정)에만 적용되므로 UPDATE 문은 이러한 경우에 복제됩니다.
# 판매 데이터베이스가 명령문에 명시 적으로 지정되었으므로 명령문이 필터링되지 않았습니다.
# 그러나 행 기반 복제를 사용할 때 UPDATE 문의 효과는 슬레이브로 전파되지 않으며 슬레이브의 sales.january 테이블 사본은 변경되지 않습니다.
# 이 경우 --replicate-ignore-db = sales는 마스터의 판매 데이터베이스 복사본에있는 테이블의 모든 변경 사항이 슬레이브에 의해 무시되도록합니다.
# 
# 무시할 둘 이상의 데이터베이스를 지정하려면 각 데이터베이스에 대해이 옵션을 여러 번 사용하십시오. 데이터베이스 이름은 쉼표를 포함 할 수 있으므로 쉼표로
# 구분된 목록을 제공하면 목록이 단일 데이터베이스의 이름으로 취급됩니다.
# 
# 데이터베이스 간 업데이트를 사용하고 있고 이러한 업데이트를 복제하지 않으려는 경우이 옵션을 사용하지 마십시오. 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
# 
# 데이터베이스 간 업데이트가 필요하면 --replicate-wild-ignore-table = db_name. %를 대신 사용하십시오. 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
# 
# 노트
# 이 옵션은 --binlog-ignore-db가 이진 로깅에 영향을 미치는 것과 같은 방식으로 복제에 영향을 미치며
# --replicate-ignore-db가 복제 동작에 미치는 영향에 대한 복제 형식의 영향은 복제 형식의 영향과 동일합니다.
# --binlog-ignore-db의 동작이 옵션은 BEGIN, COMMIT 또는 ROLLBACK 문에는 영향을 미치지 않습니다.
#
# * Apply Option
# replicate-ignore-db=db_name
# 
# --------------------------------------------
# 
# @ --replicate-do-table=db_name.tbl_name
# 
# Property : Value
# Command-Line Format : --replicate-do-table=name
# Type : String
# 
# 슬레이브 SQL 스레드에 지정된 테이블로 복제를 제한하도록 지시하여 복제 필터를 작성합니다.
# 둘 이상의 테이블을 지정하려면 각 테이블에 대해이 옵션을 여러 번 사용하십시오. --replicate-do-db와 달리 데이터베이스 간 업데이트와 기본 데이터베이스 업데이트 모두에서 작동합니다.
# 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오. CHANGE REPLICATION FILTER REPLICATE_DO_TABLE 문을 발행하여 이러한 필터를 작성할 수도 있습니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 이 옵션은 테이블에 적용되는 명령문에만 영향을줍니다. 스토어드 루틴과 같은 다른 데이터베이스 오브젝트에만 적용되는 명령문에는 영향을 미치지 않습니다.
# 스토어드 루틴에서 작동하는 명령문을 필터링하려면 하나 이상의 --replicate-*-db 옵션을 사용하십시오.
#
# * Apply Option
# replicate-do-table=db_name.tbl_name
# 
# --------------------------------------------
# 
# @ --replicate-ignore-table=db_name.tbl_name
# 
# Property : Value
# Command-Line Format : --replicate-ignore-table=name
# Type : String
# 
# 동일한 명령문으로 다른 테이블을 업데이트하더라도 슬레이브 SQL 스레드가 지정된 테이블을 업데이트하는 명령문을 복제하지 않도록 지시하여 복제 필터를 작성합니다.
# 무시할 테이블을 두 개 이상 지정하려면 각 테이블마다 한 번씩이 옵션을 여러 번 사용하십시오.
# --replicate-ignore-db와 달리 데이터베이스 간 업데이트에 적용됩니다. 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
# CHANGE REPLICATION FILTER REPLICATE_IGNORE_TABLE 문을 발행하여 이러한 필터를 작성할 수도 있습니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 이 옵션은 테이블에 적용되는 명령문에만 영향을줍니다. 스토어드 루틴과 같은 다른 데이터베이스 오브젝트에만 적용되는 명령문에는 영향을 미치지 않습니다.
# 스토어드 루틴에서 작동하는 명령문을 필터링하려면 하나 이상의 --replicate-*-db 옵션을 사용하십시오.
#
# * Apply Option
# --replicate-ignore-table=db_name.tbl_name
# 
# --------------------------------------------
# 
# @ --replicate-rewrite-db=from_name->to_name
# 
# Property : Value
# Command-Line Format : --replicate-rewrite-db=old_name->new_name
# Type : String
# 
# 슬레이브가 기본 데이터베이스 (USE에서 선택한 데이터베이스)를 마스터의 from_name 인 경우 to_name으로 변환하는 복제 필터를 작성하도록 지시합니다.
# from_name이 마스터의 기본 데이터베이스 인 경우에만 테이블 관련 명령문 만 영향을받습니다 (CREATE DATABASE, DROP DATABASE 및 ALTER DATABASE와 같은 명령문은 아님).
#  다시 쓰기를 여러 번 지정하려면이 옵션을 여러 번 사용하십시오. 서버는 일치하는 from_name 값을 가진 첫 번째 서버를 사용합니다.
#  --replicate- * 규칙을 테스트하기 전에 데이터베이스 이름 변환이 수행됩니다. CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB 문을 발행하여 이러한 필터를 작성할 수도 있습니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 이 옵션을 사용할 때 테이블 이름이 데이터베이스 이름으로 규정 된 명령문은 --replicate-do-table과 같은 테이블 레벨 복제 필터링 옵션에서 작동하지 않습니다.
# 마스터에 a라는 데이터베이스, 슬레이브에 b라는 데이터베이스, 각각 테이블 t를 포함하고 --replicate-rewrite-db = 'a-> b'로 마스터를 시작했다고 가정합니다.
# 나중에 우리는 DELETE FROM a.t를 실행합니다. 이 경우 다음과 같은 이유로 관련 필터링 규칙이 작동하지 않습니다.
# 
# a. 슬레이브가 데이터베이스 b에 테이블 t를 가지고 있기 때문에 --replicate-do-table = a.t가 작동하지 않습니다.
# b. --replicate-do-table = b.t는 원래 문장과 일치하지 않으므로 무시됩니다.
# c. --replicate-do-table = *. t는 --replicate-do-table = a.t와 동일하게 처리되므로 작동하지 않습니다.
# 마찬가지로 --replication-rewrite-db 옵션은 데이터베이스 간 업데이트에서 작동하지 않습니다.
# 
# 명령 행에서이 옵션을 사용하고> 문자가 명령 해석기에 특수한 경우 옵션 값을 인용하십시오. 예를 들면 다음과 같습니다.
# shell> mysqld --replicate-rewrite-db = "olddb-> newdb"
#
# * Apply Option
# replicate-rewrite-db=from_name->to_name
# 
# --------------------------------------------
# 
# @ --replicate-same-server-id
# 
# Property : Value
# Command-Line Format : --replicate-same-server-id[={OFF|ON}]
# Type : Boolean
# Default Value : OFF
# 
# 슬레이브 서버에서 사용됩니다. 일반적으로 순환 복제로 인한 무한 루프를 방지하려면 기본 설정 인 0을 사용해야합니다.
# 1로 설정하면 슬레이브는 자체 서버 ID가있는 이벤트를 건너 뛰지 않습니다. 일반적으로 이는 드문 구성에서만 유용합니다.
# log_slave_updates가 활성화 된 경우 1로 설정할 수 없습니다.
# 기본적으로 슬레이브 I / O 스레드는 슬레이브 서버 ID가있는 경우 이진 로그 이벤트를 릴레이 로그에 쓰지 않습니다 (이 최적화는 디스크 사용량을 절약하는 데 도움이 됨).
# --replicate-same-server-id를 사용하려면 슬레이브 SQL 스레드가 실행할 자체 이벤트를 슬레이브가 읽기 전에이 옵션으로 슬레이브를 시작해야합니다.
#
# * Apply Option
# replicate-same-server-id
# 
# --------------------------------------------
# 
# @ --replicate-wild-do-table=db_name.tbl_name
# 
# Property : Value
# Command-Line Format : --replicate-wild-do-table=name
# Type : String
# 
# 업데이트 된 테이블이 지정된 데이터베이스 및 테이블 이름 패턴과 일치하는 명령문으로 복제를 제한하도록 슬레이브 스레드에 지시하여 복제 필터를 작성합니다.
# 패턴은 % 및 _ 와일드 카드 문자를 포함 할 수 있으며 LIKE 패턴 일치 연산자와 동일한 의미를 갖습니다.
# 둘 이상의 테이블을 지정하려면 각 테이블에 대해이 옵션을 여러 번 사용하십시오. 이것은 데이터베이스 간 업데이트에 적용됩니다.
# 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오. CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE 문을 발행하여 이러한 필터를 작성할 수도 있습니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 이 옵션은 테이블, 뷰 및 트리거에 적용됩니다.
# 저장 프로 시저 및 함수 또는 이벤트에는 적용되지 않습니다. 후자의 오브젝트에서 작동하는 명령문을 필터링하려면 하나 이상의 --replicate-*-db 옵션을 사용하십시오.
# 
# 예를 들어 --replicate-wild-do-table = foo % .bar %는 데이터베이스 이름이 foo로 시작하고 테이블 이름이 bar로 시작하는 테이블을 사용하는 업데이트 만 복제합니다.
# 
# 테이블 이름 패턴이 % 인 경우 테이블 이름 패턴과 일치하며 옵션은 데이터베이스 레벨 명령문 (CREATE DATABASE, DROP DATABASE 및 ALTER DATABASE)에도 적용됩니다.
# 예를 들어 --replicate-wild-do-table = foo %. %를 사용하는 경우 데이터베이스 이름이 foo % 패턴과 일치하면 데이터베이스 수준 문이 복제됩니다.
# 
# 데이터베이스 또는 테이블 이름 패턴에 리터럴 와일드 카드 문자를 포함 시키려면 백 슬래시로 이스케이프 처리하십시오.
# 예를 들어, my_own % db라는 데이터베이스의 모든 테이블을 복제하지만 my1ownAABCdb 데이터베이스에서 테이블을 복제하지 않으려면 다음과 같이 _ 및 % 문자를 이스케이프해야합니다.
# --replicate-wild-do-table = my \ _own \ % db. 명령 행에서 옵션을 사용하는 경우 명령 인터프리터에 따라 백 슬래시를 두 배로 늘리거나 옵션 값을 인용해야합니다.
# 예를 들어, bash 쉘을 사용하면 --replicate-wild-do-table = my \\ _ own \\ % db를 입력해야합니다.
#
# * Apply Option
# replicate-wild-do-table=db_name.tbl_name
# 
# --------------------------------------------
# 
# @ --replicate-wild-ignore-table=db_name.tbl_name
# 
# Property : Value
# Command-Line Format : --replicate-wild-ignore-table=name
# Type : String
# 
# 슬레이브 필터가 지정된 와일드 카드 패턴과 일치하는 테이블을 명령문에서 복제하지 못하도록하는 복제 필터를 작성합니다.
# 무시할 테이블을 두 개 이상 지정하려면 각 테이블마다 한 번씩이 옵션을 여러 번 사용하십시오. 이것은 데이터베이스 간 업데이트에 적용됩니다.
# 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
# CHANGE REPLICATION FILTER REPLICATE_WILD_IGNORE_TABLE 문을 발행하여 이러한 필터를 작성할 수도 있습니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 예를 들어 --replicate-wild-ignore-table = foo % .bar %는 데이터베이스 이름이 foo로 시작하고 테이블 이름이 bar로 시작하는 테이블을 사용하는 업데이트를 복제하지 않습니다.
# 일치하는 방법에 대한 자세한 내용은 --replicate-wild-do-table 옵션에 대한 설명을 참조하십시오.
# 옵션 값에 리터럴 와일드 카드 문자를 포함시키는 규칙은 --replicate-wild-ignore-table과 동일합니다.
#
# * Apply Option
# replicate-wild-ignore-table=db_name.tbl_name
# 
# --------------------------------------------
# 
# @ --skip-slave-start
# 
# Property : Value
# Command-Line Format : --skip-slave-start[={OFF|ON}]
# Type : Boolean
# Default Value : OFF
# 
# 서버가 시작될 때 슬레이브 서버가 슬레이브 스레드를 시작하지 않도록 지시합니다. 나중에 스레드를 시작하려면 START SLAVE 문을 사용하십시오.
#
# * Apply Option
# skip-slave-start=OFF
# 
# --------------------------------------------
# 
# @ --slave-skip-errors=[err_code1,err_code2,...|all|ddl_exist_errors]
# 
# Property : Value
# Command-Line Format : --slave-skip-errors=name
# System Variable : slave_skip_errors
# Scope : Global
# Dynamic : No
# Type : String
# Default Value : OFF
# Valid Values  : OFF, [list of error codes], all, ddl_exist_errors
# 
# 일반적으로 슬레이브에서 오류가 발생하면 복제가 중지되므로 데이터의 불일치를 수동으로 해결할 수 있습니다.
# 이 옵션은 명령문이 옵션 값에 나열된 오류를 리턴 할 때 슬레이브 SQL 스레드가 복제를 계속하게합니다.
# 
# 오류가 발생하는 이유를 완전히 이해하지 않으면이 옵션을 사용하지 마십시오. 복제 설정 및 클라이언트 프로그램에 버그가없고 MySQL 자체에 버그가없는 경우 복제를 중지하는 오류가 발생하지 않아야합니다.
# 이 옵션을 무차별 적으로 사용하면 슬레이브가 마스터와 동기화되지 않게되어 왜 이런 일이 발생했는지 알 수 없습니다.
# 
# 오류 코드의 경우 슬레이브 오류 로그 및 SHOW SLAVE STATUS 출력에 오류 메시지가 제공 한 숫자를 사용해야합니다.
# 부록 B, 오류, 오류 코드 및 일반적인 문제에는 서버 오류 코드가 나와 있습니다.
# 
# 속기 값 ddl_exist_errors는 오류 코드 목록 1007,1008,1050,1051,1054,1060,1061,1068,1094,1146과 같습니다.
# 
# 또한 권장하지 않는 all 값을 사용하여 슬레이브가 모든 오류 메시지를 무시하고 상황에 관계없이 계속 진행할 수 있습니다. 말할 것도없이, 모두를 사용하면 데이터의 무결성에 대한 보장이 없습니다.
# 이 경우 슬레이브의 데이터가 마스터에있는 데이터와 가까운 곳에 있지 않은 경우이 경우 불평하거나 파일 버그 보고서를 작성하지 마십시오. 경고를 받았습니다.
# 
# 예제:
# --slave-skip-errors=1062,1053
# --slave-skip-errors=all
# --slave-skip-errors=ddl_exist_errors
#
# * Apply Option
# slave-skip-errors=OFF
# 
# --------------------------------------------
# 
# @ --slave-sql-verify-checksum={0|1}
# 
# Property : Value
# Command-Line Format : --slave-sql-verify-checksum[={OFF|ON}]
# Type : Boolean
# Default Value : ON
# When this option is enabled, the slave examines checksums read from the relay log, in the event of a mismatch, the slave stops with an error.
# 
# 다음 옵션은 복제 테스트 및 디버깅을 위해 MySQL 테스트 스위트에서 내부적으로 사용됩니다. 프로덕션 환경에서 사용하기위한 것이 아닙니다.
#
# * Apply Option
# slave-sql-verify-checksum=ON
# 
# --------------------------------------------
# 
# @ --abort-slave-event-count
# 
# Property : Value
# Command-Line Format : --abort-slave-event-count=#
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# 
# 이 옵션을 0 (기본값) 이외의 양의 정수 값으로 설정하면 다음과 같이 복제 동작에 영향을줍니다.
# 슬레이브 SQL 스레드가 시작된 후 값 로그 이벤트가 실행될 수 있습니다. 그 후 슬레이브 마스터 스레드는 마스터의 네트워크 연결이 끊어진 것처럼 더 이상 이벤트를받지 않습니다.
# 슬레이브 스레드는 계속 실행되고 SHOW SLAVE STATUS의 출력은 Slave_IO_Running 및 Slave_SQL_Running 열 모두에 Yes를 표시하지만 릴레이 로그에서 더 이상 이벤트를 읽지 않습니다.
#
# * Apply Option
# abort-slave-event-count=0
# 
# --------------------------------------------
# 
# @ --disconnect-slave-event-count
# 
# Property : Value
# Command-Line Format : --disconnect-slave-event-count=#
# Type : Integer
# Default Value : 0
#
# * Apply Option
# disconnect-slave-event-count=0
# 
# --------------------------------------------
# 
# @ init_slave
# 
# Property : Value
# Command-Line Format : --init-slave=name
# System Variable : init_slave
# Scope : Global
# Dynamic : Yes
# Type : String
# 
# 이 변수는 init_connect와 유사하지만 SQL 스레드가 시작될 때마다 슬레이브 서버가 실행하는 문자열입니다.
# 문자열의 형식은 init_connect 변수의 형식과 동일합니다. 이 변수의 설정은 후속 START SLAVE 문에 적용됩니다.
# 
# 노트
# SQL 스레드는 init_slave를 실행하기 전에 클라이언트에게 승인을 보냅니다. 따라서 START SLAVE가 리턴 될 때 init_slave가 실행되었다는 보장이 없습니다.
# 자세한 내용은 13.4.2.6 절“START SLAVE 문”을 참조하십시오.
#
# * Apply Option
# init_slave=none
# 
# 
# --------------------------------------------
# 
# @ log_slow_slave_statements
# 
# Property : Value
# Command-Line Format : --log-slow-slave-statements[={OFF|ON}]
# System Variable : log_slow_slave_statements
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 느린 쿼리 로그가 활성화되면이 변수는 슬레이브에서 long_query_time 초 이상 실행 된 쿼리에 대한 로깅을 활성화합니다.
# 행 기반 복제가 사용중인 경우 (binlog_format = ROW) log_slow_slave_statements는 영향을 미치지 않습니다.
# 바이너리 로그에서 명령문 형식으로 로그인 할 때, 즉 binlog_format = STATEMENT가 설정되거나 binlog_format = MIXED가 설정되고,
# 명령문이 명령문 형식으로 로깅 된 경우에만 쿼리가 슬레이브의 느린 쿼리 로그에 추가됩니다.
# binlog_format = MIXED가 설정 될 때 행 형식으로 기록되거나 binlog_format = ROW가 설정 될 때 기록된
# 느린 쿼리는 log_slow_slave_statements가 활성화되어 있어도 슬레이브의 느린 쿼리 로그에 추가되지 않습니다.
# 
# log_slow_slave_statements를 설정해도 즉각적인 효과는 없습니다. 변수 상태는 모든 후속 START SLAVE 문에 적용됩니다.
# 또한 long_query_time에 대한 전역 설정은 SQL 스레드 수명 동안 적용됩니다.
# 해당 설정을 변경하면 슬레이브의 SQL 스레드를 중지했다가 다시 시작하여 변경을 구현해야합니다 (예 : SQL_THREAD 옵션으로 STOP SLAVE 및 START SLAVE 문을 발행하여).
#
# * Apply Option
# log_slow_slave_statements=OFF
# 
# --------------------------------------------
# 
# @ master_info_repository
# 
# Property : Value
# Command-Line Format : --master-info-repository={FILE|TABLE}
# System Variable : master_info_repository
# Scope : Global
# Dynamic : Yes
# Type : String
# Default Value : FILE
# Valid Values  : FILE, TABLE
# 
# 이 변수의 설정은 슬레이브 서버가 마스터 상태 및 연결 정보를 FILE (master.info) 또는 TABLE (mysql.slave_master_info)에 기록할지 여부를 결정합니다.
# 복제 스레드가 실행되고 있지 않을 때만이 변수의 값을 변경할 수 있습니다.
# 
# 이 변수의 설정은 sync_master_info 시스템 변수의 설정에 의한 영향에 직접적인 영향을 미칩니다. 자세한 내용은 해당 변수 설명을 참조하십시오.
# 
# FILE 로깅의 경우 --master-info-file server 옵션을 사용하여 파일 이름을 변경할 수 있습니다.
# 
# 여러 복제 채널을 구성하기 전에이 변수를 TABLE로 설정해야합니다. 여러 복제 채널을 사용하는 경우 값을 다시 FILE로 설정할 수 없습니다.
#
# * Apply Option
# master_info_repository=FILE
# 
# --------------------------------------------
# 
# @ max_relay_log_size
# 
# Property : Value
# Command-Line Format : --max-relay-log-size=#
# System Variable : max_relay_log_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 1073741824
# 
# 복제 슬레이브가 릴레이 로그에 쓸 때 현재 로그 파일 크기가이 변수의 값을 초과하면 슬레이브는 릴레이 로그를 회전시킵니다 (현재 파일을 닫고 다음 파일을 엽니다).
# max_relay_log_size가 0이면 서버는 이진 로그 및 릴레이 로그 모두에 max_binlog_size를 사용합니다.
# max_relay_log_size가 0보다 크면 릴레이 로그의 크기가 제한되므로 두 로그에 대해 서로 다른 크기를 가질 수 있습니다.
# max_relay_log_size를 4096 바이트와 1GB (포함) 또는 0으로 설정해야합니다. 기본값은 0입니다. 16.2.2 절“복제 구현 세부 사항”을 참조하십시오.
#
# * Apply Option
# max_relay_log_size=0
# 
# --------------------------------------------
# 
# @ relay_log
# 
# Property : Value
# Command-Line Format : --relay-log=file_name
# System Variable : relay_log
# Scope : Global
# Dynamic : No
# Type : File name
# 
# 릴레이 로그 파일의 기본 이름입니다. 기본 복제 채널의 경우 릴레이 로그의 기본 이름은 host_name-relay-bin입니다.
# 기본이 아닌 복제 채널의 경우 릴레이 로그의 기본 이름은 host_name-relay-bin-channel입니다. 여기서 channel은이 릴레이 로그에 기록 된 복제 채널의 이름입니다.
# 
# 다른 이름을 지정하기 위해 기본 이름에 선행 절대 경로 이름이 지정되지 않은 한 서버는 파일을 데이터 디렉토리에 씁니다.
# 서버는 기본 이름에 숫자 접미 부를 추가하여 릴레이 로그 파일을 순서대로 작성합니다.
# 
# MySQL이 서버 옵션을 구문 분석하는 방식으로 인해 서버 시작시이 변수를 지정하면 값을 제공해야합니다. 옵션이 실제로 지정되지 않은 경우에만 기본 기본 이름이 사용됩니다.
# 서버 시작시 값을 지정하지 않고 relay_log 시스템 변수를 지정하면 예기치 않은 동작이 발생할 수 있습니다.
# 이 동작은 사용 된 다른 옵션, 지정된 순서 및 명령 줄 또는 옵션 파일에 지정되어 있는지에 따라 다릅니다.
# MySQL이 서버 옵션을 처리하는 방법에 대한 자세한 내용은 4.2.2 절“프로그램 옵션 지정”을 참조하십시오.
# 
# 이 변수를 지정하면 지정된 값이 릴레이 로그 색인 파일의 기본 이름으로도 사용됩니다.
# relay_log_index 시스템 변수를 사용하여 다른 릴레이 로그 인덱스 파일 기본 이름을 지정하여이 동작을 무시할 수 있습니다.
# 
# 서버는 색인 파일에서 항목을 읽을 때 항목에 상대 경로가 포함되어 있는지 확인합니다. 그렇다면 경로의 상대 부분이 relay_log 시스템 변수를 사용하여 설정된 절대 경로로 바뀝니다.
# 절대 경로는 변경되지 않습니다. 이 경우 새 경로를 사용할 수 있도록 색인을 수동으로 편집해야합니다.
# 
# 다음 작업을 수행하는 데 relay_log 시스템 변수가 유용 할 수 있습니다.
# 
# - 이름이 호스트 이름과 독립적 인 릴레이 로그 생성.
# - 릴레이 로그가 매우 큰 경향이 있고 max_relay_log_size를 줄이고 싶지 않기 때문에 데이터 디렉토리 이외의 다른 영역에 릴레이 로그를 넣어야하는 경우.
# - 디스크간 로드 균형 조정을 사용하여 속도를 향상시킵니다.
# 
# relay_log_basename 시스템 변수에서 릴레이 로그 파일 이름 및 경로를 얻을 수 있습니다.
#
# * Apply Option
# relay_log=direcoty/relay_log_filename
# 
# --------------------------------------------
# 
# @ relay_log_basename
# 
# Property : Value
# System Variable : relay_log_basename
# Scope : Global
# Dynamic : No
# Type : File name
# 
# Default Value : datadir + '/' + hostname + '-relay-bin'
# Holds the name and complete path to the relay log file. This variable is set by the server and is read only.
# 기본값 datadir + '/'+ hostname + '-relay-bin'
# 릴레이 로그 파일의 이름과 전체 경로를 보유합니다. 이 변수는 서버에 의해 설정되며 읽기 전용입니다.
#
# * Apply Option
# relay_log_basename=relay_log_basename
# 
# --------------------------------------------
# 
# @ relay_log_index
# 
# Property : Value
# Command-Line Format : --relay-log-index=file_name
# System Variable : relay_log_index
# Scope : Global
# Dynamic : No
# Type : File name
# Default Value : *host_name*-relay-bin.index
# 
# 릴레이 로그 인덱스 파일의 이름입니다. 기본 복제 채널의 기본 이름은 host_name-relay-bin.index입니다.
# 기본이 아닌 복제 채널의 경우 기본 이름은 host_name-relay-bin-channel.index입니다. 여기서 channel은이 릴레이 로그 인덱스에 기록 된 복제 채널의 이름입니다.
# 
# 다른 디렉토리를 지정하기 위해 이름에 선행 절대 경로 이름이 지정되지 않은 한 서버는 파일을 데이터 디렉토리에 기록합니다. 이름.
# 
# MySQL이 서버 옵션을 구문 분석하는 방식으로 인해 서버 시작시이 변수를 지정하면 값을 제공해야합니다. 옵션이 실제로 지정되지 않은 경우에만 기본 기본 이름이 사용됩니다.
# 서버 시작시 값을 지정하지 않고 relay_log_index 시스템 변수를 지정하면 예기치 않은 동작이 발생할 수 있습니다.
# 이 동작은 사용 된 다른 옵션, 지정된 순서 및 명령 줄 또는 옵션 파일에 지정되어 있는지에 따라 다릅니다.
# MySQL이 서버 옵션을 처리하는 방법에 대한 자세한 내용은 4.2.2 절“프로그램 옵션 지정”을 참조하십시오.
#
# * Apply Option
# relay_log_index=*host_name*-relay-bin.index
# 
# --------------------------------------------
# 
# @ relay_log_info_file
# 
# Property : Value
# Command-Line Format : --relay-log-info-file=file_name
# System Variable : relay_log_info_file
# Scope : Global
# Dynamic : No
# Type : File name
# Default Value : relay-log.info
# 
# relay_log_info_repository = FILE 인 경우 슬레이브가 릴레이 로그에 대한 정보를 기록하는 파일의 이름입니다.
# relay_log_info_repository = TABLE 인 경우 리포지토리가 FILE로 변경된 경우에 사용되는 파일 이름입니다. 기본 이름은 데이터 디렉토리의 relay-log.info입니다.
#
# * Apply Option
# relay_log_info_file=relay-log.info
# 
# --------------------------------------------
# 
# @ relay_log_info_repository
# 
# Property : Value
# Command-Line Format : --relay-log-info-repository=value
# System Variable : relay_log_info_repository
# Scope : Global
# Dynamic : Yes
# Type : String
# Default Value : FILE
# Valid Values  : FILE, TABLE
# 
# 이 변수는 릴레이 로그에서 슬레이브의 위치가 FILE (relay-log.info) 또는 TABLE (mysql.slave_relay_log_info)에 기록되는지 여부를 결정합니다.
# 복제 스레드가 실행되고 있지 않을 때만이 변수의 값을 변경할 수 있습니다.
# 
# 이 변수의 설정은 또한 sync_relay_log_info 시스템 변수의 설정에 의한 영향에 직접적인 영향을 미칩니다. 자세한 내용은 해당 변수 설명을 참조하십시오.
# 
# 여러 복제 채널을 구성하기 전에이 변수를 TABLE로 설정해야합니다. 다중 복제 채널을 사용하는 경우 값을 다시 FILE로 설정할 수 없습니다.
#
# * Apply Option
# relay_log_info_repository=FILE
# 
# --------------------------------------------
# 
# @ relay_log_purge
# 
# Property : Value
# Command-Line Format : --relay-log-purge[={OFF|ON}]
# System Variable : relay_log_purge
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 더 이상 필요하지 않은 즉시 릴레이 로그 파일 자동 제거를 비활성화하거나 활성화합니다. 기본값은 1 (ON)입니다.
#
# * Apply Option
# relay_log_purge=ON
# 
# --------------------------------------------
# 
# @ relay_log_recovery
# 
# Property : Value
# Command-Line Format : --relay-log-recovery[={OFF|ON}]
# System Variable : relay_log_recovery
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : OFF
# 
# 사용 가능한 경우 이 변수는 서버 시작 직후에 자동 릴레이 로그 복구를 사용합니다.
# 복구 프로세스는 새 릴레이 로그 파일을 작성하고이 새 릴레이 로그로 SQL 스레드 위치를 초기화 한 후 I / O 스레드를 SQL 스레드 위치로 초기화합니다.
# 그런 다음 마스터에서 릴레이 로그를 읽습니다. 이 전역 변수는 런타임시 읽기 전용입니다. 슬레이브 시작시 --relay-log-recovery 옵션을 사용하여 값을 설정할 수 있습니다.
# 이 옵션은 예상치 못한 복제 슬레이브 중단 후 릴레이 로그가 손상되지 않도록 사용해야합니다. 이 옵션을 사용하면 슬레이브가 예기치 않은 중지에 대해 복원력을 갖도록 할 수 있습니다.
# 자세한 내용은 16.3.2 절“예상치 않은 복제 슬레이브 중지 처리”를 참조하십시오.
# 
# 이 변수는 더 이상 필요하지 않을 때 로그 제거를 제어하는 ​​relay_log_purge 변수와 상호 작용합니다.
# relay_log_purge가 비활성화 된 경우 relay_log_recovery를 활성화하면 제거되지 않은 파일에서 릴레이 로그를 읽을 때 데이터가 일치하지 않을 위험이 있습니다.
# 
# 멀티 스레드 슬레이브를 사용할 때 (즉, slave_parallel_workers가 0보다 큰 경우) 릴레이 로그에서 실행 된 트랜잭션 순서에서 간격과 같은 불일치가 발생할 수 있습니다.
# 불일치가있을 때 relay_log_recovery를 활성화하면 오류가 발생하고 옵션이 적용되지 않습니다.
# 이 상황에서 해결책은 서버를보다 일관된 상태로 만드는 START SLAVE UNTIL SQL_AFTER_MTS_GAPS를 발행 한 다음 RESET SLAVE를 발행하여 릴레이 로그를 제거하는 것입니다.
# 자세한 내용은 16.4.1.32 절“복제 및 트랜잭션 불일치”를 참조하십시오.
# 
# 노트
# 이 변수는 다음 그룹 복제 채널에 영향을 미치지 않습니다.
# - group_replication_applier
# - group_replication_recovery
# 
# 외부 마스터 나 다른 그룹에서 복제되는 채널과 같이 그룹에서 실행중인 다른 모든 채널이 영향을받습니다.
#
# * Apply Option
# relay_log_recovery=OFF
# 
# --------------------------------------------
# 
# @ report_host
# 
# Property : Value
# Command-Line Format : --report-host=host_name
# System Variable : report_host
# Scope : Global
# Dynamic : No
# Type : String
# 
# 슬레이브 등록 중에 마스터에보고 할 슬레이브의 호스트 이름 또는 IP 주소입니다.
# 이 값은 마스터 서버의 SHOW SLAVE HOSTS 출력에 나타납니다. 슬레이브가 마스터에 자신을 등록하지 않게하려면 값을 설정하지 않은 상태로 두십시오.
# 
# 노트
# 슬레이브가 연결된 후 마스터가 단순히 TCP / IP 소켓에서 슬레이브의 IP 주소를 읽는 것으로 충분하지 않습니다.
# NAT 및 기타 라우팅 문제로 인해 해당 IP가 마스터 또는 다른 호스트에서 슬레이브에 연결하는 데 유효하지 않을 수 있습니다.
#
# * Apply Option
# report_host=host_name
# 
# --------------------------------------------
# 
# @ report_password
# 
# Property : Value
# Command-Line Format : --report-password=name
# System Variable : report_password
# Scope : Global
# Dynamic : No
# Type : String
# 
# 슬레이브 등록 중에 마스터에보고 될 슬레이브의 계정 비밀번호입니다. 마스터가 --show-slave-auth-info로 시작된 경우이 값은 마스터 서버의 SHOW SLAVE HOSTS 출력에 나타납니다.
# 
# 이 변수의 이름이 달리 암시 할 수도 있지만 report_password는 MySQL 사용자 권한 시스템에 연결되어 있지 않으므로 MySQL 복제 사용자 계정의 암호와 반드시 같거나 같을 필요는 없습니다.
#
# * Apply Option
# report_password=none
# 
# --------------------------------------------
# 
# @ report_port
# 
# Property : Value
# Command-Line Format : --report-port=port_num
# System Variable : report_port
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : [slave_port]
# Minimum Value : 0
# Maximum Value : 65535
# 
# 슬레이브 등록시 슬레이브에 연결하기위한 TCP / IP 포트 번호가 마스터에보고됩니다.
# 슬레이브가 기본 포트가 아닌 포트에서 수신 대기 중이거나 마스터 또는 다른 클라이언트에서 슬레이브로의 특수 터널이있는 경우에만 설정하십시오. 확실하지 않으면이 옵션을 사용하지 마십시오.
# 
# 이 옵션의 기본값은 슬레이브가 실제로 사용하는 포트 번호입니다. SHOW SLAVE HOSTS에 의해 표시되는 기본값이기도합니다.
#
# * Apply Option
# report_port=slave_port
# 
# --------------------------------------------
# 
# @ report_user
# 
# Property : Value
# Command-Line Format : --report-user=name
# System Variable : report_user
# Scope : Global
# Dynamic : No
# Type : String
# 
# 슬레이브 등록 중에 마스터에보고 될 슬레이브의 계정 사용자 이름입니다. 마스터가 --show-slave-auth-info로 시작된 경우이 값은 마스터 서버의 SHOW SLAVE HOSTS 출력에 나타납니다.
# 
# 이 변수의 이름은 달리 의미 할 수 있지만 report_user는 MySQL 사용자 권한 시스템에 연결되어 있지 않으므로 MySQL 복제 사용자 계정의 이름과 반드시 ​​같거나 같을 필요는 없습니다.
#
# * Apply Option
# report_user=username
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_slave_enabled
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-slave-enabled[={OFF|ON}]
# System Variable : rpl_semi_sync_slave_enabled
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 슬레이브에서 반동기 복제를 사용할지 여부를 제어합니다. 플러그인을 활성화 또는 비활성화하려면이 변수를 각각 ON 또는 OFF (또는 1 또는 0)로 설정하십시오. 기본 설정은 OFF입니다.
# 
# 이 변수는 슬레이브 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_slave_enabled=OFF
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_slave_trace_level
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-slave-trace-level=#
# System Variable : rpl_semi_sync_slave_trace_level
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 32
# 
# 슬레이브의 반 동기식 복제 디버그 추적 수준입니다. 허용 가능한 값은 rpl_semi_sync_master_trace_level을 참조하십시오.
# 
# 이 변수는 슬레이브 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_slave_trace_level=32
# 
# --------------------------------------------
# 
# @ rpl_stop_slave_timeout
# 
# Property : Value
# Command-Line Format : --rpl-stop-slave-timeout=seconds
# System Variable : rpl_stop_slave_timeout
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 31536000
# Minimum Value : 2
# Maximum Value : 31536000
# 
# 이 변수를 설정하여 시간 초과 전에 STOP SLAVE가 대기하는 시간 (초)을 제어 할 수 있습니다.
# 이는 슬레이브에 대한 다른 클라이언트 연결을 사용하여 STOP SLAVE와 다른 슬레이브 SQL 문 사이의 교착 상태를 피하기 위해 사용할 수 있습니다.
# 
# rpl_stop_slave_timeout의 최대 값과 기본값은 31536000 초 (1 년)입니다. 최소값은 2 초입니다. 이 변수에 대한 변경 사항은 후속 STOP SLAVE 문에 적용됩니다.
# 
# 이 변수는 STOP SLAVE 문을 발행하는 클라이언트에만 영향을줍니다. 시간 종료에 도달하면 발행 클라이언트는 명령 실행이 완료되지 않았다는 오류 메시지를 리턴합니다.
# 그런 다음 클라이언트는 슬레이브 스레드가 중지되기를 기다리는 것을 중지하지만 슬레이브 스레드는 계속 중지를 시도하고 STOP SLAVE 명령은 계속 유효합니다.
# 슬레이브 스레드가 더 이상 사용되지 않으면 STOP SLAVE 문이 실행되고 슬레이브가 중지됩니다.
#
# * Apply Option
# rpl_stop_slave_timeout=31536000
# 
# --------------------------------------------
# 
# @ slave_checkpoint_group
# 
# Property : Value
# Command-Line Format : --slave-checkpoint-group=#
# System Variable : slave_checkpoint_group
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 512
# Minimum Value : 32
# Maximum Value : 524280
# Block Size	8
# 
# SHOW SLAVE STATUS에 표시된대로 상태를 업데이트하기 위해 검사 점 작업을 호출하기 전에 멀티 스레드 슬레이브가 처리 할 수있는 최대 트랜잭션 수를 설정합니다.
# 이 변수를 설정해도 멀티 스레딩이 활성화되지 않은 슬레이브에는 영향을 미치지 않습니다. 이 변수를 설정해도 즉각적인 효과는 없습니다. 변수 상태는 모든 후속 START SLAVE 명령에 적용됩니다.
# 
# 노트
# 멀티 스레드 슬레이브는 현재 NDB 클러스터에서 지원되지 않으며이 변수의 설정을 자동으로 무시합니다. 자세한 내용은 21.6.3 절“NDB 클러스터 복제의 알려진 문제”를 참조하십시오.
# 
# 이 변수는 slave_checkpoint_period 시스템 변수와 함께 작동하여 어느 한도를 초과하면 검사 점이 실행되고
# 카운터가 트랜잭션 수와 마지막 검사 점 이후 경과 된 시간을 모두 추적하는 카운터가 재설정됩니다.
# 
# 서버가 -DWITH_DEBUG를 사용하여 빌드 된 경우를 제외하고이 변수에 허용되는 최소값은 32입니다.이 경우 최소값은 1입니다. 유효 값은 항상 8의 배수입니다.
# 이 값을 배수가 아닌 값으로 설정할 수 있지만 서버는 값을 저장하기 전에 값을 8의 다음 하위 배수로 내림합니다. (예외 : 디버그 서버는 이러한 반올림을 수행하지 않습니다.)
# 서버의 구축 방법에 관계없이 기본값은 512이고 최대 허용 값은 524280입니다.
#
# * Apply Option
# slave_checkpoint_group=512
# 
# --------------------------------------------
# 
# @ slave_checkpoint_period
# 
# Property : Value
# Command-Line Format : --slave-checkpoint-period=#
# System Variable : slave_checkpoint_period
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 300
# Minimum Value : 1
# Maximum Value : 4G
# 
# SHOW SLAVE STATUS에 표시된대로 멀티 스레드 슬레이브의 상태를 업데이트하기 위해 검사 점 작업을 호출하기 전에 통과 할 수있는 최대 시간 (밀리 초)을 설정합니다.
# 이 변수를 설정해도 멀티 스레딩이 활성화되지 않은 슬레이브에는 영향을 미치지 않습니다. 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# 노트
# 멀티 스레드 슬레이브는 현재 NDB 클러스터에서 지원되지 않으며이 변수의 설정을 자동으로 무시합니다. 자세한 내용은 21.6.3 절“NDB 클러스터 복제의 알려진 문제”를 참조하십시오.
# 
# 이 변수는 한계를 초과 할 때 검사 점이 실행되고 마지막 검사 점 이후의 트랜잭션 수와 경과 시간을 추적하는 카운터가 카운터를 초기화하는 방식으로 slave_checkpoint_group 시스템 변수와 함께 작동합니다.
# 
# 서버가 -DWITH_DEBUG를 사용하여 빌드 된 경우를 제외하고이 변수에 허용되는 최소값은 1입니다. 이 경우 최소값은 0입니다. 서버의 빌드 방법에 관계없이 기본값은 300이며 가능한 최대 값은 4294967296 ( 4GB).
#
# * Apply Option
# slave_checkpoint_period=300
# 
# --------------------------------------------
# 
# @ slave_compressed_protocol
# 
# Property : Value
# Command-Line Format : --slave-compressed-protocol[={OFF|ON}]
# System Variable : slave_compressed_protocol
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 마스터 및 슬레이브 프로토콜이 모두 지원하는 경우 마스터 / 슬레이브 프로토콜의 압축 사용 여부입니다. 이 변수를 비활성화하면 (기본값) 연결이 압축 해제됩니다.
# 이 변수에 대한 변경 사항은 후속 연결 시도에 적용됩니다. 여기에는 START SLAVE 문을 발행 한 후 실행중인 I / O 스레드에 의한 재 연결
# (예 : CHANGE MASTER TO 문에 대해 MASTER_RETRY_COUNT 옵션을 설정 한 후)이 포함됩니다.
# 4.2.5 절“연결 압축 제어”도 참조하십시오.
#
# * Apply Option
# slave_compressed_protocol=OFF
# 
# --------------------------------------------
# 
# @ slave_exec_mode
# 
# Property : Value
# Command-Line Format : --slave-exec-mode=mode
# System Variable : slave_exec_mode
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : IDEMPOTENT (NDB), STRICT (Other)
# Valid Values  : IDEMPOTENT, STRICT
# 
# 슬레이브 스레드가 복제 중 충돌 및 오류를 해결하는 방법을 제어합니다. IDEMPOTENT 모드는 중복 키 및 키가없는 오류를 억제합니다. 엄격은 그러한 억제가 일어나지 않음을 의미합니다.
# 
# IDEMPOTENT 모드는 다중 마스터 복제, 순환 복제 및 NDB 클러스터 복제를위한 기타 특수 복제 시나리오에서 사용하기위한 것입니다.
# 자세한 내용은 21.6.10 절“NDB 클러스터 복제 : 다중 마스터 및 순환 복제”및 21.6.11 절“NDB 클러스터 복제 충돌 해결”을 참조하십시오.
# NDB 클러스터는 slave_exec_mode에 대해 명시 적으로 설정된 값을 무시합니다. 항상 그것을 IDEMPOTENT로 취급합니다.
# 
# MySQL Server 5.7에서는 STRICT 모드가 기본값입니다.
# 
# NDB 이외의 스토리지 엔진의 경우 IDEMPOTENT 모드는 중복 키 오류 및 키를 찾을 수 없음 오류를 안전하게 무시할 수있는 경우에만 사용해야합니다.
# 다중 마스터 복제 또는 순환 복제가 사용되는 NDB 클러스터의 페일 오버 시나리오에 사용되며 다른 경우에는 사용하지 않는 것이 좋습니다.
#
# * Apply Option
# slave_exec_mode=IDEMPOTENT (NDB), STRICT (Other)
# 
# --------------------------------------------
# 
# @ slave_load_tmpdir
# 
# Property : Value
# Command-Line Format : --slave-load-tmpdir=dir_name
# System Variable : slave_load_tmpdir
# Scope : Global
# Dynamic : No
# Type : Directory name
# Default Value : Value of --tmpdir
# 
# 슬레이브가 임시 파일을 생성하는 디렉토리의 이름입니다. 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 변수 값은 기본적으로 tmpdir 시스템 변수의 값과 같거나 해당 시스템 변수가 지정되지 않은 경우 적용되는 기본값입니다.
# 
# 슬레이브 SQL 스레드는 LOAD DATA 문을 복제 할 때 릴레이 로그에서 임시 파일로로드 할 파일을 추출한 다음 테이블에로드합니다.
# 마스터에로드 된 파일이 크면 슬레이브의 임시 파일도 커집니다. 따라서이 옵션을 사용하여 임시 파일을 사용 가능한 공간이 많은 일부 파일 시스템에있는 디렉토리에 두도록 지시하는 것이 좋습니다.
# 이 경우 릴레이 로그도 매우 커서 릴레이 파일을 해당 파일 시스템에 배치하도록 relay_log 시스템 변수를 설정할 수도 있습니다.
# 
# 이 옵션으로 지정된 디렉토리는 메모리 기반 파일 시스템이 아닌 디스크 기반 파일 시스템에 있어야 LOAD DATA 문을 복제하는 데 사용 된 임시 파일이 시스템을 다시 시작하더라도 살아남을 수 있습니다.
# 또한 디렉토리는 시스템 시작 프로세스 중에 운영 체제가 지우는 디렉토리가 아니어야합니다. 그러나 임시 파일을 제거한 경우 다시 시작한 후 복제를 계속할 수 있습니다.
#
# * Apply Option
# slave_load_tmpdir=dir_name
# 
# --------------------------------------------
# 
# @ slave_max_allowed_packet
# 
# Property : Value
# Command-Line Format : --slave-max-allowed-packet=#
# System Variable : slave_max_allowed_packet
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1073741824
# Minimum Value : 1024
# Maximum Value : 1073741824
# 
# 이 변수는 슬레이브 SQL 및 I / O 스레드의 최대 패킷 크기를 설정하므로 업데이트가 max_allowed_packet을 초과하여
# 행 기반 복제를 사용하는 대규모 업데이트로 인해 복제가 실패하지 않습니다.
# 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# 이 전역 변수는 항상 1024의 양의 정수 배수 인 값을 갖습니다. 그렇지 않은 값으로 설정하면 값이 저장되거나 사용되므로 1024의 다음으로 가장 높은 배수로 내림됩니다.
# slave_max_allowed_packet을 0으로 설정하면 1024가 사용됩니다. (이러한 경우 모두 잘림 경고가 발생합니다.) 기본값 및 최대 값은 1073741824 (1GB)입니다. 최소값은 1024입니다.
#
# * Apply Option
# slave_max_allowed_packet=1073741824
# 
# --------------------------------------------
# 
# @ slave_net_timeout
# 
# Property : Value
# Command-Line Format : --slave-net-timeout=#
# System Variable : slave_net_timeout
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 60
# Minimum Value : 1
# 
# 슬레이브가 연결이 끊어진 것으로 간주하고 읽기를 중단 한 후 다시 연결하려고 시도하기 전에 마스터로부터 더 많은 데이터 또는 하트 비트 신호를 기다리는 시간 (초)입니다.
# 이 변수를 설정해도 즉각적인 효과는 없습니다. 변수 상태는 모든 후속 START SLAVE 명령에 적용됩니다.
# 
# 첫 번째 재 시도는 시간 종료 직후에 발생합니다. 재시도 간격은 CHANGE MASTER TO 문의 MASTER_CONNECT_RETRY 옵션으로 제어되며
# 재 연결 시도 횟수는 CHANGE MASTER TO 문의 MASTER_RETRY_COUNT 옵션으로 제한됩니다.
# 
# 연결 상태가 양호 할 경우 데이터가 없을 때 발생하는 연결 시간 초과를 중지시키는 하트 비트 간격은 CHANGE MASTER TO 문에 대한 MASTER_HEARTBEAT_PERIOD 옵션으로 제어됩니다.
# 하트 비트 간격은 기본적으로 slave_net_timeout 값의 절반으로 설정되며 마스터 정보 로그에 기록되고 replication_connection_configuration 성능 스키마 테이블에 표시됩니다.
# slave_net_timeout의 값 또는 기본 설정을 변경해도 하트 비트 간격이 명시 적으로 설정되었는지 또는 이전에 계산 된 기본값을 사용하는지에 관계없이 자동으로 변경되지는 않습니다.
# 연결 시간 종료가 변경되면 CHANGE MASTER TO도 변경하여 연결 시간 종료 전에 발생하는 하트 비트 간격을 적절한 값으로 조정해야합니다.
#
# * Apply Option
# slave_net_timeout=60
# 
# --------------------------------------------
# 
# @ slave_parallel_type
# 
# Property : Value
# Command-Line Format : --slave-parallel-type=value
# System Variable : slave_parallel_type
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : DATABASE
# Valid Values  : DATABASE, LOGICAL_CLOCK
# 
# 다중 스레드 슬레이브를 사용하는 경우 (slave_parallel_workers가 0보다 큰 경우)이 변수는 슬레이브에서 병렬로 실행할 수있는 트랜잭션을 결정하는 데 사용되는 정책을 지정합니다.
# 이 변수는 멀티 스레딩이 활성화되지 않은 슬레이브에는 영향을 미치지 않습니다. 가능한 값은 다음과 같습니다.
# 
# -LOGICAL_CLOCK : 마스터에서 동일한 이진 로그 그룹 커밋의 일부인 트랜잭션이 슬레이브에 병렬로 적용됩니다. 트랜잭션 간의 종속성은 타임 스탬프를 기반으로 추적되어 가능한 경우 추가 병렬화를 제공합니다.
# 이 값을 설정하면 binlog_transaction_dependency_tracking 시스템 변수를 마스터에서 사용하여 트랜잭션에 쓰기 세트를 사용할 수 있고 타임 스탬프에 비해 향상된 결과를 제공하는 경우,
# 쓰기 세트가 타임 스탬프 대신 병렬화에 사용되도록 지정할 수 있습니다.
# 
# -데이터베이스 : 다른 데이터베이스를 업데이트하는 트랜잭션이 병렬로 적용됩니다. 이 값은 데이터가 마스터에서 독립적으로 동시에 업데이트되는 여러 데이터베이스로 파티션 된 경우에만 적합합니다.
# 데이터베이스 간 제약 조건이 없어야합니다. 이러한 제약 조건이 슬레이브에서 위반 될 수 있습니다.
# 
# slave_preserve_commit_order = 1이 설정되면 LOGICAL_CLOCK 만 사용할 수 있습니다.
# 
# 복제 토폴로지가 여러 레벨의 슬레이브를 사용하는 경우 LOGICAL_CLOCK은 슬레이브가 마스터에서 떨어져있는 각 레벨에 대해 덜 병렬화를 달성 할 수 있습니다.
# 마스터에서 binlog_transaction_dependency_tracking을 사용하여 가능한 경우 병렬화를 위해 타임 스탬프 대신 쓰기 세트가 사용되도록 지정하여이 효과를 줄일 수 있습니다.
#
# * Apply Option
# slave_parallel_type=DATABASE
# 
# --------------------------------------------
# 
# @ slave_parallel_workers
# 
# Property : Value
# Command-Line Format : --slave-parallel-workers=#
# System Variable : slave_parallel_workers
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 1024
# 
# 복제 트랜잭션을 병렬로 실행하기위한 슬레이브 적용자 스레드 수를 설정합니다. 이 변수를 0보다 큰 수로 설정하면이 개수의 적용 가능한 스레드가있는 다중 스레드 슬레이브가 만들어집니다.
# 0 (기본값)으로 설정하면 병렬 실행이 비활성화되고 슬레이브는 단일 적용자 스레드를 사용합니다.
# slave_parallel_workers를 설정해도 즉각적인 효과는 없습니다. 변수 상태는 모든 후속 START SLAVE 문에 적용됩니다.
# 
# 노트
# 멀티 스레드 슬레이브는 현재 NDB 클러스터에서 지원되지 않으며이 변수의 설정을 자동으로 무시합니다. 자세한 내용은 21.6.3 절“NDB 클러스터 복제의 알려진 문제”를 참조하십시오.
# 
# 멀티 스레드 슬레이브는 코디네이터 스레드와이 변수로 구성된 적용자 스레드 수를 사용하여 병렬 실행을 제공합니다.
# Applier 스레드간에 트랜잭션이 분배되는 방식은 slave_parallel_type에 의해 구성됩니다.
# slave_preserve_commit_order = 1이 아닌 한 슬레이브가 병렬로 적용하는 트랜잭션은 순서가 맞지 않을 수 있습니다.
# 따라서 가장 최근에 실행 된 트랜잭션을 확인한다고해서 마스터의 모든 이전 트랜잭션이 슬레이브에서 실행 된 것은 아닙니다.
# 이는 다중 스레드 슬레이브를 사용할 때 로깅 및 복구에 영향을 미칩니다. 예를 들어, 다중 스레드 슬레이브에서 START SLAVE UNTIL 문은 SQL_AFTER_MTS_GAPS 사용 만 지원합니다.
# 
# MySQL 5.7에서는 슬레이브에서 멀티 스레딩이 활성화 된 경우 트랜잭션 재 시도가 지원됩니다.
# 이전 버전에서는 멀티 스레드 슬레이브를 사용할 때 slave_transaction_retries가 0으로 취급되었습니다.
#
# * Apply Option
# slave_parallel_workers=0
# 
# --------------------------------------------
# 
# @ slave_pending_jobs_size_max
# 
# Property : Value
# Command-Line Format : --slave-pending-jobs-size-max=#
# System Variable : slave_pending_jobs_size_max
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 16M
# Minimum Value : 1024
# Maximum Value : 16EiB
# Block Size	1024
# 
# 다중 스레드 슬레이브의 경우이 변수는 아직 적용되지 않은 이벤트를 보유하는 슬레이브 작업자 큐에 사용할 수있는 최대 메모리 양 (바이트)을 설정합니다.
# 이 변수를 설정해도 멀티 스레딩이 활성화되지 않은 슬레이브에는 영향을 미치지 않습니다. 이 변수를 설정해도 즉각적인 효과는 없습니다. 변수 상태는 모든 후속 START SLAVE 명령에 적용됩니다.
# 
# 이 변수의 가능한 최소값은 1024입니다. 기본값은 16MB입니다. 최대 값은 18446744073709551615 (16 엑사 바이트)입니다.
# 1024의 정확한 배수가 아닌 값은 저장되기 전에 1024의 다음으로 높은 배수로 내림됩니다.
# 
# 이 변수의 값은 소프트 한계이며 일반 워크로드와 일치하도록 설정할 수 있습니다.
# 비정상적으로 큰 이벤트가이 크기를 초과하면 모든 슬레이브 작업자가 빈 큐를 가질 때까지 트랜잭션이 보류 된 다음 처리됩니다. 모든 후속 거래는 대규모 거래가 완료 될 때까지 보류됩니다.
#
# * Apply Option
# slave_pending_jobs_size_max=16M
# 
# --------------------------------------------
# 
# @ slave_preserve_commit_order
# 
# Property : Value
# Command-Line Format : --slave-preserve-commit-order[={OFF|ON}]
# System Variable : slave_preserve_commit_order
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 멀티 스레드 슬레이브의 경우이 변수에 1을 설정하면 트랜잭션이 슬레이브의 릴레이 로그에 나타나는 순서대로 슬레이브에서 외부화되고 릴레이 로그에서 실행 된 트랜잭션 순서의 간격이 방지됩니다.
# 이 변수는 멀티 스레딩이 활성화되지 않은 슬레이브에는 영향을 미치지 않습니다.
# slave_preserve_commit_order = 1은 비 트랜잭션 DML 업데이트의 순서를 유지하지 않으므로 릴레이 로그에서 트랜잭션보다 우선하는 트랜잭션보다 먼저 커밋되어 간격이 생길 수 있습니다.
# 
# slave_preserve_commit_order = 1을 사용하려면 슬레이브에서 --log-bin 및 --log-slave-updates를 활성화하고 slave_parallel_type을 LOGICAL_CLOCK으로 설정해야합니다.
# 이 변수를 변경하기 전에 모든 복제 스레드 (여러 복제 채널을 사용하는 경우 모든 복제 채널에 대해)를 중지해야합니다.
# 
# slave_preserve_commit_order가 활성화되면 실행 스레드는 커밋 전에 모든 이전 트랜잭션이 커밋 될 때까지 기다립니다.
# 슬레이브 스레드는 다른 작업자가 트랜잭션을 커밋하기를 기다리는 동안 이전 트랜잭션이 커밋되기를 기다리는 중으로 상태를보고합니다.
# (MySQL 5.7.8 이전에는 이것이 커밋을 기다리는 중으로 표시되었습니다.)
# 다중 스레드 슬레이브에서이 모드를 활성화하면 마스터가없는 상태로 들어 가지 않습니다. 이는 읽기 스케일에 대한 복제 사용을 지원합니다. -밖. 16.3.4 절.“스케일 아웃에 복제 사용”을 참조하십시오.
# 
# slave_preserve_commit_order = 0을 설정하면 슬레이브가 병렬로 적용하는 트랜잭션의 순서가 잘못 될 수 있습니다.
# 따라서 가장 최근에 실행 된 트랜잭션을 확인한다고해서 마스터의 모든 이전 트랜잭션이 슬레이브에서 실행 된 것은 아닙니다.
# 슬레이브의 릴레이 로그에서 실행 된 트랜잭션 순서에 차이가있을 수 있습니다. 이는 다중 스레드 슬레이브를 사용할 때 로깅 및 복구에 영향을 미칩니다.
# slave_preserve_commit_order = 1 설정은 간격을 방지하지만 마스터 로그 위치 지연 (Exec_master_log_pos가 트랜잭션이 실행 된 위치 뒤에 있음)을 방지하지는 않습니다.
# 자세한 내용은 16.4.1.32 절“복제 및 트랜잭션 불일치”를 참조하십시오.
#
# * Apply Option
# slave_preserve_commit_order=OFF
# 
# --------------------------------------------
# 
# @ slave_rows_search_algorithms
# 
# Property : Value
# Command-Line Format : --slave-rows-search-algorithms=value
# System Variable : slave_rows_search_algorithms
# Scope : Global
# Dynamic : Yes
# Type : Set
# Default Value : TABLE_SCAN,INDEX_SCAN
# Valid Values  : :
# TABLE_SCAN,INDEX_SCAN
# INDEX_SCAN,HASH_SCAN
# TABLE_SCAN,HASH_SCAN
# TABLE_SCAN,INDEX_SCAN,HASH_SCAN (equivalent to INDEX_SCAN,HASH_SCAN)
# 
# 행 기반 로깅 및 복제를 위해 행 배치를 준비 할 때이 변수는 행에서 일치 항목을 검색하는 방법, 특히 해시 스캔 사용 여부를 제어합니다.
# 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# INDEX_SCAN, TABLE_SCAN, HASH_SCAN 목록에서 다음 두 값 조합의 쉼표로 구분 된 목록을 지정하십시오.
# 값은 문자열로 예상되므로 서버 시작이 아닌 런타임시 설정되면 값을 인용해야합니다. 또한 값에 공백이 없어야합니다. 권장되는 조합 (목록)과 그 효과는 다음 표에 나와 있습니다.
# 
# Index used / option value	| INDEX_SCAN,HASH_SCAN | INDEX_SCAN,TABLE_SCAN
# Primary key or unique key	| Index scan	         | Index scan
# (Other) Key	              | Hash scan over index | Index scan
# No index                  | Hash scan            | Table scan
# 
# -기본값은 INDEX_SCAN, TABLE_SCAN입니다. 이는 인덱스를 사용할 수있는 모든 검색에서이를 사용하며 인덱스가없는 검색은 테이블 스캔을 사용함을 의미합니다.
# -기본 또는 고유 키를 사용하지 않는 검색에 해싱을 사용하려면 INDEX_SCAN, HASH_SCAN을 설정하십시오.
# INDEX_SCAN, HASH_SCAN을 지정하면 허용되는 INDEX_SCAN, TABLE_SCAN, HASH_SCAN을 지정하는 것과 동일한 효과가 있습니다.
# -TABLE_SCAN, HASH_SCAN 조합을 사용하지 마십시오. 이 설정은 모든 검색을 강제로 해싱합니다.
#  INDEX_SCAN, HASH_SCAN에 비해 이점이 없으며 동일한 행에 대한 여러 업데이트가 포함 된 단일 이벤트 또는 순서에 따른 업데이트의 경우
# "레코드를 찾을 수 없음"오류 또는 중복 키 오류가 발생할 수 있습니다.
# 
# 알고리즘이 목록에 지정된 순서는 SELECT 또는 SHOW VARIABLES 문에 의해 표시되는 순서와 차이가 없습니다.
# 
# 단일 값을 지정할 수는 있지만 단일 값을 설정하면 해당 알고리즘 만 사용하도록 검색이 제한되므로 최적이 아닙니다.
# 특히 인덱스가 없으면 검색에서 행을 찾을 수 없으므로 INDEX_SCAN 만 설정하지 않는 것이 좋습니다.
#
# * Apply Option
# slave_rows_search_algorithms=TABLE_SCAN,INDEX_SCAN
# 
# --------------------------------------------
# 
# @ slave_skip_errors
# 
# Property : Value
# Command-Line Format : --slave-skip-errors=name
# System Variable : slave_skip_errors
# Scope : Global
# Dynamic : No
# Type : String
# Default Value : OFF
# Valid Values  : OFF
# [list of error codes]
# all
# ddl_exist_errors
# 
# 일반적으로 슬레이브에서 오류가 발생하면 복제가 중지되므로 데이터의 불일치를 수동으로 해결할 수 있습니다.
# 이 변수는 명령문이 변수 값에 나열된 오류를 리턴 할 때 슬레이브 SQL 스레드가 복제를 계속하게합니다.
#
# * Apply Option
# slave_skip_errors=OFF
# 
# --------------------------------------------
# 
# @ slave_sql_verify_checksum
# 
# Property : Value
# Command-Line Format : --slave-sql-verify-checksum[={OFF|ON}]
# System Variable : slave_sql_verify_checksum
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 슬레이브 SQL 스레드가 릴레이 로그에서 읽은 체크섬을 사용하여 데이터를 확인하게합니다.
# 불일치가 발생하면 슬레이브는 오류와 함께 정지합니다. 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# 노트
# 슬레이브 I / O 스레드는 네트워크를 통해 이벤트를 수락 할 때 가능하면 항상 체크섬을 읽습니다.
#
# * Apply Option
# slave_sql_verify_checksum=ON
# 
# --------------------------------------------
# 
# @ slave_transaction_retries
# 
# Property : Value
# Command-Line Format : --slave-transaction-retries=#
# System Variable : slave_transaction_retries
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10
# Minimum Value : 0
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 복제 슬레이브 SQL 스레드가 InnoDB 교착 상태로 인해 트랜잭션을 실행하지 못하거나 트랜잭션의 실행 시간이
# InnoDB의 innodb_lock_wait_timeout 또는 NDB의 TransactionDeadlockDetectionTimeout
# 또는 TransactionInactiveTimeout을 초과하여 트랜잭션을 실행하지 못하면 오류가 발생하기 전에 slave_transaction_retries 시간을 자동으로 재 시도합니다.
# 일시적이지 않은 오류가 있는 트랜잭션은 재시도되지 않습니다.
# 
# slave_transaction_retries의 기본값은 10입니다. 변수를 0으로 설정하면 트랜잭션의 자동 재 시도를 사용하지 않습니다.
# 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# MySQL 5.7.5부터 슬레이브에서 멀티 스레딩이 활성화되면 트랜잭션 재 시도가 지원됩니다.
# 이전 버전에서는 멀티 스레드 슬레이브를 사용할 때 slave_transaction_retries가 0으로 취급되었습니다.
# 
# 성능 스키마 테이블 replication_applier_status는 각 복제 채널에서 발생한 재시도 횟수를 COUNT_TRANSACTIONS_RETRIES 열에 표시합니다.
#
# * Apply Option
# slave_transaction_retries=10
# 
# --------------------------------------------
# 
# @ slave_type_conversions
# 
# Property : Value
# Command-Line Format : --slave-type-conversions=set
# System Variable : slave_type_conversions
# Scope : Global
# Dynamic : No
# Type : Set
# Default Value : 
# Valid Values  : ALL_LOSSY, ALL_NON_LOSSY, ALL_SIGNED, ALL_UNSIGNED
# 
# 행 기반 복제를 사용할 때 슬레이브에 적용되는 유형 변환 모드를 제어합니다.
# MySQL 5.7.2 이상에서이 값은 쉼표로 구분 된 ALL_LOSSY, ALL_NON_LOSSY, ALL_SIGNED, ALL_UNSIGNED 목록에서 0 개 이상의 요소로 구성된 세트입니다.
# 마스터와 슬레이브 사이의 유형 변환을 허용하지 않으려면이 변수를 빈 문자열로 설정하십시오. 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# ALL_SIGNED 및 ALL_UNSIGNED가 MySQL 5.7.2 (버그 # 15831300)에 추가되었습니다.
# 행 기반 복제에서 속성 승격 및 수준 내리기에 적용 가능한 유형 변환 모드에 대한 자세한 내용은 행 기반 복제 : 속성 승격 및 수준 내리기를 참조하십시오.
#
# * Apply Option
# slave_type_conversions=none
# 
# --------------------------------------------
# 
# @ sql_slave_skip_counter
# 
# Property : Value
# System Variable : sql_slave_skip_counter
# Scope : Global
# Dynamic : Yes
# Type : Integer
# 
# 슬레이브 서버가 건너 뛰어야하는 마스터의 이벤트 수입니다. 옵션을 설정해도 즉각적인 효과는 없습니다. 변수는 다음 START SLAVE 문에 적용됩니다.
# 다음 START SLAVE 문도 값을 다시 0으로 변경합니다.
# 이 변수가 0이 아닌 값으로 설정되고 여러 복제 채널이 구성된 경우 START SLAVE 문은 FOR CHANNEL 채널 절에서만 사용할 수 있습니다.
# 
# 이 옵션은 GTID 기반 복제와 호환되지 않으며 gtid_mode = ON 인 경우 0이 아닌 값으로 설정해서는 안됩니다.
# GTID를 사용할 때 트랜잭션을 건너 뛰려면 대신 마스터에서 gtid_executed를 사용하십시오. 이를 수행하는 방법에 대한 정보는 빈 트랜잭션 주입을 참조하십시오.
# 
# 중대한
# 이 변수를 설정하여 지정된 이벤트 수를 건너 뛰면 슬레이브가 이벤트 그룹 중간에서 시작되는 경우 슬레이브는 다음 이벤트 그룹의 시작을 찾아 해당 지점에서 시작할 때까지 계속 건너 뜁니다.
# 자세한 내용은 13.4.2.5 절“SET GLOBAL sql_slave_skip_counter 문”을 참조하십시오.
#
# * Apply Option
# sql_slave_skip_counter=none
# 
# --------------------------------------------
# 
# @ sync_master_info
# 
# Property : Value
# Command-Line Format : --sync-master-info=#
# System Variable : sync_master_info
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10000
# Minimum Value : 0
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 복제 슬레이브에 대한이 변수의 영향은 다음 단락에서 설명하는 것처럼 슬레이브의 master_info_repository가 FILE 또는 TABLE로 설정되어 있는지 여부에 따라 다릅니다.
# 
# master_info_repository = 파일 sync_master_info의 값이 0보다 크면 슬레이브는 모든 sync_master_info 이벤트 후 fdatasync ()를 사용하여 master.info 파일을 디스크에 동기화합니다.
# 0이면 MySQL 서버는 master.info 파일을 디스크에 동기화하지 않습니다. 대신 서버는 운영 체제에 의존하여 다른 파일과 마찬가지로 내용을 주기적으로 플러시합니다.
# 
# master_info_repository = 테이블. sync_master_info의 값이 0보다 크면 슬레이브는 모든 sync_master_info 이벤트 후에 마스터 정보 저장소 테이블을 업데이트합니다.
# 0이면 테이블이 업데이트되지 않습니다.
# 
# sync_master_info의 기본값은 10000입니다.이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
#
# * Apply Option
# sync_master_info=10000
# 
# --------------------------------------------
# 
# @ sync_relay_log
# 
# Property : Value
# Command-Line Format : --sync-relay-log=#
# System Variable : sync_relay_log
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10000
# Minimum Value : 0
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 이 변수의 값이 0보다 크면 MySQL 서버는 모든 sync_relay_log 이벤트가 릴레이 로그에 기록 된 후 릴레이 로그를 디스크에 동기화합니다 (fdatasync () 사용).
# 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# sync_relay_log를 0으로 설정하면 디스크에 대한 동기화가 수행되지 않습니다.
# 이 경우 서버는 운영 체제를 사용하여 다른 파일과 마찬가지로 릴레이 로그의 내용을 수시로 플러시합니다.
# 
# 충돌이 발생하면 릴레이 로그에서 최대 하나의 이벤트가 손실되므로 값 1이 가장 안전한 선택입니다.
# 그러나 디스크에 배터리 백업 캐시가 없어 동기화 속도가 매우 빠르지 않은 한 가장 느린 선택이기도합니다.
#
# * Apply Option
# sync_relay_log=10000
# 
# --------------------------------------------
# 
# @ sync_relay_log_info
# 
# Property : Value
# Command-Line Format : --sync-relay-log-info=#
# System Variable : sync_relay_log_info
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10000
# Minimum Value : 0
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# sync_relay_log_info의 기본값은 10000입니다.이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# 복제 슬레이브에서이 변수의 영향은 서버의 relay_log_info_repository 설정 (FILE 또는 TABLE)에 따라 다릅니다.
# 설정이 TABLE 인 경우 변수의 영향은 릴레이 로그 정보 테이블에서 사용하는 스토리지 엔진이 트랜잭션 (InnoDB 등)인지 트랜잭션 (MyISAM)인지에 따라 달라집니다.
# sync_relay_log_info 값이 0보다 크고 0보다 큰 서버의 동작에 대한 이러한 요인의 영향은 다음과 같습니다.
# 
# sync_relay_log_info = 0
# - relay_log_info_repository가 FILE로 설정된 경우 MySQL 서버는 relay-log.info 파일을 디스크에 동기화하지 않습니다.
# 대신 서버는 운영 체제에 의존하여 다른 파일과 마찬가지로 내용을 주기적으로 플러시합니다.
# - relay_log_info_repository가 TABLE로 설정되고 해당 테이블의 스토리지 엔진이 트랜잭션 인 경우 테이블은 각 트랜잭션 후에 업데이트됩니다.
# 이 경우 sync_relay_log_info 설정은 효과적으로 무시됩니다.
# - relay_log_info_repository가 TABLE로 설정되고 해당 테이블의 스토리지 엔진이 트랜잭션이 아닌 경우 테이블은 업데이트되지 않습니다.
# 
# sync_relay_log_info = N > 0
# - relay_log_info_repository가 FILE로 설정된 경우 슬레이브는 매 N 트랜잭션 후 relay-log.info 파일을 디스크에 동기화합니다 (fdatasync () 사용).
# - relay_log_info_repository가 TABLE로 설정되고 해당 테이블의 스토리지 엔진이 트랜잭션 인 경우 테이블은 각 트랜잭션 후에 업데이트됩니다.
# 이 경우 sync_relay_log_info 설정은 효과적으로 무시됩니다.
# - relay_log_info_repository가 TABLE로 설정되고 해당 테이블의 스토리지 엔진이 트랜잭션이 아닌 경우 테이블은 N 개의 이벤트마다 업데이트됩니다.
#
# * Apply Option
# sync_relay_log_info=10000
#
# --------------------------------------------
# 
# @ read_only
# 
# Command-Line Format	--read-only[={OFF|ON}]
# System Variable	read_only
# Scope	Global
# Dynamic	Yes
# Type	Boolean
# Default Value	OFF
# 
# read_only 시스템 변수가 활성화되면 서버는 SUPER 권한이있는 사용자를 제외하고는 클라이언트 업데이트를 허용하지 않습니다. 이 변수는 기본적으로 비활성화되어 있습니다.
# 
# 서버는 또한 super_read_only 시스템 변수 (기본적으로 비활성화 됨)를 지원하며 다음과 같은 효과가 있습니다.
#   -super_read_only가 활성화 된 경우 서버는 SUPER 권한이있는 사용자로부터도 클라이언트 업데이트를 금지합니다.
#   -super_read_only를 ON으로 설정하면 암시 적으로 read_only를 ON으로 강제합니다.
#   -read_only를 OFF로 설정하면 암시 적으로 super_read_only를 OFF로 강제합니다.
# 
# read_only가 활성화된 경우에도 서버는 다음 작업을 허용합니다.
#   - 서버가 복제 복제 본인 경우 복제본 스레드에서 수행하는 업데이트입니다. 복제 설정에서 복제본이 클라이언트가 아닌 원본 서버에서만
      업데이트를 수락하도록 복제본 서버에서 read_only를 활성화하는 것이 유용 할 수 있습니다.
#   - ANALYZE TABLE 또는 OPTIMIZE TABLE 문 사용. 읽기 전용 모드의 목적은 테이블 구조 또는 내용의 변경을 방지하는 것입니다. 분석 및 최적화는 그러한 변경에 해당되지 않습니다.
#     예를 들어 mysqlcheck --all-databases --analyze를 사용하여 읽기 전용 복제 복제본에 대한 일관성 검사를 수행할 수 있습니다.
#   - TEMPORARY 테이블에 대한 작업.
#   - 로그 테이블 (mysql.general_log 및 mysql.slow_log)에 삽입합니다. 5.4.1 절.“일반 쿼리 로그 및 느린 쿼리 로그 출력 대상 선택”을 참조하십시오.
#   - MySQL 5.7.16부터 UPDATE 또는 TRUNCATE TABLE 작업과 같은 성능 스키마 테이블이 업데이트되었습니다.
# 
# 원본 서버에서 read_only에 대한 변경 사항은 복제본 서버에 복제되지 않습니다. 값은 소스의 설정에 관계없이 복제 서버에서 설정할 수 있습니다.
#
# 다음 조건은 read_only를 활성화하려는 시도에 적용됩니다 (super_read_only 활성화로 인한 암시 적 시도 포함).
#   -명시 적 잠금 (LOCK TABLES로 획득)이 있거나 보류중인 트랜잭션이있는 경우 시도가 실패하고 오류가 발생합니다.
#   -잠금이 해제되고 명령문과 트랜잭션이 종료 될 때까지 다른 클라이언트가 진행중인 명령문, 활성 LOCK TABLES WRITE 또는 진행중인 커밋이있는 동안 시도가 차단됩니다.
#    read_only를 활성화하려는 시도가 보류중인 동안 테이블 잠금 또는 트랜잭션 시작에 대한 다른 클라이언트의 요청도 read_only가 설정 될 때까지 차단됩니다.
#   -메타 데이터 잠금을 유지하는 활성 트랜잭션이 있으면 해당 트랜잭션이 끝날 때까지 시도가 차단됩니다.
#   -읽기 전용은 테이블 잠금을 포함하지 않기 때문에 전역 읽기 잠금 (FLUSH TABLES WITH READ LOCK으로 획득)을 유지하는 동안 활성화 할 수 있습니다.
# 
# * Apply Option
# read_only=OFF
# 
# --------------------------------------------
# 
# @ super_read_only
# 
# Command-Line Format	--super-read-only[={OFF|ON}]
# System Variable	super_read_only
# Scope	Global
# Dynamic	Yes
# Type	Boolean
# Default Value	OFF
# 
# 
# read_only 시스템 변수가 활성화된 경우 서버는 SUPER 권한이있는 사용자의 클라이언트 업데이트만 허용합니다.
# super_read_only 시스템 변수도 활성화된 경우 서버는 SUPER가 있는 사용자의 클라이언트 업데이트도 금지합니다.
# 읽기 전용 모드에 대한 설명과 read_only 및 super_read_only가 상호 작용하는 방법에 대한 정보는 read_only 시스템 변수에 대한 설명을 참조하십시오.
# 
# super_read_only가 활성화 되어있을 때 방지되는 클라이언트 업데이트에는 CREATE FUNCTION (UDF 설치) 및 INSTALL PLUGIN과 같이 반드시 업데이트로 표시되지 않는 작업이 포함됩니다.
# 이러한 작업은 mysql 시스템 데이터베이스의 테이블 변경을 포함하기 때문에 금지됩니다.
# 
# 소스 서버에서 super_read_only에 대한 변경 사항은 복제본 서버에 복제되지 않습니다. 값은 소스의 설정에 관계없이 복제 서버에서 설정할 수 있습니다.
# 
# * Apply Option
# super_read_only=OFF
#
# --------------------------------------------
# 
# =========================================================================
# =========== Global Transaction ID System Variables ======================
# =========================================================================
# 
# @ binlog_gtid_simple_recovery
# 
# Property : Value
# Command-Line Format : --binlog-gtid-simple-recovery[={OFF|ON}]
# System Variable : binlog_gtid_simple_recovery
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : ON
# 
# 이 변수는 MySQL이 시작되거나 재시작 될 때 GTID를 검색하는 동안 이진 로그 파일이 반복되는 방법을 제어합니다.
# 
# binlog_gtid_simple_recovery = TRUE (기본값) 인 경우 gtid_executed 및 gtid_purged의 값은 시작시 가장 최근의 가장 오래된
# 이진 로그 파일에서 Previous_gtids_log_event의 값을 기반으로 계산됩니다.
# 계산에 대한 설명은 gtid_purged 시스템 변수를 참조하십시오. 이 설정은 서버를 다시 시작하는 동안 2 개의 이진 로그 파일에만 액세스합니다.
# 서버의 모든 이진 로그가 MySQL 5.7.8 이상을 사용하여 생성되었고 MySQL 5.7.8 이상을 사용하는 경우 binlog_gtid_simple_recovery = TRUE를 항상 안전하게 사용할 수 있습니다.
# 
# binlog_gtid_simple_recovery = TRUE를 사용하면 다음 두 가지 상황에서 gtid_executed 및 gtid_purged가 잘못 초기화 될 수 있습니다.
# + 최신 이진 로그는 MySQL 5.7.5 또는 이전 버전에서 생성되었으며 gtid_mode는 일부 이진 로그의 경우 ON이지만 최신 이진 로그의 경우 OFF입니다.
# + SET @@ GLOBAL.gtid_purged 문은 MySQL 5.7.7 또는 이전 버전에서 발행되었으며 SET @@ GLOBAL.gtid_purged 문 시점에 활성화 된 이진 로그는 아직 제거되지 않았습니다.
# 
# 어떤 상황에서든 잘못된 GTID 세트가 계산되면 나중에 binlog_gtid_simple_recovery = FALSE로 서버를 다시 시작하더라도 잘못된 GTID 세트가 계산됩니다.
# 이러한 상황 중 하나가 서버에 적용되는 경우 서버를 시작하거나 다시 시작하기 전에 binlog_gtid_simple_recovery = FALSE를 설정하십시오.
# 두 번째 상황을 확인하려면 MySQL 5.7.7 또는 이전 버전을 사용하는 경우 SET @@ GLOBAL.gtid_purged 문을 실행 한 후
# SHOW MASTER STATUS를 사용하여 확인할 수있는 현재 이진 로그 파일 이름을 적어 두십시오.
# 이 파일이 제거되기 전에 서버가 다시 시작되면 binlog_gtid_simple_recovery = FALSE를 설정해야합니다.
# 
# binlog_gtid_simple_recovery = FALSE가 설정되면 gtid_purged 시스템 변수에 설명 된대로
# gtid_executed 및 gtid_purged를 계산하는 방법이 다음과 같이 2 진 로그 파일을 반복하도록 변경됩니다.
# + 최신 이진 로그 파일에서 Previous_gtids_log_event 및 GTID 로그 이벤트 값을 사용하는 대신 gtid_executed에 대한 계산은 최신 이진 로그 파일에서 반복되며
#   Previous_gtids_log_event 값과 첫 번째 이진 로그 파일의 모든 GTID 로그 이벤트를 사용합니다. Previous_gtids_log_event 값을 찾습니다.
#   서버의 최신 이진 로그 파일에 GTID 로그 이벤트가없는 경우 (예 : gtid_mode = ON이 사용되었지만 나중에 서버가 gtid_mode = OFF로 변경된 경우)
#   이 프로세스는 시간이 오래 걸릴 수 있습니다.
# + 가장 오래된 이진 로그 파일에서 Previous_gtids_log_event의 값을 사용하는 대신 gtid_purged 계산은 가장 오래된 이진 로그 파일에서 반복되고 비어 있지 않은
#   Previous_gtids_log_event 값 또는 찾은 첫 번째 이진 로그 파일의 Previous_gtids_log_event 값을 사용합니다.
#   최소한 하나의 GTID 로그 이벤트 (GTID 사용이 해당 시점에서 시작됨을 나타냄).
#   서버의 이전 2 진 로그 파일에 GTID 로그 이벤트가없는 경우 (예 : gtid_mode = ON이 서버에서 최근에 설정된 경우),이 프로세스는 시간이 오래 걸릴 수 있습니다.
# 
# MySQL 버전 5.7.5에서는이 변수가 단순화 _binlog_gtid_recovery로 추가되었고 MySQL 버전 5.7.6에서는 binlog_gtid_simple_recovery로 이름이 변경되었습니다.
#
# * Apply Option
# binlog_gtid_simple_recovery=ON
# 
# --------------------------------------------
# 
# @ enforce_gtid_consistency
# 
# Property : Value
# Command-Line Format : --enforce-gtid-consistency[=value]
# System Variable : enforce_gtid_consistency
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values  : OFF, ON, WARN
# 
# 이 변수의 값에 따라, 서버는 GTID를 사용하여 안전하게 기록 할 수있는 명령문 만 실행하여 GTID 일관성을 강제합니다. GTID 기반 복제를 활성화하기 전에이 변수를 ON으로 설정해야합니다.
# 
# enforce_gtid_consistency가 구성 할 수있는 값은 다음과 같습니다.
# + OFF : 모든 트랜잭션이 GTID 일관성을 위반할 수 있습니다.
# + ON : 트랜잭션이 GTID 일관성을 위반할 수 없습니다.
# + WARN : 모든 트랜잭션이 GTID 일관성을 위반할 수 있지만이 경우 경고가 생성됩니다. WARN은 MySQL 5.7.6에서 추가되었습니다.
# 
# enforce_gtid_consistency가 ON으로 설정되면 GTID 안전 명령문을 사용하여 로그 할 수있는 명령문 만 로그 될 수 있으므로 여기에 나열된 조작을이 옵션과 함께 사용할 수 없습니다.
# + CREATE TABLE ... SELECT 문
# + 트랜잭션 내의 CREATE TEMPORARY TABLE 또는 DROP TEMPORARY TABLE 문
# + 트랜잭션 테이블과 비 트랜잭션 테이블을 모두 업데이트하는 트랜잭션 또는 명령문. 모든 비 트랜잭션 테이블이 임시 인 경우 비 트랜잭션 DML이 트랜잭션
#   DML과 동일한 트랜잭션 또는 동일한 명령문에서 허용되는 예외가 있습니다.
# 
# --enforce-gtid-consistency는 명령문에 이진 로깅이 발생하는 경우에만 적용됩니다.
# 서버에서 2 진 로깅이 사용 불가능하거나 명령문이 필터에 의해 제거되어 2 진 로그에 작성되지 않은 경우 GTID 일관성은 로그되지 않은 명령문에 대해 점검되거나 적용되지 않습니다.
# 
# 자세한 내용은 16.1.3.6 절“GTID를 사용한 복제 제한 사항”을 참조하십시오.
# 
# MySQL 5.7.6 이전에는 boolean enforce_gtid_consistency의 기본값이 OFF였습니다. 이전 릴리스와의 호환성을 유지하기 위해 MySQL 5.7.6에서는 열거의 기본값이 OFF로 설정되고
# 값없이 --enforce-gtid-consistency를 설정하면 값을 ON으로 설정하는 것으로 해석됩니다. 변수에는 0 = OFF = FALSE, 1 = ON = TRUE, 2 = WARN 값에 대한 여러 텍스트 별칭이 있습니다.
# 이것은 다른 열거 유형과 다르지만 이전 버전에서 사용 된 부울 유형과의 호환성을 유지합니다. 이러한 변경 사항은 변수가 반환하는 내용에 영향을줍니다.
# SELECT @@ ENFORCE_GTID_CONSISTENCY를 사용하여 'ENFORCE_GTID_CONSISTENCY'와 같은 변수를 표시하고
# SELECT * FROM INFORMATION_SCHEMA.VARIABLES WHERE 'VARIABLE_NAME'= 'ENFORCE_GTID_CONSISTENCY'와 같은 SELECT 변수는 모두 숫자 형식이 아닌 텍스트 형식을 반환합니다.
# @@ENFORCE_GTID_CONSISTENCY는 부울의 숫자 형식을 반환하지만 SHOW 및 정보 스키마의 텍스트 형식을 반환하므로 호환되지 않는 변경 사항입니다.
#
# * Apply Option
# enforce_gtid_consistency=OFF
# 
# --------------------------------------------
# 
# @ gtid_executed
# 
# Property : Value
# System Variable : gtid_executed
# System Variable : gtid_executed
# Scope : Global
# Scope : Global, Session
# Dynamic : No
# Dynamic : No
# Type : String
# 
# 글로벌 범위와 함께 사용되는 경우이 변수에는 서버에서 실행 된 모든 트랜잭션 세트와 SET gtid_purged 문으로 설정된 GTID의 표현이 포함됩니다.
# 이것은 SHOW MASTER STATUS 및 SHOW SLAVE STATUS 출력의 Executed_Gtid_Set 열 값과 동일합니다. 이 변수의 값은 GTID 세트입니다. 자세한 정보는 GTID 세트를 참조하십시오.
# 
# 서버가 시작되면 @@ GLOBAL.gtid_executed가 초기화됩니다. 바이너리 로그가 gtid_executed를 채우도록 반복되는 방법에 대한 자세한 정보는
# binlog_gtid_simple_recovery를 참조하십시오.
# 그런 다음 트랜잭션이 실행되거나 SET gtid_purged 문이 실행되면 GTID가 세트에 추가됩니다.
# 
# 주어진 시간에 이진 로그에서 찾을 수있는 트랜잭션 세트는 GTID_SUBTRACT (@@ GLOBAL.gtid_executed, @@ GLOBAL.gtid_purged)와 같습니다.
# 즉, 아직 제거되지 않은 이진 로그의 모든 트랜잭션에 적용됩니다.
# 
# RESET MASTER를 실행하면이 변수의 글로벌 값 (세션 값이 아님)이 빈 문자열로 재설정됩니다.
# RESET MASTER로 인해 세트가 지워지는 경우 외에는이 세트에서 GTID가 제거되지 않습니다.
# 
# MySQL 5.7.7 이전에는이 ​​변수를 세션 범위와 함께 사용할 수 있었는데, 현재 세션에서 캐시에 기록 된 트랜잭션 세트의 표현이 포함되어있었습니다.
# 세션 범위는 MySQL 5.7.7에서 더 이상 사용되지 않습니다.
#
# * Apply Option
# gtid_executed=none
# 
# --------------------------------------------
# 
# @ gtid_executed_compression_period
# 
# Property : Value
# Command-Line Format : --gtid-executed-compression-period=#
# System Variable : gtid_executed_compression_period
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1000
# Minimum Value : 0
# Maximum Value : 4294967295
# 
# 이 많은 트랜잭션이 처리 될 때마다 mysql.gtid_executed 테이블을 압축하십시오. 0으로 설정하면이 테이블이 압축되지 않습니다.
# 이진 로그를 사용할 때 테이블 압축이 발생하지 않으므로 이진 로깅을 사용하지 않으면 변수 값을 설정해도 아무런 영향이 없습니다.
# 
# 자세한 정보는 mysql.gtid_executed 테이블 압축을 참조하십시오.
# 
# 이 변수는 MySQL 버전 5.7.5에서 executable_gtids_compression_period로 추가되었고
# MySQL 버전 5.7.6에서 gtid_executed_compression_period로 이름이 변경되었습니다.
#
# * Apply Option
# gtid_executed_compression_period=1000
# 
# --------------------------------------------
# 
# @ gtid_mode
# 
# Property : Value
# Command-Line Format : --gtid-mode=MODE
# System Variable : gtid_mode
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values  : OFF, OFF_PERMISSIVE, ON_PERMISSIVE, ON
# 
# GTID 기반 로깅 사용 여부 및 로그에 포함 할 수있는 트랜잭션 유형을 제어합니다. MySQL 5.7.6 이전에는이 ​​변수가 읽기 전용이며 서버 시작시 --gtid-mode를 사용하여 설정되었습니다.
# MySQL 5.7.5 이전에는 --gtid-mode = ON으로 서버를 시작하려면 --log-bin 및 --log-slave-updates 옵션으로 서버를 시작해야했습니다.
# MySQL 5.7.5부터는 더 이상 필요하지 않습니다. mysql.gtid_executed 테이블을 참조하십시오.
# 
# MySQL 5.7.6에서는이 변수를 동적으로 설정할 수 있습니다. 글로벌 시스템 변수를 설정하기에 충분한 권한이 있어야합니다.
# 5.1.8.1 절.“시스템 변수 권한”을 참조하십시오. gtid_mode = ON을 설정하기 전에 enforce_gtid_consistency가 true 여야합니다.
# 이 변수를 수정하기 전에 16.1.5 절“온라인 서버에서 복제 모드 변경”을 참조하십시오.
# 
# MySQL 5.7.6 이상에 로그인 된 트랜잭션은 익명이거나 GTID를 사용할 수 있습니다. 익명 트랜잭션은 이진 로그 파일을 사용하여 특정 트랜잭션을 식별하는 위치에 있습니다.
# GTID 트랜잭션에는 트랜잭션을 참조하는 데 사용되는 고유 식별자가 있습니다. MySQL 5.7.6에 추가 된 OFF_PERMISSIVE 및 ON_PERMISSIVE 모드는 토폴로지에서
# 이러한 트랜잭션 유형의 혼합을 허용합니다. 다른 모드는 다음과 같습니다.
# + OFF : 새 트랜잭션과 복제 된 트랜잭션이 모두 익명이어야합니다.
# + OFF_PERMISSIVE : 새로운 거래는 익명입니다. 복제 된 트랜잭션은 익명 또는 GTID 트랜잭션 일 수 있습니다.
# + ON_PERMISSIVE : 새로운 거래는 GTID 거래입니다. 복제 된 트랜잭션은 익명 또는 GTID 트랜잭션 일 수 있습니다.
# + ON : 새 트랜잭션과 복제 된 트랜잭션 모두 GTID 트랜잭션이어야합니다.
# 
# 한 값에서 다른 값으로 변경하는 것은 한 번에 한 단계 만 가능합니다.
# 예를 들어, gtid_mode가 현재 OFF_PERMISSIVE로 설정되어 있으면 OFF 또는 ON_PERMISSIVE로 변경할 수 있지만 ON으로 변경할 수는 없습니다.
# 
# MySQL 5.7.6 이상에서 gtid_purged 및 gtid_executed의 값은 gtid_mode의 값에 관계없이 영구적입니다.
# 따라서 gtid_mode의 값을 변경 한 후에도이 변수에는 올바른 값이 포함됩니다.
# MySQL 5.7.5 및 이전 버전에서 gtid_purged 및 gtid_executed의 값은 gtid_mode = OFF 인 동안 지속되지 않습니다.
# 따라서 gtid_mode를 OFF로 변경 한 후 GTID를 포함하는 모든 이진 로그가 제거되면 이러한 변수의 값이 손실됩니다.
#
# * Apply Option
# gtid_mode=OFF
# 
# --------------------------------------------
# 
# @ gtid_next
# 
# Property : Value
# System Variable : gtid_next
# Scope : Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : AUTOMATIC
# Valid Values	AUTOMATIC, ANONYMOUS, UUID:NUMBER
# 
# 이 변수는 다음 GTID의 획득 여부와 방법을 지정하는 데 사용됩니다.
# 
# 이 시스템 변수의 세션 값 설정은 제한된 조작입니다. 세션 사용자에게는 제한된 세션 변수를 설정하기에 충분한 권한이 있어야합니다. 5.1.8.1 절.“시스템 변수 권한”을 참조하십시오.
# 
# gtid_next는 다음 값 중 하나를 사용할 수 있습니다.
# + 자동 : 자동으로 생성 된 다음 글로벌 트랜잭션 ID를 사용하십시오.
# + ANONYMOUS : 트랜잭션에는 전역 식별자가 없으며 파일 및 위치로만 식별됩니다.
# + UUID : NUMBER 형식의 글로벌 트랜잭션 ID
# 
# 위의 옵션 중 어떤 옵션이 유효한지는 gtid_mode 설정에 따라 다릅니다. 자세한 내용은 16.1.5.1 절“복제 모드 개념”을 참조하십시오. gtid_mode가 OFF이면이 변수를 설정해도 아무런 영향이 없습니다.
# 
# 이 변수가 UUID : NUMBER로 설정되고 트랜잭션이 커미트 또는 롤백 된 후 다른 명령문보다 먼저 명시적인 SET GTID_NEXT 문을 발행해야합니다.
# 
# MySQL 5.7.5 이상에서 DROP TABLE 또는 DROP TEMPORARY TABLE은 임시 테이블이있는 비 임시 테이블 또는 트랜잭션이없는 스토리지 엔진을 사용하는 임시 테이블이있는
# 트랜잭션 스토리지 엔진을 사용하는 임시 테이블의 조합에서 사용될 때 명시적인 오류와 함께 실패합니다. MySQL 5.7.5 이전에는 GTID가 활성화되었지만 gtid_next가 AUTOMATIC이 아닌 경우
# 이러한 테이블 조합 중 하나와 함께 사용될 때 DROP TABLE이 올바르게 작동하지 않았습니다. (버그 # 17620053)
# 
# MySQL 5.7.1에서는 CHANGE MASTER TO, START SLAVE, STOP SLAVE, REPAIR TABLE, OPTIMIZE TABLE, ANALYZE TABLE, CHECK TABLE, CREATE SERVER,
# ALTER SERVER, DROP SERVER, CACHE INDEX, LOAD INDEX INTO 문을 실행할 수 없습니다. gtid_next가 AUTOMATIC 이외의 값으로 설정된 경우
# CACHE, FLUSH 또는 RESET; 이러한 경우 명령문이 오류와 함께 실패합니다.
# 이러한 진술은 MySQL 5.7.2 이상에서 허용되지 않습니다. (버그 # 16062608, 버그 # 16715809, 버그 # 69045) (버그 # 16062608)
#
# * Apply Option
# gtid_next=AUTOMATIC
# 
# --------------------------------------------
# 
# @ gtid_owned
# 
# Property : Value
# System Variable : gtid_owned
# Scope : Global, Session
# Dynamic : No
# Type : String
# 
# 이 읽기 전용 변수는 주로 내부 용입니다. 내용은 범위에 따라 다릅니다.
# 
# 전역 범위와 함께 사용되는 경우 gtid_owned는 현재 서버에서 사용중인 모든 GTID 목록을 소유하고있는 스레드 ID를 보유합니다.
# 이 변수는 주로 다중 스레드 복제 슬레이브가 트랜잭션이 다른 스레드에 적용되고 있는지 확인하는 데 유용합니다.
# Applier 스레드는 트랜잭션을 처리 할 때마다 트랜잭션의 GTID 소유권을 가져 오므로 @@ global.gtid_owned는 처리 기간 동안 GTID와 소유자를 표시합니다.
# 트랜잭션이 커밋되거나 롤백되면 Applier 스레드가 GTID의 소유권을 해제합니다.
# 
# 세션 범위와 함께 사용될 때 gtid_owned는 현재이 세션에서 사용 중이고 소유 한 단일 GTID를 보유합니다.
# 이 변수는 클라이언트가 gtid_next를 설정하여 트랜잭션에 대한 GTID를 명시 적으로 할당 한 경우 GTID 사용을 테스트하고 디버깅하는 데 주로 유용합니다.
# 이 경우 @@ session.gtid_owned는 트랜잭션이 커밋되거나 롤백 될 때까지 클라이언트가 트랜잭션을 처리 할 때마다 GTID를 표시합니다.
# 클라이언트가 트랜잭션 처리를 마치면 변수가 지워집니다. 세션에 gtid_next = AUTOMATIC을 사용하는 경우 gtid_owned는 트랜잭션에 대한 커밋 명령문을 실행하는 동안 잠깐만 채워 지므로
# @@global.gtid_owned를 읽을 경우 나열 될지라도 해당 세션에서 볼 수는 없습니다. 올바른 지점. 세션에서 클라이언트가 처리하는 GTID를 추적해야하는 경우
# session_track_gtids 시스템 변수로 제어되는 세션 상태 추적기를 사용할 수 있습니다.
#
# * Apply Option
# gtid_owned=none
# 
# --------------------------------------------
# 
# @ gtid_purged
# 
# Property : Value
# System Variable : gtid_purged
# Scope : Global
# Dynamic : Yes
# Type : String
# 
# gtid_purged 시스템 변수 (@@ GLOBAL.gtid_purged)의 전역 값은 서버에서 커밋되었지만 서버의 이진 로그 파일에 존재하지 않는 모든 트랜잭션의 GTID로 구성된 GTID 세트입니다.
# gtid_purged는 gtid_executed의 서브 세트입니다. gtid_purged에는 다음과 같은 GTID 범주가 있습니다.
# + 슬레이브에서 바이너리 로깅이 비활성화 된 상태에서 커밋 된 복제 된 트랜잭션의 GTID
# + 이제 제거 된 이진 로그 파일에 기록 된 트랜잭션의 GTID
# + SET @@ GLOBAL.gtid_purged 문에 의해 세트에 명시 적으로 추가 된 GTID.
# 
# 서버가 시작되거나 다시 시작되면 gtid_purged의 전역 값이 GTID 세트로 초기화됩니다.
# 이 GTID 세트가 계산되는 방법에 대한 정보는 gtid_purged 시스템 변수를 참조하십시오.
# MySQL 5.7.7 이전의 이진 로그가 서버에있는 경우 서버 구성 파일에서 binlog_gtid_simple_recovery = FALSE를 설정하여 올바른 계산을 수행해야 할 수 있습니다.
# 이 설정이 필요한 상황에 대한 자세한 내용은 binlog_gtid_simple_recovery에 대한 설명을 참조하십시오.
# 
# RESET MASTER를 실행하면 gtid_purged의 값이 빈 문자열로 재설정됩니다.
# 
# 서버의 이진 로그에는 존재하지 않지만 특정 GTID 세트의 트랜잭션이 적용된 서버에 기록하기 위해 gtid_purged의 값을 설정할 수 있습니다.
# 이 조치의 사용 사례는 서버에서 하나 이상의 데이터베이스 백업을 복원하지만 서버에서 트랜잭션을 포함하는 관련 2 진 로그가없는 경우입니다.
# 
# MySQL 5.7에서는 gtid_executed가 빈 문자열 인 경우에만 gtid_purged의 값을 업데이트 할 수 있으므로 gtid_purged는 빈 문자열입니다.
# 복제가 이전에 시작되지 않았거나 복제가 이전에 GTID를 사용하지 않은 경우입니다. MySQL 5.7.6 이전에는 gtid_purged는 gtid_mode = ON 인 경우에만 설정할 수있었습니다.
# MySQL 5.7.6 이상에서 gtid_purged는 gtid_mode의 값에 관계없이 설정할 수 있습니다.
# 
# gtid_purged의 값을 지정된 GTID 세트로 바꾸려면 다음 명령문을 사용하십시오.
# SET @@GLOBAL.gtid_purged = 'gtid_set'
# 
# 참고사항
# MySQL 5.7.7 또는 이전 버전을 사용하는 경우 SET @@ GLOBAL.gtid_purged 문을 실행 한 후 서버를 다시 시작하기 전에 서버의 구성 파일에서
# binlog_gtid_simple_recovery = FALSE를 설정해야합니다.
# 그렇지 않으면 gtid_purged가 잘못 계산 될 수 있습니다. 이 설정이 필요한 상황에 대한 자세한 내용은 binlog_gtid_simple_recovery에 대한 설명을 참조하십시오.
# 서버의 모든 이진 로그가 MySQL 5.7.8 이상을 사용하여 생성되었고 MySQL 5.7.8 이상을 사용하는 경우
# binlog_gtid_simple_recovery = TRUE (MySQL 5.7.7의 기본 설정)는 항상 안전하게 사용할 수 있습니다.
#
# * Apply Option
# gtid_purged=none
# 
# --------------------------------------------
# @ session_track_gtids
# 
# Property : Value
# Command-Line Format : --session-track-gtids=value
# System Variable : session_track_gtids
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values  : OFF, OWN_GTID, ALL_GTIDS
# 
# 서버가 현재 세션 내에서 GTID를 추적하여 클라이언트에 반환할지 여부를 제어합니다.
# 변수 값에 따라 각 트랜잭션 실행이 끝날 때 서버 GTID가 추적 프로그램에 의해 캡처되어 클라이언트로 리턴됩니다. 다음 session_track_gtids 값이 허용됩니다.
# 
# -OFF : 트래커가 GTID를 수집하지 않습니다. 이것이 기본값입니다.
# -OWN_GTID : 추적기는 성공적으로 커밋 된 읽기 / 쓰기 트랜잭션에 의해 생성 된 GTID를 수집합니다.
# -ALL_GTIDS : 추적기는 트랜잭션이 읽기 / 쓰기 또는 읽기 전용인지에 관계없이 현재 트랜잭션이 커밋 될 때 gtid_executed 시스템 변수에서 모든 GTID를 수집합니다.
# 
# session_track_gtids는 트랜잭션 컨텍스트 내에서 설정할 수 없습니다.
# 
# 세션 상태 추적에 대한 자세한 내용은 5.1.14 절“클라이언트 세션 상태 변경에 대한 서버 추적”을 참조하십시오.
#
# * Apply Option
# session_track_gtids=OFF
#
# --------------------------------------------