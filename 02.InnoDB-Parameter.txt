# ===============================================================
# ======= InnoDB Startup Options and System Variables  ==========
# ===============================================================
#
#
# @ --innodb-status-file
#
# Property : Value
# Command-Line Format : --innodb-status-file[={OFF|ON}]
# Type : Boolean
# Default Value : OFF
#
# --innodb-status-file 시작 옵션은 InnoDB가 데이터 디렉토리에 innodb_status.pid라는 파일을 생성하고 약 15 초마다 SHOW ENGINE INNODB STATUS 출력을 파일에 기록할지 여부를 제어합니다.
#
# innodb_status.pid 파일은 기본적으로 작성되지 않습니다. 그것을 만들려면 --innodb-status-file 옵션으로 mysqld를 시작하십시오. 서버가 정상적으로 종료되면 InnoDB가 파일을 제거합니다.
# 비정상적인 종료가 발생하면 상태 파일을 수동으로 제거해야 할 수 있습니다.
#
# SHOW ENGINE INNODB STATUS 출력 생성은 성능에 영향을 줄 수 있고 innodb_status.pid 파일은 시간이 지남에 따라 상당히 커질 수 있으므로 --innodb-status-file 옵션은 임시로 사용하기위한 것입니다.
#
# 관련 정보는 14.18.2 절.“InnoDB 모니터 활성화”에서 참조하십시오.
#
# * Apply Option
# innodb-status-file=OFF
#
# --------------------------------------------
#
# @ --skip-innodb
#
# InnoDB 스토리지 엔진을 비활성화하십시오. --innodb의 설명을 참조하십시오.
#
# * Apply Option
# skip-innodb=none
#
# --------------------------------------------
#
# @ daemon_memcached_enable_binlog
#
# Property : Value
# Command-Line Format : --daemon-memcached-enable-binlog[={OFF|ON}]
# System Variable : daemon_memcached_enable_binlog
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : OFF
#
# 마스터 서버에서이 옵션을 활성화하면 MySQL 바이너리 로그와 함께 InnoDB memcached 플러그인 (daemon_memcached)을 사용할 수 있습니다. 이 옵션은 서버 시작시에만 설정할 수 있습니다.
# --log-bin 옵션을 사용하여 마스터 서버에서 MySQL 이진 로그를 활성화해야합니다.
#
# 자세한 정보는 14.21.6 절.“InnoDB memcached 플러그인 및 복제”에서 참조하십시오.
#
# * Apply Option
# daemon_memcached_enable_binlog=OFF
#
# --------------------------------------------
#
# @ daemon_memcached_engine_lib_name
#
# Property : Value
# Command-Line Format : --daemon-memcached-engine-lib-name=file_name
# System Variable : daemon_memcached_engine_lib_name
# Scope : Global
# Dynamic	No
# Type : File name
# Default Value : innodb_engine.so
#
# InnoDB memcached 플러그인을 구현하는 공유 라이브러리를 지정합니다.
#
# 자세한 정보는 14.21.3 절.“InnoDB memcached 플러그인 설정”에서 참조하십시오.
#
# * Apply Option
# daemon_memcached_engine_lib_name=innodb_engine.so
#
# --------------------------------------------
#
# @ daemon_memcached_engine_lib_path
#
# Property : Value
# Command-Line Format : --daemon-memcached-engine-lib-path=dir_name
# System Variable : daemon_memcached_engine_lib_path
# Scope : Global
# Dynamic	No
# Type : Directory name
# Default Value : NULL
#
# InnoDB memcached 플러그인을 구현하는 공유 라이브러리가 포함 된 디렉토리의 경로입니다. 기본값은 NULL이며 MySQL 플러그인 디렉토리를 나타냅니다.
# MySQL 플러그인 디렉토리 외부에있는 다른 스토리지 엔진에 memcached 플러그인을 지정하지 않으면이 매개 변수를 수정할 필요가 없습니다.
#
# 자세한 정보는 14.21.3 절.“InnoDB memcached 플러그인 설정”에서 참조하십시오.
#
# * Apply Option
# daemon_memcached_engine_lib_path=NULL
#
# --------------------------------------------
#
# @ daemon_memcached_option
#
# Property : Value
# Command-Line Format : --daemon-memcached-option=options
# System Variable : daemon_memcached_option
# Scope : Global
# Dynamic	No
# Type : String
# Default Value
#
# 시작시 공백으로 구분 된 memcached 옵션을 기본 memcached 메모리 객체 캐싱 데몬에 전달하는 데 사용됩니다.
# 예를 들어, memcached가 청취하는 포트를 변경하거나 최대 동시 연결 수를 줄이거 나 키-값 쌍의 최대 메모리 크기를 변경하거나 오류 로그에 대한 디버깅 메시지를 사용할 수 있습니다.
#
# 자세한 사용법은 14.21.3 절.“InnoDB memcached 플러그인 설정”에서 참조하십시오. memcached 옵션에 대한 자세한 내용은 memcached 매뉴얼 페이지를 참조하십시오.
#
# * Apply Option
# daemon_memcached_option=Value
#
# --------------------------------------------
#
# @ daemon_memcached_r_batch_size
#
# Property : Value
# Command-Line Format : --daemon-memcached-r-batch-size=#
# System Variable : daemon_memcached_r_batch_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 1
#
# 새 트랜잭션을 시작하기 위해 COMMIT를 수행하기 전에 수행 할 memcached 읽기 조작 (get 조작) 수를 지정합니다. daemon_memcached_w_batch_size의 대응.
#
# 이 값은 기본적으로 1로 설정되므로 SQL 문을 통해 테이블을 변경하면 memcached 작업에 즉시 표시됩니다.
# 기본 테이블이 memcached 인터페이스를 통해서만 액세스되는 시스템에서 빈번한 커밋으로 인한 오버 헤드를 줄이기 위해이 값을 증가시킬 수 있습니다.
# 값을 너무 크게 설정하면 실행 취소 또는 재실행 데이터의 양이 장기 실행 트랜잭션과 같이 일부 스토리지 오버 헤드를 유발할 수 있습니다.
#
# 자세한 정보는 14.21.3 절.“InnoDB memcached 플러그인 설정”에서 참조하십시오.
#
# * Apply Option
# daemon_memcached_r_batch_size=1
#
# --------------------------------------------
#
# @ daemon_memcached_w_batch_size
#
# Property : Value
# Command-Line Format : --daemon-memcached-w-batch-size=#
# System Variable : daemon_memcached_w_batch_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 1
#
# COMMIT를 수행하여 새 트랜잭션을 시작하기 전에 add, set 및 incr과 같은 memcached 쓰기 조작 수를 지정합니다. daemon_memcached_r_batch_size의 대응.
#
# 이 값은 저장되는 데이터가 정전시 보존해야하며 즉시 커밋해야한다는 가정하에 기본적으로 1로 설정됩니다.
# 중요하지 않은 데이터를 저장할 때이 값을 늘리면 빈번한 커밋으로 인한 오버 헤드가 줄어 듭니다. 그러나 충돌이 발생하면 마지막 N-1 커밋되지 않은 쓰기 작업이 손실 될 수 있습니다.
#
# 자세한 정보는 14.21.3 절.“InnoDB memcached 플러그인 설정”에서 참조하십시오.
#
# * Apply Option
# daemon_memcached_w_batch_size=1
#
# --------------------------------------------
#
# @ innodb_adaptive_flushing
#
# Property : Value
# Command-Line Format : --innodb-adaptive-flushing[={OFF|ON}]
# System Variable : innodb_adaptive_flushing
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# 워크로드를 기반으로 InnoDB 버퍼 풀에서 더티 페이지 플러시 비율을 동적으로 조정할지 여부를 지정합니다. 플러시 속도를 동적으로 조정하면 I / O 작업이 급격히 진행되지 않습니다.
# 이 설정은 기본적으로 활성화되어 있습니다. 자세한 내용은 14.8.3.5 절“버퍼 풀 플러시 구성”을 참조하십시오. 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_adaptive_flushing=ON
#
# --------------------------------------------
#
# @ innodb_adaptive_flushing_lwm
#
# Property : Value
# Command-Line Format : --innodb-adaptive-flushing-lwm=#
# System Variable : innodb_adaptive_flushing_lwm
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 10
# Minimum Value	0
# Maximum Value	70
#
# 적응 형 플러싱이 활성화 된 재실행 로그 용량의 백분율을 나타내는 하위 워터 마크를 정의합니다. 자세한 내용은 14.8.3.5 절“버퍼 풀 플러시 구성”을 참조하십시오.
#
# * Apply Option
# innodb_adaptive_flushing_lwm=10
#
# --------------------------------------------
#
# @ innodb_adaptive_hash_index
#
# Property : Value
# Command-Line Format : --innodb-adaptive-hash-index[={OFF|ON}]
# System Variable : innodb_adaptive_hash_index
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# InnoDB 적응 형 해시 인덱스의 활성화 여부입니다. 작업 부하에 따라 적응 형 해시 인덱싱을 동적으로 활성화 또는 비활성화하여 쿼리 성능을 향상시키는 것이 바람직 할 수 있습니다.
# 어댑티브 해시 인덱스는 모든 워크로드에 유용하지 않을 수 있으므로 현실적인 워크로드를 사용하여 활성화 및 비활성화 된 벤치 마크로 벤치 마크를 수행하십시오.
# 자세한 내용은 14.5.3 절“Adaptive Hash Index”를 참조하십시오.
#
# 이 변수는 기본적으로 활성화되어 있습니다. 서버를 다시 시작하지 않고 SET GLOBAL 문을 사용하여이 매개 변수를 수정할 수 있습니다.
# 런타임시 설정을 변경하면 전역 시스템 변수를 설정하기에 충분한 권한이 필요합니다. 5.1.8.1 절.“시스템 변수 권한”을 참조하십시오.
# 서버 시작시 --skip-innodb-adaptive-hash-index를 사용하여 비활성화 할 수도 있습니다.
#
# 적응 형 해시 인덱스를 비활성화하면 해시 테이블이 즉시 비워집니다. 해시 테이블을 비우는 동안 정상적인 작업을 계속할 수 있으며 해시 테이블을 사용하는 쿼리를 실행하면 대신 인덱스 B- 트리에 직접 액세스합니다.
# 적응 형 해시 인덱스가 다시 활성화되면 정상적인 작업 중에 해시 테이블이 다시 채워집니다.
#
# * Apply Option
# innodb_adaptive_hash_index=ON
#
# --------------------------------------------
#
# @ innodb_adaptive_hash_index_parts
#
# Property : Value
# Command-Line Format : --innodb-adaptive-hash-index-parts=#
# System Variable : innodb_adaptive_hash_index_parts
# Scope : Global
# Dynamic	No
# Type : Numeric
# Default Value : 8
# Minimum Value	1
# Maximum Value	512
#
# 적응 형 해시 인덱스 검색 시스템을 분할합니다. 각 인덱스는 특정 파티션에 바인딩되며 각 파티션은 별도의 래치로 보호됩니다.
#
# 이전 릴리스에서는 적응 형 해시 인덱스 검색 시스템이 경합 지점이 될 수있는 단일 래치 (btr_search_latch)로 보호되었습니다.
# innodb_adaptive_hash_index_parts 옵션이 도입되면서 검색 시스템은 기본적으로 8 개 파트로 분할됩니다. 최대 설정은 512입니다.
#
# 관련 정보는 14.5.3 절.“적응 해시 인덱스”를 참조하십시오.
#
# * Apply Option
# innodb_adaptive_hash_index_parts=8
#
# --------------------------------------------
#
# @ innodb_adaptive_max_sleep_delay
#
# Property : Value
# Command-Line Format : --innodb-adaptive-max-sleep-delay=#
# System Variable : innodb_adaptive_max_sleep_delay
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 150000
# Minimum Value	0
# Maximum Value	1000000
#
# InnoDB가 현재 워크로드에 따라 innodb_thread_sleep_delay의 값을 자동으로 올리거나 내 리도록 허용합니다.
# 0이 아닌 값을 사용하면 innodb_adaptive_max_sleep_delay 옵션에 지정된 최대 값까지 innodb_thread_sleep_delay 값을 자동으로 동적으로 조정할 수 있습니다.
# 값은 마이크로 초 수를 나타냅니다. 이 옵션은 16 개 이상의 InnoDB 스레드를 사용하는 사용량이 많은 시스템에서 유용 할 수 있습니다. (실제로 수백 또는 수천 개의 동시 연결이있는 MySQL 시스템에 가장 유용합니다.)
#
# 자세한 내용은 14.8.5 절“InnoDB에 대한 스레드 동시성 구성”을 참조하십시오.
#
# * Apply Option
# innodb_adaptive_max_sleep_delay=150000
#
# --------------------------------------------
#
# @ innodb_api_bk_commit_interval
#
# Property : Value
# Command-Line Format : --innodb-api-bk-commit-interval=#
# System Variable : innodb_api_bk_commit_interval
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 5
# Minimum Value	1
# Maximum Value	1073741824
#
# InnoDB memcached 인터페이스를 사용하는 유휴 연결을 몇 초 안에 자동 커밋하는 빈도입니다. 자세한 내용은 14.21.5.4 절“InnoDB memcached 플러그인의 트랜잭션 동작 제어”를 참조하십시오.
#
# * Apply Option
# innodb_api_bk_commit_interval=5
#
# --------------------------------------------
#
# @ innodb_api_disable_rowlock
#
# Property : Value
# Command-Line Format : --innodb-api-disable-rowlock[={OFF|ON}]
# System Variable : innodb_api_disable_rowlock
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : OFF
#
# InnoDB memcached가 DML 작업을 수행 할 때 행 잠금을 비활성화하려면이 옵션을 사용하십시오. 기본적으로 innodb_api_disable_rowlock은 비활성화되어 있습니다.
# 이는 memcached가 get 및 set 작업을 위해 행 잠금을 요청 함을 의미합니다. innodb_api_disable_rowlock이 활성화되면 memcached는 행 잠금 대신 테이블 잠금을 요청합니다.
#
# innodb_api_disable_rowlock이 동적이 아닙니다. mysqld 명령 줄에 지정하거나 MySQL 구성 파일에 입력해야합니다.
# 플러그인이 설치되면 구성이 적용되며, 이는 MySQL 서버가 시작될 때 발생합니다.
#
# 자세한 내용은 14.21.5.4 절“InnoDB memcached 플러그인의 트랜잭션 동작 제어”를 참조하십시오.
#
# * Apply Option
# innodb_api_disable_rowlock=OFF
#
# --------------------------------------------
#
# @ innodb_api_enable_binlog
#
# Property : Value
# Command-Line Format : --innodb-api-enable-binlog[={OFF|ON}]
# System Variable : innodb_api_enable_binlog
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : OFF
#
# MySQL 바이너리 로그와 함께 InnoDB memcached 플러그인을 사용할 수 있습니다. 자세한 내용은 InnoDB memcached 이진 로그 활성화를 참조하십시오.
#
# * Apply Option
# innodb_api_enable_binlog=OFF
#
# --------------------------------------------
#
# @ innodb_api_enable_mdl
#
# Property : Value
# Command-Line Format : --innodb-api-enable-mdl[={OFF|ON}]
# System Variable : innodb_api_enable_mdl
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : OFF
#
# InnoDB memcached 플러그인이 사용하는 테이블을 잠 가서 SQL 인터페이스를 통해 DDL에 의해 삭제되거나 변경 될 수 없도록합니다. 자세한 내용은 14.21.5.4 절“InnoDB memcached 플러그인의 트랜잭션 동작 제어”를 참조하십시오.
#
# * Apply Option
# innodb_api_enable_mdl=OFF
#
# --------------------------------------------
#
# @ innodb_api_trx_level
#
# Property : Value
# Command-Line Format : --innodb-api-trx-level=#
# System Variable : innodb_api_trx_level
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
#
# memcached 인터페이스에서 처리 한 쿼리에서 트랜잭션 격리 수준을 제어합니다. 익숙한 이름에 해당하는 상수는 다음과 같습니다.
# 0 = READ UNCOMMITTED
# 1 = READ COMMITTED
# 2 = REPEATABLE READ
# 3 = SERIALIZABLE
#
# 자세한 내용은 14.21.5.4 절“InnoDB memcached 플러그인의 트랜잭션 동작 제어”를 참조하십시오.
#
# * Apply Option
# innodb_api_enable_mdl=OFF
#
# --------------------------------------------
#
# @ innodb_autoextend_increment
#
# Property : Value
# Command-Line Format : --innodb-autoextend-increment=#
# System Variable : innodb_autoextend_increment
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 64
# Minimum Value	1
# Maximum Value	1000
#
# 자동 확장 InnoDB 시스템 테이블 스페이스 파일이 가득 찼을 때 확장하는 증분 크기 (MB)입니다. 기본값은 64입니다. 관련 정보는 시스템 테이블 스페이스 데이터 파일 구성 및 시스템 테이블 스페이스 크기 조정을 참조하십시오.
#
# innodb_autoextend_increment 설정은 테이블 당 파일 테이블 스페이스 파일 또는 일반 테이블 스페이스 파일에 영향을 미치지 않습니다.
# 이 파일은 innodb_autoextend_increment 설정에 관계없이 자동 확장됩니다. 초기 확장은 소량이며 확장 후에는 4MB 씩 증가합니다.
#
# * Apply Option
# innodb_autoextend_increment=64
#
# --------------------------------------------
#
# @ innodb_autoinc_lock_mode
#
# Property : Value
# Command-Line Format : --innodb-autoinc-lock-mode=#
# System Variable : innodb_autoinc_lock_mode
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 1
# Valid Values 0, 1, 2
#
# 자동 증분 값을 생성하는 데 사용할 잠금 모드입니다. 허용되는 값은 각각 기존, 연속 또는 인터리브에 대해 0, 1 또는 2입니다.
# 기본 설정은 1 (연속)입니다. 각 잠금 모드의 특징은 InnoDB AUTO_INCREMENT 잠금 모드를 참조하십시오.
#
# * Apply Option
# innodb_autoinc_lock_mode=64
#
# --------------------------------------------
#
# @ innodb_background_drop_list_empty
#
# Property : Value
# Command-Line Format : --innodb-background-drop-list-empty[={OFF|ON}]
# Introduced	5.7.10
# System Variable : innodb_background_drop_list_empty
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# innodb_background_drop_list_empty 디버그 옵션을 사용하면 백그라운드 삭제 목록이 비어있을 때까지 테이블 작성을 지연시켜 테스트 케이스 실패를 방지 할 수 있습니다.
# 예를 들어, 테스트 케이스 A가 테이블 t1을 백그라운드 드롭 목록에 배치하면 테스트 케이스 B는 테이블 t1을 작성하기 전에 백그라운드 드롭 목록이 비어있을 때까지 대기합니다.
#
# * Apply Option
# innodb_background_drop_list_empty=OFF
#
# --------------------------------------------
#
# @ innodb_buffer_pool_chunk_size
#
# Property : Value
# Command-Line Format : --innodb-buffer-pool-chunk-size=#
# System Variable : innodb_buffer_pool_chunk_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 134217728
# Minimum Value	1048576
# Maximum Value	innodb_buffer_pool_size / innodb_buffer_pool_instances
#
# innodb_buffer_pool_chunk_size는 InnoDB 버퍼 풀 크기 조정 작업의 청크 크기를 정의합니다. innodb_buffer_pool_size 매개 변수는 동적이므로 서버를 다시 시작하지 않고 버퍼 풀의 크기를 조정할 수 있습니다.
#
# 크기 조정 작업 중 모든 버퍼 풀 페이지를 복사하지 않으려면 작업이 "청크"로 수행됩니다. 기본적으로 innodb_buffer_pool_chunk_size는 128MB (134217728 바이트)입니다.
# 청크에 포함 된 페이지 수는 innodb_page_size의 값에 따라 다릅니다. # innodb_buffer_pool_chunk_size는 1MB (1048576 바이트) 단위로 늘리거나 줄일 수 있습니다.
#
# innodb_buffer_pool_chunk_size 값을 변경할 때 다음 조건이 적용됩니다.
# + innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances가 버퍼 풀이 초기화 될 때 현재 버퍼 풀 크기보다 큰 경우 
#   innodb_buffer_pool_chunk_size는 innodb_buffer_pool_size / innodb_buffer_pool_instances로 잘립니다.
# + 버퍼 풀 크기는 항상 innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances의 배수와 같아야합니다. 
#   innodb_buffer_pool_chunk_size를 변경하면 innodb_buffer_pool_size는 자동으로 innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances의 배수와 같은 값으로 반올림됩니다.
#   버퍼 풀이 초기화 될 때 조정이 발생합니다.
#
# 중요사항
# 이 값을 변경하면 버퍼 풀의 크기가 자동으로 증가 할 수 있으므로 innodb_buffer_pool_chunk_size를 변경할 때주의해야 합니다.
# innodb_buffer_pool_chunk_size를 변경하기 전에 결과 버퍼 풀 크기가 허용 가능한지 확인하기 위해 # innodb_buffer_pool_size에 미치는 영향을 계산하십시오.
#
# 잠재적 인 성능 문제를 피하려면 청크 수 (innodb_buffer_pool_size / innodb_buffer_pool_chunk_size)는 1000을 초과하지 않아야합니다.
#
# 자세한 내용은 14.8.3.1 절“InnoDB 버퍼 풀 크기 구성”을 참조하십시오.
#
# * Apply Option
# innodb_buffer_pool_chunk_size=134217728
#
# --------------------------------------------
#
# @ innodb_buffer_pool_dump_at_shutdown
#
# Property : Value
# Command-Line Format : --innodb-buffer-pool-dump-at-shutdown[={OFF|ON}]
# System Variable : innodb_buffer_pool_dump_at_shutdown
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# MySQL 서버가 종료 될 때 InnoDB 버퍼 풀에 캐시 된 페이지를 기록하여 다음에 다시 시작할 때 예열 프로세스를 단축할지 여부를 지정합니다.
# 일반적으로 innodb_buffer_pool_load_at_startup과 함께 사용됩니다. innodb_buffer_pool_dump_pct 옵션은 덤프 할 가장 최근에 사용 된 버퍼 풀 페이지의 백분율을 정의합니다.
#
# innodb_buffer_pool_dump_at_shutdown 및 innodb_buffer_pool_load_at_startup은 기본적으로 활성화되어 있습니다.
#
# 자세한 내용은 14.8.3.6 절“버퍼 풀 상태 저장 및 복원”을 참조하십시오.
#
# * Apply Option
# innodb_buffer_pool_dump_at_shutdown=ON
#
# --------------------------------------------
#
# @ innodb_buffer_pool_dump_now
#
# Property : Value
# Command-Line Format : --innodb-buffer-pool-dump-now[={OFF|ON}]
# System Variable : innodb_buffer_pool_dump_now
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# InnoDB 버퍼 풀에 캐시 된 페이지를 즉시 기록합니다. 일반적으로 innodb_buffer_pool_load_now와 함께 사용됩니다.
#
# 자세한 내용은 14.8.3.6 절“버퍼 풀 상태 저장 및 복원”을 참조하십시오.
#
# * Apply Option
# innodb_buffer_pool_dump_now=OFF
#
# --------------------------------------------
#
# @ innodb_buffer_pool_dump_pct
#
# Property : Value
# Command-Line Format : --innodb-buffer-pool-dump-pct=#
# System Variable : innodb_buffer_pool_dump_pct
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 25
# Minimum Value	1
# Maximum Value	100
#
# 읽고 버퍼 할 각 버퍼 풀에 대해 가장 최근에 사용한 페이지의 백분율을 지정합니다. 범위는 1-100입니다. 기본값은 25입니다.
# 예를 들어, 각각 100 페이지를 가진 4 개의 버퍼 풀이 있고 innodb_buffer_pool_dump_pct가 25로 설정된 경우 각 버퍼 풀에서 가장 최근에 사용 된 25 개의 페이지가 덤프됩니다.
#
# innodb_buffer_pool_dump_pct 기본값의 변경은 innodb_buffer_pool_dump_at_shutdown 및 innodb_buffer_pool_load_at_startup의 기본값 변경과 일치하며, 둘 다 MySQL 5.7에서 기본적으로 활성화됩니다.
#
# * Apply Option
# innodb_buffer_pool_dump_pct=25
#
# --------------------------------------------
#
# @ innodb_buffer_pool_filename
#
# Property : Value
# Command-Line Format : --innodb-buffer-pool-filename=file_name
# System Variable : innodb_buffer_pool_filename
# Scope : Global
# Dynamic	Yes
# Type : File name
# Default Value : ib_buffer_pool
#
# innodb_buffer_pool_dump_at_shutdown 또는 innodb_buffer_pool_dump_now에 의해 생성 된 테이블 스페이스 ID 및 페이지 ID 목록을 보유하는 파일 이름을 지정합니다. 테이블 스페이스 ID 및 페이지 ID는 space, page_id 형식으로 저장됩니다. # 기본적으로 파일 이름은 ib_buffer_pool이며 InnoDB 데이터 디렉토리에 있습니다. 기본이 아닌 위치는 데이터 디렉토리를 기준으로 지정해야합니다.
#
# SET 문을 사용하여 런타임에 파일 이름을 지정할 수 있습니다.
# mysql > SET GLOBAL innodb_buffer_pool_filename='file_name';
#
# 시작시 시작 문자열 또는 MySQL 구성 파일에서 파일 이름을 지정할 수도 있습니다. 시작할 때 파일 이름을 지정할 때 파일이 존재해야합니다. 그렇지 않으면 InnoDB는 그러한 파일이나 디렉토리가 없음을 나타내는 시작 오류를 반환합니다.
#
# 자세한 내용은 14.8.3.6 절“버퍼 풀 상태 저장 및 복원”을 참조하십시오.
#
# * Apply Option
# innodb_buffer_pool_filename=ib_buffer_pool
#
# --------------------------------------------
#
# @ innodb_buffer_pool_instances
#
# Property : Value
# Command-Line Format : --innodb-buffer-pool-instances=#
# System Variable : innodb_buffer_pool_instances
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value (Other)	8 (or 1 if innodb_buffer_pool_size < 1GB
# Default Value (Windows, 32-bit platforms)	(autosized)
# Minimum Value	1
# Maximum Value	64
#
# InnoDB 버퍼 풀이 분할 된 영역 수 멀티 기가 바이트 범위의 버퍼 풀이있는 시스템의 경우 버퍼 풀을 개별 인스턴스로 나누면 다른 스레드가 캐시 된 페이지를 읽고 쓸 때 경합을 줄임으로써 동시성을 향상시킬 수 있습니다.
# 버퍼 풀에 저장되거나 버퍼 풀에서 읽은 각 페이지는 해싱 함수를 사용하여 버퍼 풀 인스턴스 중 하나에 임의로 할당됩니다.
# 각 버퍼 풀은 자체 여유 목록, 플러시 목록, LRU 및 버퍼 풀에 연결된 기타 모든 데이터 구조를 관리하며 자체 버퍼 풀 뮤텍스에 의해 보호됩니다.
#
# 이 옵션은 innodb_buffer_pool_size를 1GB 이상으로 설정할 때만 적용됩니다. 총 버퍼 풀 크기는 모든 버퍼 풀로 나뉩니다.
# 최상의 효율성을 위해 각 버퍼 풀 인스턴스가 1GB 이상이되도록 innodb_buffer_pool_instances 및 innodb_buffer_pool_size의 조합을 지정하십시오.
#
# 32 비트 Windows 시스템의 기본값은 아래 설명 된대로 innodb_buffer_pool_size의 값에 따라 다릅니다.
# + innodb_buffer_pool_size가 1.3GB보다 큰 경우 innodb_buffer_pool_instances의 기본값은 innodb_buffer_pool_size / 128MB이며 각 청크에 대한 개별 메모리 할당 요청이 있습니다.
# 32 비트 Windows가 단일 버퍼 풀에 필요한 연속 주소 공간을 할당 할 수없는 중대한 위험이있는 경계로 1.3GB를 선택했습니다.
# + 그렇지 않으면 기본값은 1입니다.
#
# 다른 모든 플랫폼에서 innodb_buffer_pool_size가 1GB 이상인 경우 기본값은 8입니다. 그렇지 않으면 기본값은 1입니다.
# 관련 정보는 14.8.3.1 절.“InnoDB 버퍼 풀 크기 구성”에서 참조하십시오.
#
# * Apply Option
# innodb_buffer_pool_instances=8
#
# --------------------------------------------
#
# @ innodb_buffer_pool_load_abort
#
# Property : Value
# Command-Line Format : --innodb-buffer-pool-load-abort[={OFF|ON}]
# System Variable : innodb_buffer_pool_load_abort
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# innodb_buffer_pool_load_at_startup 또는 innodb_buffer_pool_load_now에 의해 트리거 된 InnoDB 버퍼 풀 내용을 복원하는 프로세스를 중단합니다.
#
# 자세한 내용은 14.8.3.6 절“버퍼 풀 상태 저장 및 복원”을 참조하십시오.
#
# * Apply Option
# innodb_buffer_pool_load_abort=OFF
#
# --------------------------------------------
#
# @ innodb_buffer_pool_load_at_startup
#
# Property : Value
# Command-Line Format : --innodb-buffer-pool-load-at-startup[={OFF|ON}]
# System Variable : innodb_buffer_pool_load_at_startup
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : ON
#
# MySQL 서버 시작시 InnoDB 버퍼 풀이 이전에 보유한 동일한 페이지를로드하여 자동으로 예열되도록 지정합니다. 일반적으로 innodb_buffer_pool_dump_at_shutdown과 함께 사용됩니다.
#
# innodb_buffer_pool_dump_at_shutdown 및 innodb_buffer_pool_load_at_startup은 기본적으로 활성화되어 있습니다.
#
# 자세한 내용은 14.8.3.6 절“버퍼 풀 상태 저장 및 복원”을 참조하십시오.
#
# * Apply Option
# innodb_buffer_pool_load_at_startup=ON
#
# --------------------------------------------
#
# @ innodb_buffer_pool_load_now
#
# Property : Value
# Command-Line Format : --innodb-buffer-pool-load-now[={OFF|ON}]
# System Variable : innodb_buffer_pool_load_now
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# 서버 재시작을 기다리지 않고 일련의 데이터 페이지를로드하여 InnoDB 버퍼 풀을 즉시 예열합니다.
# 벤치마킹 중에 캐시 메모리를 알려진 상태로 되돌 리거나 보고서 또는 유지 관리를 위해 쿼리를 실행 한 후 MySQL 서버가 정상 워크로드를 재개 할 수 있도록 준비하는 데 유용 할 수 있습니다.
#
# 자세한 내용은 14.8.3.6 절“버퍼 풀 상태 저장 및 복원”을 참조하십시오.
#
#
# * Apply Option
# innodb_buffer_pool_load_now=OFF
#
# --------------------------------------------
#
# @ innodb_buffer_pool_size
#
# Property : Value
# Command-Line Format : --innodb-buffer-pool-size=#
# System Variable : innodb_buffer_pool_size
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 134217728
# Minimum Value	5242880
# Maximum Value (64-bit platforms)	2**64-1
# Maximum Value (32-bit platforms)	2**32-1
#
# 버퍼 풀의 크기 (InnoDB가 테이블 및 인덱스 데이터를 캐시하는 메모리 영역)입니다. 기본값은 134217728 바이트 (128MB)입니다.
# 최대 값은 CPU 아키텍처에 따라 다릅니다. 최대 값은 32 비트 시스템에서 4294967295 (232-1)이고 64 비트 시스템에서 18446744073709551615 (264-1)입니다.
# 32 비트 시스템에서 CPU 아키텍처 및 운영 체제는 명시된 최대 값보다 실제 최대 크기를 낮출 수 있습니다. 버퍼 풀의 크기가 1GB보다 큰 경우 innodb_buffer_pool_instances를 1보다 큰 값으로 설정하면 사용중인 서버의 확장 성이 향상 될 수 있습니다.
#
# 더 큰 버퍼 풀은 동일한 테이블 데이터에 두 번 이상 액세스하기 위해 더 적은 디스크 I / O가 필요합니다.
# 전용 데이터베이스 서버에서 버퍼 풀 크기를 머신의 실제 메모리 크기의 80 %로 설정할 수 있습니다. 버퍼 풀 크기를 구성 할 때 다음과 같은 잠재적 인 문제를 알고 필요한 경우 버퍼 풀의 크기를 축소 할 수 있도록 준비하십시오.
# + 실제 메모리 경쟁으로 인해 운영 체제에서 페이징이 발생할 수 있습니다.
# + InnoDB는 버퍼 및 제어 구조를위한 추가 메모리를 예약하여 할당 된 총 공간이 지정된 버퍼 풀 크기보다 약 10 % 더 큽니다.
# + 버퍼 풀의 주소 공간은 연속적이어야하며, 이는 특정 주소에서로드되는 DLL이있는 Windows 시스템에서 문제가 될 수 있습니다.
# + 버퍼 풀을 초기화하는 시간은 크기에 대략 비례합니다. 버퍼 풀이 큰 인스턴스에서는 초기화 시간이 중요 할 수 있습니다. 초기화 기간을 줄이려면 서버 종료시 버퍼 풀 상태를 저장하고 서버 시작시이를 복원 할 수 있습니다.
# 14.8.3.6 절“버퍼 풀 상태 저장 및 복원”을 참조하십시오.
#
# 버퍼 풀 크기를 늘리거나 줄이면 작업이 청크로 수행됩니다. 청크 크기는 innodb_buffer_pool_chunk_size 변수에 의해 정의되며 기본값은 128MB입니다.
#
# 버퍼 풀 크기는 항상 innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances의 배수와 같아야합니다.
# 버퍼 풀 크기를 innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances의 배수가 아닌 값으로 변경하면 버퍼 풀 크기가 자동으로
# innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances의 배수와 같거나 여러 값으로 조정됩니다.
#
# innodb_buffer_pool_size를 동적으로 설정하여 서버를 다시 시작하지 않고도 버퍼 풀의 크기를 조정할 수 있습니다.
# Innodb_buffer_pool_resize_status 상태 변수는 온라인 버퍼 풀 크기 조정 조작의 상태를보고합니다. 자세한 내용은 14.8.3.1 절“InnoDB 버퍼 풀 크기 구성”을 참조하십시오.
#
# * Apply Option
# innodb_buffer_pool_size=134217728
#
# --------------------------------------------
# 
# @ innodb_additional_mem_pool_size
# 
# Command-Line Format	--innodb-additional-mem-pool-size=#
# Deprecated	Yes
# System Variable	innodb_additional_mem_pool_size
# Scope	Global
# Dynamic	No
# Type	Integer
# Default Value	8388608
# Minimum Value	2097152
# Maximum Value	4294967295
# 
# The size in bytes of a memory pool InnoDB uses to store data dictionary information and other internal data structures. The more tables you have in your application, the more memory you allocate here. If InnoDB runs out of memory in this pool, it starts to allocate memory from the operating system and writes warning messages to the MySQL error log. The default value is 8MB.
# 
# This variable relates to the InnoDB internal memory allocator, which is unused if innodb_use_sys_malloc is enabled. For more information, see Section 14.8.4, “Configuring the Memory Allocator for InnoDB”.
# 
# As of MySQL 5.6.3, innodb_additional_mem_pool_size is deprecated; expect it to be removed in a future MySQL release.
# 
# 
# InnoDB가 데이터 사전 정보 및 기타 내부 데이터 구조를 저장하는 데 사용하는 메모리 풀의 크기 (바이트)입니다.
# 애플리케이션에 테이블이 많을수록 여기에 더 많은 메모리를 할당합니다.
# InnoDB가이 풀의 메모리가 부족하면 운영 체제에서 메모리를 할당하기 시작하고 MySQL 오류 로그에 경고 메시지를 기록합니다. 기본값은 8MB입니다.
# 
# 이 변수는 innodb_use_sys_malloc이 활성화 된 경우 사용되지 않는 InnoDB 내부 메모리 할당 자와 관련이 있습니다.
# 자세한 내용은 Section 14.8.4,“InnoDB 용 메모리 할당 자 구성”을 참조하십시오.
# 
# MySQL 5.6.3부터 innodb_additional_mem_pool_size는 더 이상 사용되지 않습니다. 향후 MySQL 릴리스에서 제거 될 것으로 예상됩니다.
# 
# * Apply Option
# innodb_additional_mem_pool_size=8388608
# 
# --------------------------------------------
#
# @ innodb_change_buffer_max_size
#
# Property : Value
# Command-Line Format : --innodb-change-buffer-max-size=#
# System Variable : innodb_change_buffer_max_size
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 25
# Minimum Value	0
# Maximum Value	50
#
# 버퍼 풀의 전체 크기에 대한 백분율로 표시되는 InnoDB 변경 버퍼의 최대 크기입니다.
# 삽입, 업데이트 및 삭제 활동이 많은 MySQL 서버의 경우이 값을 늘리거나보고에 사용 된 데이터가 변경되지 않은 MySQL 서버의 경우이 값을 줄일 수 있습니다.
# 자세한 내용은 14.5.2 절“버퍼 변경”을 참조하십시오. 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_change_buffer_max_size=25
#
# --------------------------------------------
#
# @ innodb_change_buffering
#
# Property : Value
# Command-Line Format : --innodb-change-buffering=value
# System Variable : innodb_change_buffering
# Scope : Global
# Dynamic	Yes
# Type : Enumeration
# Default Value : all
# Valid Values none, inserts, deletes, changes, purges, all
#
# InnoDB가 변경 버퍼링을 수행하는지 여부에 관계없이 I / O 작업을 순차적으로 수행 할 수 있도록 쓰기 작업을 보조 인덱스로 지연시키는 최적화.
# 허용되는 값은 다음 표에 설명되어 있습니다.
#
# Table 14.19 Permitted Values for innodb_change_buffering
#
# Value     | Description
# none      | Do not buffer any operations.
# inserts   | Buffer insert operations.
# deletes   | Buffer delete marking operations; strictly speaking, the writes that mark index records for later deletion during a purge operation.
# changes   | Buffer inserts and delete-marking operations.
# purges    | Buffer the physical deletion operations that happen in the background.
# all	The default. Buffer inserts, delete-marking operations, and purges.
#
# * Apply Option
# innodb_change_buffering=all
#
# --------------------------------------------
#
# @ innodb_change_buffering_debug
#
# Property : Value
# Command-Line Format : --innodb-change-buffering-debug=#
# System Variable : innodb_change_buffering_debug
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
# Maximum Value	2
#
# InnoDB 변경 버퍼링에 대한 디버그 플래그를 설정합니다. 값이 1이면 모든 변경 사항이 변경 버퍼에 적용됩니다. 값이 2이면 병합시 충돌이 발생합니다.
# 기본값 0은 변경 버퍼링 디버그 플래그가 설정되지 않았 음을 나타냅니다. 이 옵션은 디버깅 지원이 WITH_DEBUG CMake 옵션을 사용하여 컴파일 된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# innodb_change_buffering_debug=0
#
# --------------------------------------------
#
# @ innodb_checksum_algorithm
#
# Property : Value
# Command-Line Format : --innodb-checksum-algorithm=value
# System Variable : innodb_checksum_algorithm
# Scope : Global
# Dynamic	Yes
# Type : Enumeration
# Default Value : crc32
# Valid Values innodb, crc32, none, strict_innodb, strict_crc32, strict_none
#
# InnoDB 테이블 스페이스의 디스크 블록에 저장된 체크섬을 생성하고 확인하는 방법을 지정합니다. crc32는 MySQL 5.7.7의 기본값입니다.
#
# innodb_checksum_algorithm은 innodb_checksums 옵션을 대체합니다. MySQL 5.7.6 이하의 호환성을 위해 다음 값이 제공되었습니다.
# + innodb_checksums = ON은 innodb_checksum_algorithm = innodb와 동일합니다.
# + innodb_checksums = OFF는 innodb_checksum_algorithm = none과 같습니다.
# MySQL 5.7.7부터 기본 innodb_checksum_algorithm 값이 crc32 인 innodb_checksums = ON은 이제 innodb_checksum_algorithm = crc32와 동일합니다. innodb_checksums = OFF는 여전히 innodb_checksum_algorithm = none과 동일합니다.
#
# 충돌을 피하려면 MySQL 구성 파일 및 시작 스크립트에서 innodb_checksums에 대한 참조를 제거하십시오.
#
# innodb 값은 이전 버전의 MySQL과 호환됩니다. crc32 값은 수정 된 모든 블록에 대한 체크섬을 계산하고 각 디스크 읽기에 대한 체크섬을 확인하기 위해 더 빠른 알고리즘을 사용합니다.
# 한 번에 32 비트를 스캔하며, 한 번에 8 비트를 스캔하는 innodb 체크섬 알고리즘보다 빠릅니다. none 값은 블록 데이터를 기반으로 값을 계산하지 않고 체크섬 필드에 상수 값을 씁니다.
# 테이블 스페이스의 블록은 데이터가 수정됨에 따라 점진적으로 업데이트되는 기존, 새로운 체크섬 값 및 체크섬 값을 혼합하여 사용할 수 있습니다.
# crc32 알고리즘을 사용하도록 테이블 스페이스의 블록을 수정하면 이전 버전의 MySQL에서 관련 테이블을 읽을 수 없습니다.
#
# 체크섬 알고리즘의 엄격한 형식은 테이블 스페이스에서 유효하지만 일치하지 않는 체크섬 값을 발견하면 오류를보고합니다.
# 테이블 스페이스를 처음 설정하려면 새 인스턴스에서 엄격한 설정 만 사용하는 것이 좋습니다. 엄격한 설정은 디스크를 읽는 동안 모든 체크섬 값을 계산할 필요가 없기 때문에 다소 빠릅니다.
#
# Note
# MySQL 5.7.8 이전에는 innodb_checksum_algorithm에 대한 엄격한 모드 설정으로 인해 유효하지만 일치하지 않는 체크섬이 발생할 때 InnoDB가 중지되었습니다.
# MySQL 5.7.8 이상에서는 오류 메시지 만 인쇄되며 페이지에 유효한 innodb, crc32가 있거나 체크섬이없는 경우 페이지가 유효한 것으로 승인됩니다.
#
# 다음 표는 none, innodb 및 crc32 옵션 값과 해당 값의 차이점을 보여줍니다.
# none, innodb 및 crc32는 지정된 유형의 체크섬 값을 각 데이터 블록에 쓰지만 호환성을 위해 읽기 작업 중에 블록을 확인할 때 다른 체크섬 값을 수락합니다.
# 엄격한 설정은 유효한 체크섬 값을 허용하지만 유효한 비 일치 체크섬 값이 발견되면 오류 메시지를 인쇄합니다.
# 엄격한 형식을 사용하면 인스턴스의 모든 InnoDB 데이터 파일이 동일한 innodb_checksum_algorithm 값으로 생성되는 경우 더 빠르게 검증 할 수 있습니다.
#
# Table 14.20 Permitted innodb_checksum_algorithm Values
# Value           | Generated checksum (when writing)	                                      |  Permitted checksums (when reading)
# none	        | 상수.                                                                   | none, innodb 또는 crc32에 의해 생성 된 모든 체크섬
# innodb          | InnoDB의 원래 알고리즘을 사용하여 소프트웨어로 계산 된 체크섬.              | none, innodb 또는 crc32에 의해 생성 된 모든 체크섬
# crc32           | crc32 알고리즘을 사용하여 계산 된 체크섬으로, 하드웨어 지원으로 가능합니다.  | none, innodb 또는 crc32에 의해 생성 된 모든 체크섬
# strict_none     | 상수.                                                                   | none, innodb 또는 crc32에 의해 생성 된 모든 체크섬 유효하지만 일치하지 않는 체크섬이 있으면 InnoDB가 오류 메시지를 인쇄합니다.
# strict_innodb   | InnoDB의 원래 알고리즘을 사용하여 소프트웨어로 계산 된 체크섬.              |  none, innodb 또는 crc32에 의해 생성 된 모든 체크섬 유효하지만 일치하지 않는 체크섬이 있으면 InnoDB가 오류 메시지를 인쇄합니다.
# strict_crc32    | crc32 알고리즘을 사용하여 계산 된 체크섬으로, 하드웨어 지원으로 가능합니다.  |  none, innodb 또는 crc32에 의해 생성 된 모든 체크섬 유효하지만 일치하지 않는 체크섬이 있으면 InnoDB가 오류 메시지를 인쇄합니다.
#
# 최대 3.8.0까지의 MySQL Enterprise Backup 버전은 CRC32 체크섬을 사용하는 테이블 스페이스 백업을 지원하지 않습니다.
# MySQL Enterprise Backup은 3.8.1에서 CRC32 체크섬 지원을 추가하지만 몇 가지 제한이 있습니다. 자세한 내용은 MySQL Enterprise Backup 3.8.1 변경 기록을 참조하십시오.
#
# * Apply Option
# innodb_checksum_algorithm=crc32
#
# --------------------------------------------
#
# @ innodb_checksums
#
# Property : Value
# Command-Line Format : --innodb-checksums[={OFF|ON}]
# Deprecated	Yes
# System Variable : innodb_checksums
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : ON
#
# InnoDB는 디스크에서 읽은 모든 테이블 스페이스 페이지에서 체크섬 유효성 검사를 사용하여 하드웨어 결함 또는 손상된 데이터 파일에 대한 추가 결함 허용을 보장 할 수 있습니다.
# 이 유효성 검사는 기본적으로 활성화되어 있습니다. 특수한 상황 (예 : 벤치 마크 실행)에서이 안전 기능은 --skip-innodb-checksums로 비활성화 할 수 있습니다.
# innodb_checksum_algorithm 옵션을 사용하여 체크섬을 계산하는 방법을 지정할 수 있습니다.
#
# innodb_checksums는 더 이상 사용되지 않으며 innodb_checksum_algorithm으로 대체됩니다.
#
# MySQL 5.7.7 이전의 innodb_checksums = ON은 innodb_checksum_algorithm = innodb와 동일합니다.
# MySQL 5.7.7부터 innodb_checksum_algorithm 기본값은 crc32이고 innodb_checksums = ON은 innodb_checksum_algorithm = crc32와 동일합니다. innodb_checksums = OFF는 innodb_checksum_algorithm = none과 같습니다.
#
# innodb_checksum_algorithm과의 충돌을 피하려면 구성 파일 및 시작 스크립트에서 innodb_checksums 옵션을 제거하십시오.
# innodb_checksums = OFF는 자동으로 innodb_checksum_algorithm = none을 설정합니다. innodb_checksums = ON은 innodb_checksum_algorithm에 대한 다른 설정으로 무시되고 무시됩니다.
#
#
# * Apply Option
# innodb_checksums=ON
#
# --------------------------------------------
#
# @ innodb_cmp_per_index_enabled
#
# Property : Value
# Command-Line Format : --innodb-cmp-per-index-enabled[={OFF|ON}]
# System Variable : innodb_cmp_per_index_enabled
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX 테이블에서 인덱스 별 압축 관련 통계를 사용합니다.
# 이러한 통계는 수집 비용이 많이들 수 있으므로 InnoDB 압축 테이블과 관련된 성능 조정 중에 개발, 테스트 또는 슬레이브 인스턴스에서만이 옵션을 활성화하십시오.
#
# 자세한 내용은 24.32.6 절“Information_SCHEMA INNODB_CMP_PER_INDEX 및 INNODB_CMP_PER_INDEX_RESET 테이블”및 14.9.1.4 절“런타임에서 InnoDB 테이블 압축 모니터링”을 참조하십시오.
#
# * Apply Option
# innodb_cmp_per_index_enabled=OFF
#
# --------------------------------------------
#
# @ innodb_commit_concurrency
#
# Property : Value
# Command-Line Format : --innodb-commit-concurrency=#
# System Variable : innodb_commit_concurrency
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
# Minimum Value	0
# Maximum Value	1000
#
# 동시에 커밋 할 수있는 스레드 수입니다. 값이 0 (기본값)이면 여러 트랜잭션을 동시에 커밋 할 수 있습니다.
#
# innodb_commit_concurrency의 값은 런타임시 0에서 0이 아닌 값으로 또는 그 반대로 변경할 수 없습니다. 값은 0이 아닌 값에서 다른 값으로 변경할 수 있습니다.
#
# * Apply Option
# innodb_commit_concurrency=0
#
# --------------------------------------------
#
# @ innodb_compress_debug
#
# Property : Value
# Command-Line Format : --innodb-compress-debug=value
# System Variable : innodb_compress_debug
# Scope : Global
# Dynamic	Yes
# Type : Enumeration
# Default Value : none
# Valid Values none, zlib, lz4, lz4hc
#
# 각 테이블에 대해 COMPRESSION 속성을 정의하지 않고도 지정된 압축 알고리즘을 사용하여 모든 테이블을 압축합니다. 이 옵션은 디버깅 지원이 WITH_DEBUG CMake 옵션을 사용하여 컴파일 된 경우에만 사용할 수 있습니다.
#
# 관련 정보는 14.9.2 절.“InnoDB 페이지 압축”에서 참조하십시오.
#
# * Apply Option
# innodb_compress_debug=none
#
# --------------------------------------------
#
# @ innodb_compression_failure_threshold_pct
#
# Property : Value
# Command-Line Format : --innodb-compression-failure-threshold-pct=#
# System Variable : innodb_compression_failure_threshold_pct
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 5
# Minimum Value	0
# Maximum Value	100
#
# 비싼 압축 실패를 피하기 위해 MySQL이 압축 된 페이지 내에 패딩을 추가하기 시작하는 시점에 대한 테이블의 압축 실패율 임계 값을 백분율로 정의합니다.
# 이 임계 값이 전달되면 MySQL은 각각의 새로운 압축 된 페이지 내에 추가 여유 공간을 남기기 시작하여 innodb_compression_pad_pct_max에 의해 지정된 페이지 크기의 백분율까지 여유 공간의 양을 동적으로 조정합니다.
# 값이 0이면 압축 효율성을 모니터링하고 패딩 양을 동적으로 조정하는 메커니즘이 비활성화됩니다.
#
# 자세한 내용은 14.9.1.6 절“OLTP 작업 부하 압축”을 참조하십시오.
#
# * Apply Option
# innodb_compression_failure_threshold_pct=OFF
#
# --------------------------------------------
#
# @ innodb_compression_level
#
# Property : Value
# Command-Line Format : --innodb-compression-level=#
# System Variable : innodb_compression_level
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 6
# Minimum Value	0
# Maximum Value	9
#
# InnoDB 압축 테이블 및 인덱스에 사용할 zlib 압축 레벨을 지정합니다. 값이 클수록 압축하는 동안 CPU 오버 헤드가 증가하면서 더 많은 데이터를 스토리지 장치에 맞출 수 있습니다.
# 값이 작을수록 저장 공간이 중요하지 않거나 데이터가 특별히 압축되지 않을 때 CPU 오버 헤드를 줄일 수 있습니다.
#
# 자세한 내용은 14.9.1.6 절“OLTP 작업 부하 압축”을 참조하십시오.
#
# * Apply Option
# innodb_compression_level=6
#
# --------------------------------------------
#
# @ innodb_compression_pad_pct_max
#
# Property : Value
# Command-Line Format : --innodb-compression-pad-pct-max=#
# System Variable : innodb_compression_pad_pct_max
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 50
# Minimum Value	0
# Maximum Value	75
#
# 압축 된 테이블 또는 인덱스가 업데이트되고 데이터가 다시 압축 될 때 공간이 페이지 내의 데이터 및 수정 로그를 재구성 할 수 있도록 각 압축 된 페이지 내에서 여유 공간으로 예약 될 수있는 최대 백분율을 지정합니다.
# innodb_compression_failure_threshold_pct가 0이 아닌 값으로 설정되고 압축 실패 비율이 컷오프 지점을 통과 한 경우에만 적용됩니다.
#
# 자세한 내용은 14.9.1.6 절“OLTP 작업 부하 압축”을 참조하십시오.
#
# * Apply Option
# innodb_compression_pad_pct_max=OFF
#
# --------------------------------------------
#
# @ innodb_concurrency_tickets
#
# Property : Value
# Command-Line Format : --innodb-concurrency-tickets=#
# System Variable : innodb_concurrency_tickets
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 5000
# Minimum Value	1
# Maximum Value	4294967295
#
# InnoDB에 동시에 들어갈 수있는 스레드 수를 결정합니다. 스레드 수가 이미 동시성 한계에 도달 한 경우 InnoDB에 들어 가려고하면 스레드가 큐에 배치됩니다.
# 스레드가 InnoDB에 들어갈 수 있으면 innodb_concurrency_tickets 값과 동일한 수의 "티켓"이 부여되며 스레드는 티켓을 다 쓸 때까지 자유롭게 InnoDB에 출입 할 수 있습니다.
# 그 후 스레드는 다음에 InnoDB에 들어 가려고 할 때 동시성 검사 (및 가능한 대기열)의 대상이됩니다. 기본값은 5000입니다.
#
# 작은 innodb_concurrency_tickets 값을 사용하면 몇 개의 행만 처리하면되는 작은 트랜잭션은 많은 행을 처리하는 큰 트랜잭션과 공정하게 경쟁합니다.
# 작은 innodb_concurrency_tickets 값의 단점은 큰 트랜잭션이 완료되기 전에 큐를 여러 번 반복해야하므로 작업을 완료하는 데 필요한 시간이 길어집니다.
#
# innodb_concurrency_tickets 값이 크면 큰 트랜잭션은 대기열 끝에있는 위치 (innodb_thread_concurrency에 의해 제어 됨)를 기다리는 시간이 줄어들고 행을 검색하는 데 더 많은 시간이 소요됩니다.
# 대규모 트랜잭션은 또한 작업을 완료하기 위해 대기열을 통한 여행 횟수가 줄어 듭니다.
# 큰 innodb_concurrency_tickets 값의 단점은 동시에 실행되는 너무 큰 트랜잭션이 너무 많으면 실행하기 전에 더 오래 기다리게하여 더 작은 트랜잭션을 고갈시킬 수 있다는 것입니다.
#
# 0이 아닌 innodb_thread_concurrency 값을 사용하면 innodb_concurrency_tickets 값을 위 또는 아래로 조정하여 더 큰 트랜잭션과 더 작은 트랜잭션 사이의 최적 균형을 찾을 수 있습니다.
# SHOW ENGINE INNODB STATUS 보고서는 큐를 통과하는 현재 트랜잭션에서 실행중인 트랜잭션에 남아있는 티켓 수를 보여줍니다.
# 이 데이터는 INFORMATION_SCHEMA.INNODB_TRX 테이블의 TRX_CONCURRENCY_TICKETS 컬럼에서 얻을 수도 있습니다.
#
# 자세한 내용은 14.8.5 절“InnoDB에 대한 스레드 동시성 구성”을 참조하십시오.
#
# * Apply Option
# innodb_concurrency_tickets=5000
#
# --------------------------------------------
#
# @ innodb_data_file_path
#
# Property : Value
# Command-Line Format : --innodb-data-file-path=file_name
# System Variable : innodb_data_file_path
# Scope : Global
# Dynamic	No
# Type : String
# Default Value : ibdata1:12M:autoextend
#
# InnoDB 시스템 테이블 스페이스 데이터 파일의 이름, 크기 및 속성을 정의합니다. innodb_data_file_path에 값을 지정하지 않으면 기본 동작은 ibdata1이라는 12MB보다 약간 큰 단일 자동 확장 데이터 파일을 만드는 것입니다.
#
# 데이터 파일 스펙의 전체 구문에는 파일 이름(file_name), 파일 크기(file_size), 자동확장(autoextend)속성 및 최대(max)속성이 포함됩니다.
# file_name:file_size[:autoextend[:max:max_file_size]]
#
# 파일 크기는 K, M 또는 G를 크기 값에 추가하여 킬로바이트, 메가 바이트 또는 기가 바이트로 지정됩니다.
# 데이터 파일 크기를 킬로바이트로 지정하면 1024의 배수로 수행하십시오. 그렇지 않으면 KB 값은 가장 가까운 MB (MB) 경계로 반올림됩니다. 파일 크기의 합계는 최소한 12MB보다 약간 커야합니다.
#
# 추가 구성 정보는 시스템 테이블 스페이스 데이터 파일 구성을 참조하십시오. 크기 조정 지침은 시스템 테이블 스페이스 크기 조정을 참조하십시오.
#
# * Apply Option
# innodb_data_file_path=ibdata1:12M:autoextend
#
# --------------------------------------------
#
# @ innodb_data_home_dir
#
# Property : Value
# Command-Line Format : --innodb-data-home-dir=dir_name
# System Variable : innodb_data_home_dir
# Scope : Global
# Dynamic	No
# Type : Directory name
#
# InnoDB 시스템 테이블 스페이스 데이터 파일에 대한 디렉토리 경로의 공통 부분. 이 설정은 innodb_file_per_table이 사용 가능한 경우 테이블 당 파일 공간의 위치에 영향을 미치지 않습니다.
# 기본값은 MySQL 데이터 디렉토리입니다. 값을 빈 문자열로 지정하면 innodb_data_file_path에 대한 절대 파일 경로를 지정할 수 있습니다.
#
# innodb_data_home_dir에 값을 지정할 때 후행 슬래시가 필요합니다. 예를 들면 다음과 같습니다.
#
# [mysqld]
# innodb_data_home_dir = /path/to/myibdata/
#
# 관련 정보는 14.8.1 절“InnoDB 시작 구성”을 참조하십시오.
#
# * Apply Option
# innodb_data_home_dir=OFF
#
# --------------------------------------------
# 
# innodb_large_prefix
# 
# Command-Line Format	--innodb-large-prefix[={OFF|ON}]
# Deprecated	Yes
# System Variable	innodb_large_prefix
# Scope	Global
# Dynamic	Yes
# Type	Boolean
# Default Value	ON
# 
# 이 옵션이 활성화되면 DYNAMIC 또는 COMPRESSED행 형식을 사용하는 InnoDB 테이블에 대해 767 바이트 (최대 3072 바이트)보다 긴 인덱스 키 접두사가 허용됩니다.
# 다양한 설정에서 인덱스 키 접두사와 관련된 최대 값은 14.23 절.“InnoDB 제한”을 참조하십시오.
# 
# REDUNDANT 또는 COMPACT 행 형식을 사용하는 테이블의 경우이 옵션은 허용된 인덱스 키 접두사 길이에 영향을주지 않습니다.
# 
# innodb_large_prefix는 MySQL 5.7에서 기본적으로 활성화되어 있습니다. 이 변경 사항은 MySQL 5.7에서 기본적으로 Barracuda로 설정되는 innodb_file_format의 기본값 변경과 일치합니다.
# 이러한 기본값 변경을 함께 사용하면 DYNAMIC 또는 COMPRESSED 행 형식을 사용할 때 더 큰 인덱스 키 접두사를 만들 수 있습니다.
# 두 옵션 중 하나를 기본값이 아닌 값으로 설정하면 767 바이트보다 큰 인덱스 키 접두사가 자동으로 잘립니다.
# 
# innodb_large_prefix는 더 이상 사용되지 않습니다. 향후 릴리스에서 제거 될 예정입니다.
# innodb_large_prefix는 대형 인덱스 키 접두사를 지원하지 않는 이전 버전의 InnoDB와의 호환성을 위해 대형 인덱스 키 접두사를 비활성화하기 위해 도입되었습니다.
# 
# * Apply Option
# innodb_large_prefix=ON
# 
# --------------------------------------------
#
# @ innodb_deadlock_detect
#
# Property : Value
# Command-Line Format : --innodb-deadlock-detect[={OFF|ON}]
# Introduced	5.7.15
# System Variable : innodb_deadlock_detect
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# 이 옵션은 교착 상태 감지를 비활성화하는 데 사용됩니다. 동시성이 높은 시스템에서 교착 상태 감지로 인해 많은 스레드가 동일한 잠금을 기다릴 때 속도가 느려질 수 있습니다.
# 때때로 교착 상태 감지를 사용하지 않고 교착 상태가 발생할 때 트랜잭션 롤백에 innodb_lock_wait_timeout 설정을 사용하는 것이 더 효율적일 수 있습니다.
#
# 관련 정보는 14.7.5.2 절“데드락 감지 및 롤백”을 참조하십시오.
#
# * Apply Option
# innodb_deadlock_detect=ON
#
# --------------------------------------------
#
# @ innodb_default_row_format
#
# Property : Value
# Command-Line Format : --innodb-default-row-format=value
# System Variable : innodb_default_row_format
# Scope : Global
# Dynamic	Yes
# Type : Enumeration
# Default Value : DYNAMIC
# Valid Values DYNAMIC, COMPACT, REDUNDANT
#
# innodb_default_row_format 옵션은 InnoDB 테이블 및 사용자가 만든 임시 테이블의 기본 행 형식을 정의합니다.
# 기본 설정은 DYNAMIC입니다. 허용되는 다른 값은 COMPACT 및 REDUNDANT입니다. 시스템 테이블 스페이스에서 사용하도록 지원되지 않는 COMPRESSED 행 형식을 기본값으로 정의 할 수 없습니다.
#
# 새로 작성된 테이블은 ROW_FORMAT 옵션이 명시 적으로 지정되지 않거나 ROW_FORMAT = DEFAULT가 사용될 때 innodb_default_row_format에 의해 정의 된 행 형식을 사용합니다.
#
# ROW_FORMAT 옵션을 명시 적으로 지정하지 않거나 ROW_FORMAT = DEFAULT를 사용하는 경우 테이블을 다시 작성하는 모든 조작은 테이블의 행 형식을 자동으로 innodb_default_row_format에 의해 정의 된 형식으로 변경합니다.
# 자세한 내용은 테이블의 행 형식 정의를 참조하십시오.
#
# 서버가 쿼리를 처리하기 위해 만든 내부 InnoDB 임시 테이블은 innodb_default_row_format 설정에 관계없이 DYNAMIC 행 형식을 사용합니다.
#
# * Apply Option
# innodb_default_row_format=DYNAMIC
#
# --------------------------------------------
#
# @ innodb_disable_sort_file_cache
#
# Property : Value
# Command-Line Format : --innodb-disable-sort-file-cache[={OFF|ON}]
# System Variable : innodb_disable_sort_file_cache
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# 병합 정렬 임시 파일에 대한 운영 체제 파일 시스템 캐시를 비활성화합니다. 결과는 O_DIRECT와 동등한 파일을 여는 것입니다.
#
# * Apply Option
# innodb_disable_sort_file_cache=OFF
#
# --------------------------------------------
#
# @ innodb_disable_resize_buffer_pool_debug
#
# Property : Value
# Command-Line Format : --innodb-disable-resize-buffer-pool-debug[={OFF|ON}]
# System Variable : innodb_disable_resize_buffer_pool_debug
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# InnoDB 버퍼 풀의 크기 조정을 비활성화합니다. 이 옵션은 디버깅 지원이 WITH_DEBUG CMake 옵션을 사용하여 컴파일 된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# innodb_disable_resize_buffer_pool_debug=ON
#
# --------------------------------------------
#
# @ innodb_doublewrite
#
# Property : Value
# Command-Line Format : --innodb-doublewrite[={OFF|ON}]
# System Variable : innodb_doublewrite
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : ON
#
# 활성화되면 (기본값) InnoDB는 모든 데이터를 먼저 이중 쓰기 버퍼에 저장 한 다음 실제 데이터 파일에 두 번 저장합니다.
# 이 변수는 데이터 무결성 또는 가능한 오류에 대한 우려보다는 벤치 마크 또는 최고 성능이 필요한 경우에 --skip-innodb-doublewrite를 사용하여 해제 할 수 있습니다.
#
# 시스템 테이블 스페이스 데이터 파일 (ibdata * 파일)이 원자 쓰기를 지원하는 Fusion-io 장치에있는 경우 이중 쓰기 버퍼링이 자동으로 비활성화되고 Fusion-io 원자 쓰기가 모든 데이터 파일에 사용됩니다.
# 이중 쓰기 버퍼 설정은 전역이므로, 퓨전이 아닌 하드웨어에 상주하는 데이터 파일에 대해서는 이중 쓰기 버퍼링도 비활성화됩니다.
# 이 기능은 Fusion-io 하드웨어에서만 지원되며 Linux에서는 Fusion-io NVMFS에서만 활성화됩니다. 이 기능을 최대한 활용하려면 innodb_flush_method 설정 O_DIRECT를 권장합니다.
#
# 관련 정보는 14.6.5 절“이중 쓰기 버퍼”를 참조하십시오.
#
# * Apply Option
# innodb_doublewrite=ON
#
# --------------------------------------------
#
# @ innodb_fast_shutdown
#
# Property : Value
# Command-Line Format : --innodb-fast-shutdown=#
# System Variable : innodb_fast_shutdown
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 1
# Valid Values 0, 1, 2
#
# InnoDB 종료 모드 값이 0이면 InnoDB는 종료 전에 느린 종료, 전체 제거 및 변경 버퍼 병합을 수행합니다.
# 값이 1 (기본값)이면 InnoDB는 종료시 이러한 작업을 건너 뜁니다.이 프로세스는 빠른 종료라고합니다.
# 값이 2 인 경우 InnoDB는 마치 MySQL이 충돌 한 것처럼 로그를 플러시하고 콜드 셧다운합니다. 커밋 된 트랜잭션은 손실되지 않지만 응급 복구 작업으로 인해 다음 시작 시간이 더 오래 걸립니다.
#
# 상당한 양의 데이터가 여전히 버퍼링되는 극단적 인 경우 느린 종료에는 몇 분 또는 몇 시간이 걸릴 수 있습니다.
# 업그레이드 프로세스가 파일 형식을 업데이트 할 경우 모든 데이터 파일이 완전히 준비되도록 MySQL 주 릴리스간에 업그레이드하거나 다운 그레이드하기 전에 느린 종료 기술을 사용하십시오.
#
# 비상 또는 문제 해결 상황에서 innodb_fast_shutdown = 2를 사용하면 데이터가 손상 될 위험이있는 경우 절대적으로 가장 빨리 종료됩니다.
#
# * Apply Option
# innodb_fast_shutdown=1
#
# --------------------------------------------
#
# @ innodb_fil_make_page_dirty_debug
#
# Property : Value
# Command-Line Format : --innodb-fil-make-page-dirty-debug=#
# System Variable : innodb_fil_make_page_dirty_debug
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
# Maximum Value	2**32-1
#
# 기본적으로 innodb_fil_make_page_dirty_debug를 테이블 스페이스의 ID로 설정하면 테이블 스페이스의 첫 페이지가 즉시 지워집니다.
# innodb_saved_page_number_debug가 기본값이 아닌 값으로 설정된 경우 innodb_fil_make_page_dirty_debug를 설정하면 지정된 페이지가 지워집니다.
# innodb_fil_make_page_dirty_debug 옵션은 WITH_DEBUG CMake 옵션을 사용하여 디버깅 지원이 컴파일 된 경우에만 사용 가능합니다.
#
# * Apply Option
# innodb_fil_make_page_dirty_debug=0
#
# --------------------------------------------
#
# @ innodb_file_format
#
# Property : Value
# Command-Line Format : --innodb-file-format=value
# Deprecated	Yes
# System Variable : innodb_file_format
# Scope : Global
# Dynamic	Yes
# Type : String
# Default Value : Barracuda
# Valid Values Antelope, Barracuda
#
# 테이블 당 파일 공간 테이블 스페이스에 InnoDB 파일 형식을 사용합니다. 지원되는 파일 형식은 Antelope 및 Barracuda입니다.
# 영양은 원래 InnoDB 파일 형식이며 REDUNDANT 및 COMPACT 행 형식을 지원합니다. 바라쿠다는 새로운 파일 형식으로 압축 및 동적 행 형식을 지원합니다.
#
# COMPRESSED 및 DYNAMIC 행 형식을 사용하면 InnoDB 테이블에 중요한 스토리지 기능을 사용할 수 있습니다. 14.11 절“InnoDB 행 형식”을 참조하십시오.
#
# innodb_file_format 설정을 변경해도 기존 InnoDB 테이블 스페이스 파일의 파일 형식에는 영향을 미치지 않습니다.
#
# innodb_file_format 설정은 모든 행 형식의 테이블을 지원하는 일반 테이블 스페이스에는 적용되지 않습니다. 14.6.3.3 절“일반 테이블 스페이스”를 참조하십시오.
#
# innodb_file_format 기본값은 MySQL 5.7에서 Barracuda로 변경되었습니다.
#
# DYNAMIC 행 형식을 사용하는 테이블을 작성할 때는 innodb_file_format 설정이 무시됩니다. DYNAMIC 행 형식을 사용하여 작성된 테이블은 innodb_file_format 설정에 관계없이 항상 Barracuda 파일 형식을 사용합니다.
# COMPRESSED 행 형식을 사용하려면 innodb_file_format을 Barracuda로 설정해야합니다.
#
# innodb_file_format 옵션은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다. innodb_file_format 옵션의 목적은 사용자가 이전 버전의 MySQL에서 내장 버전의 InnoDB로 다운 그레이드 할 수 있도록하는 것입니다.
# 이러한 MySQL 버전이 제품 수명주기의 끝에 도달 했으므로이 옵션에서 제공하는 다운 그레이드 지원이 더 이상 필요하지 않습니다.
#
# 자세한 내용은 14.10 절“InnoDB 파일 형식 관리”를 참조하십시오.
#
# * Apply Option
# innodb_file_format=Barracuda
#
# --------------------------------------------
#
# @ innodb_file_format_check
#
# Property : Value
# Command-Line Format : --innodb-file-format-check[={OFF|ON}]
# Deprecated	Yes
# System Variable : innodb_file_format_check
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : ON
#
# InnoDB가 시스템 테이블 스페이스 (예 : Antelope 또는 Barracuda)에서 파일 형식 태그를 검사하는지 여부를 활성화 또는 비활성화하기 위해 서버 시작시이 변수를 1 또는 0으로 설정할 수 있습니다.
# 태그가 확인되어 현재 버전의 InnoDB에서 지원하는 것보다 높은 경우 오류가 발생하고 InnoDB가 시작되지 않습니다. 태그가 높지 않으면 InnoDB는 innodb_file_format_max의 값을 파일 형식 태그로 설정합니다.
#
# 노트
# 기본값이 때때로 ON 또는 OFF로 표시 되더라도 항상 구성 파일 또는 명령 행 문자열에서이 옵션을 켜거나 끄려면 숫자 1 또는 0을 사용하십시오.
#
# 자세한 내용은 14.10.2.1 절“InnoDB가 시작될 때의 호환성 검사”를 참조하십시오.
#
# innodb_file_format_check 옵션은 innodb_file_format 옵션과 함께 더 이상 사용되지 않습니다. 두 가지 옵션 모두 향후 릴리스에서 제거 될 예정입니다.
#
# * Apply Option
# innodb_file_format_check=ON
#
# --------------------------------------------
#
# @ innodb_file_format_max
#
# Property : Value
# Command-Line Format : --innodb-file-format-max=value
# Deprecated	Yes
# System Variable : innodb_file_format_max
# Scope : Global
# Dynamic	Yes
# Type : String
# Default Value : Barracuda
# Valid Values Antelope, Barracuda
#
# 서버 시작시 InnoDB는이 변수의 값을 시스템 테이블 스페이스의 파일 형식 태그 (예 : Antelope 또는 Barracuda)로 설정합니다. 서버가 "더 높은"파일 형식으로 테이블을 작성하거나 열면 innodb_file_format_max의 값을 해당 형식으로 설정합니다.
#
# 관련 정보는 14.10 절.“InnoDB 파일 형식 관리”에서 참조하십시오.
#
# innodb_file_format_max 옵션은 innodb_file_format 옵션과 함께 더 이상 사용되지 않습니다. 두 가지 옵션 모두 향후 릴리스에서 제거 될 예정입니다.
#
# * Apply Option
# innodb_file_format_max=Barracuda
#
# --------------------------------------------
#
# @ innodb_file_per_table
#
# Property : Value
# Command-Line Format : --innodb-file-per-table[={OFF|ON}]
# System Variable : innodb_file_per_table
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# innodb_file_per_table이 사용 가능한 경우, 테이블은 기본적으로 파일 당 테이블 스페이스에 작성됩니다. 비활성화하면 기본적으로 테이블이 시스템 테이블 스페이스에 생성됩니다.
# 테이블 당 파일 테이블 스페이스에 대한 정보는 14.6.3.2 절“테이블 당 파일 테이블 스페이스”를 참조하십시오. InnoDB 시스템 테이블 스페이스에 대한 정보는 14.6.3.1 절“시스템 테이블 스페이스”를 참조하십시오.
#
# innodb_file_per_table 변수는 SET GLOBAL 문을 사용하여 런타임시 구성하거나 시작시 명령 행에 지정하거나 옵션 파일에 지정할 수 있습니다.
# 런타임시 구성에는 전역 시스템 변수를 설정하기에 충분한 권한이 필요하며 (5.1.8.1 절.“시스템 변수 권한”참조) 모든 연결 작업에 즉시 영향을 미칩니다.
#
# 테이블 당 파일 테이블 스페이스에있는 테이블이 잘 리거나 삭제되면 사용 가능한 공간이 운영 체제로 리턴됩니다. 시스템 테이블 스페이스에있는 테이블을 잘라내거나 삭제하면 시스템 테이블 스페이스의 공간 만 비워집니다.
# 시스템 테이블 스페이스의 사용 가능한 공간은 InnoDB 데이터에 다시 사용될 수 있지만 시스템 테이블 스페이스 데이터 파일은 절대 축소되지 않으므로 운영 체제로 반환되지 않습니다.
#
# innodb_file_per_table이 사용 가능한 경우 시스템 테이블 스페이스에 상주하는 테이블에서 테이블 복사 ALTER TABLE 조작은 테이블 당 테이블 스페이스에 테이블을 내재적으로 다시 작성합니다.
# 이를 방지하려면 시스템 테이블 스페이스에있는 테이블에서 테이블 복사 ALTER TABLE 조작을 실행하기 전에 innodb_file_per_table을 비활성화하십시오.
#
# innodb_file_per-table 설정은 임시 테이블 작성에 영향을 미치지 않습니다. 임시 테이블은 임시 테이블 스페이스에 작성됩니다. 14.6.3.5 절“임시 테이블 스페이스”를 참조하십시오.
#
# * Apply Option
# innodb_file_per_table=ON
#
# --------------------------------------------
#
# @ innodb_fill_factor
#
# Property : Value
# Command-Line Format : --innodb-fill-factor=#
# System Variable : innodb_fill_factor
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 100
# Minimum Value	10
# Maximum Value	100
#
# InnoDB는 인덱스 생성 또는 재 구축시 대량로드를 수행합니다. 이 색인 작성 방법을 "정렬 색인 작성"이라고합니다.
#
# innodb_fill_factor는 정렬 된 인덱스 빌드 중에 채워지는 각 B- 트리 페이지의 공간 백분율을 정의하며 남은 공간은 향후 인덱스 증가를 위해 예약됩니다.
# 예를 들어 innodb_fill_factor를 80으로 설정하면 향후 인덱스 증가를 위해 각 B- 트리 페이지에 20 %의 공간이 예약됩니다. 실제 비율은 다를 수 있습니다. innodb_fill_factor 설정은 하드 한계가 아니라 힌트로 해석됩니다.
#
# innodb_fill_factor를 100으로 설정하면 클러스터 된 인덱스 페이지 공간의 1/16에 여유 공간이 생겨 향후 인덱스 증가가 가능합니다.
#
# innodb_fill_factor는 B- 트리 리프 및 비 리프 페이지 모두에 적용됩니다. TEXT 또는 BLOB 항목에 사용되는 외부 페이지에는 적용되지 않습니다.
#
# 자세한 내용은 14.6.2.3 절.“분류 된 인덱스 빌드”를 참조하십시오.
#
# * Apply Option
# innodb_fill_factor=100
#
# --------------------------------------------
#
# @ innodb_flush_log_at_timeout
#
# Property : Value
# Command-Line Format : --innodb-flush-log-at-timeout=#
# System Variable : innodb_flush_log_at_timeout
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 1
# Minimum Value	1
# Maximum Value	2700
#
# N 초마다 로그를 작성하고 플러시하십시오. innodb_flush_log_at_timeout은 플러시를 줄이고 이진 로그 그룹 커밋의 성능에 영향을 미치지 않도록 플러시 사이의 시간 초과 기간을 늘릴 수 있습니다.
# innodb_flush_log_at_timeout의 기본 설정은 초당 한 번입니다.
#
#
# * Apply Option
# innodb_flush_log_at_timeout=1
#
# --------------------------------------------
#
# @ innodb_flush_log_at_trx_commit
#
# Property : Value
# Command-Line Format : --innodb-flush-log-at-trx-commit=#
# System Variable : innodb_flush_log_at_trx_commit
# Scope : Global
# Dynamic	Yes
# Type : Enumeration
# Default Value : 1
# Valid Values 0, 1, 2
#
# 커밋 작업에 대한 엄격한 ACID 준수와 커밋 관련 I / O 작업을 다시 배치하고 일괄 처리 할 때 가능한 고성능 간의 균형을 제어합니다. 기본값을 변경하여 성능을 향상시킬 수 있지만 충돌로 인해 트랜잭션이 손실 될 수 있습니다.
# + ACID를 완전히 준수하려면 기본 설정 1이 필요합니다. 각 트랜잭션 커밋마다 로그가 기록되고 디스크에 플러시됩니다.
# + 0으로 설정하면 초당 로그가 기록되고 디스크에 플러시됩니다. 로그가 플러시되지 않은 트랜잭션은 충돌로 인해 손실 될 수 있습니다.
# + 2로 설정하면 각 트랜잭션 커밋 후에 로그가 작성되고 초당 한 번씩 디스크로 플러시됩니다. 로그가 플러시되지 않은 트랜잭션은 충돌로 인해 손실 될 수 있습니다.
# + 설정 0 및 2의 경우 초당 1 회 플러싱이 100 % 보장되지는 않습니다.
# 플러싱은 DDL 변경 및 기타 내부 InnoDB 활동으로 인해 innodb_flush_log_at_trx_commit 설정과 독립적으로 로그가 플러시되도록하는 경우가 많으며, 일정 문제로 인해 잦은 경우가 종종 없습니다.
# 로그가 초당 한 번 플러시되면 충돌로 인해 최대 1 초의 트랜잭션이 유실 될 수 있습니다. 로그가 초당 1 회 이상 자주 플러시되면 손실 될 수있는 트랜잭션의 양이 그에 따라 다릅니다.
# + 로그 플러시 빈도는 innodb_flush_log_at_timeout에 의해 제어되며, 로그 플러시 빈도를 N 초 (여기서 N은 1 ... 2700, 기본값은 1 임)로 설정할 수 있습니다. 그러나 mysqld 프로세스 충돌은 최대 N 초의 트랜잭션을 지울 수 있습니다.
# + DDL 변경 및 기타 내부 InnoDB 활동은 innodb_flush_log_at_trx_commit 설정과 독립적으로 로그를 플러시합니다.
# + InnoDB 응급 복구는 innodb_flush_log_at_trx_commit 설정에 관계없이 작동합니다. 트랜잭션은 전체적으로 적용되거나 완전히 지워집니다.
#
# 트랜잭션과 함께 InnoDB를 사용하는 복제 설정에서 내구성과 일관성을 유지하려면 :
# + 이진 로깅이 활성화 된 경우 sync_binlog = 1을 설정하십시오.
# + 항상 innodb_flush_log_at_trx_commit = 1로 설정하십시오.
#
# 주의
# 많은 운영 체제와 일부 디스크 하드웨어는 디스크 비우기 작업을 속입니다. 그들은 플러시가 발생하지 않았지만 mysqld에게 플러시가 발생했다고 말할 수 있습니다.
# 이 경우 권장 설정으로도 트랜잭션의 내구성을 보장 할 수 없으며 최악의 경우 정전으로 인해 InnoDB 데이터가 손상 될 수 있습니다.
# SCSI 디스크 컨트롤러나 디스크 자체에서 배터리 백업 디스크 캐시를 사용하면 파일 플러시 속도가 빨라지고 작업이 더 안전 해집니다. 하드웨어 캐시에서 디스크 쓰기 캐싱을 비활성화 할 수도 있습니다.
#
# * Apply Option
# innodb_flush_log_at_trx_commit=1
#
# --------------------------------------------
#
# @ innodb_flush_method
#
# Property : Value
# Command-Line Format : --innodb-flush-method=value
# System Variable : innodb_flush_method
# Scope : Global
# Dynamic	No
# Type : String
# Default Value : NULL
# Valid Values (Windows) async_unbuffered, normal, unbuffered
# Valid Values (Unix)	fsync, O_DSYNC, littlesync, nosync, O_DIRECT, O_DIRECT_NO_FSYNC
#
# I / O 처리량에 영향을 줄 수있는 InnoDB 데이터 파일 및 로그 파일로 데이터를 플러시하는 데 사용되는 방법을 정의합니다.
#
# 유닉스 계열 시스템에서 innodb_flush_method가 NULL로 설정되어 있으면 기본적으로 fsync 옵션이 사용됩니다.
# Windows에서 innodb_flush_method가 NULL로 설정되어 있으면 async_unbuffered 옵션이 기본적으로 사용됩니다.
#
# 유닉스 계열 시스템의 innodb_flush_method 옵션은 다음과 같습니다.
# + fsync : InnoDB는 fsync () 시스템 호출을 사용하여 데이터와 로그 파일을 모두 플러시합니다. 기본 설정은 fsync입니다.
# + O_DSYNC : InnoDB는 O_SYNC를 사용하여 로그 파일을 열고 플러시하고 fsync ()를 사용하여 데이터 파일을 플러시합니다. InnoDB는 다양한 유닉스 계열에 문제가 있기 때문에 O_DSYNC를 직접 사용하지 않습니다.
# + littlesync :이 옵션은 내부 성능 테스트에 사용되며 현재 지원되지 않습니다. 자신의 책임하에 사용하십시오.
# + nosync :이 옵션은 내부 성능 테스트에 사용되며 현재 지원되지 않습니다. 자신의 책임하에 사용하십시오.
# + O_DIRECT : InnoDB는 O_DIRECT (또는 Solaris의 directio ())를 사용하여 데이터 파일을 열고 fsync ()를 사용하여 데이터와 로그 파일을 모두 플러시합니다.
#   이 옵션은 일부 GNU / Linux 버전, FreeBSD 및 Solaris에서 사용할 수 있습니다.
# + O_DIRECT_NO_FSYNC : InnoDB는 I / O를 비우는 동안 O_DIRECT를 사용하지만 각 쓰기 작업 후 fsync () 시스템 호출을 건너 뜁니다.
# MySQL 5.7.25 이전에는 이 ​​설정은 파일 시스템 메타 데이터 변경을 동기화하기 위해 fsync () 시스템 호출이 필요한 XFS 및 EXT4와 같은 파일 시스템에는 적합하지 않습니다.
# 파일 시스템에 파일 시스템 메타 데이터 변경 사항을 동기화하기 위해 fsync () 시스템 호출이 필요한지 확실하지 않으면 대신 O_DIRECT를 사용하십시오.
# MySQL 5.7.25부터 fsync ()는 파일 시스템 메타 데이터 변경이 동기화되도록 파일 크기를 늘리거나 파일을 닫은 후 새 파일을 만든 후 호출됩니다. 각 쓰기 작업 후에도 fsync () 시스템 호출은 건너 뜁니다.
# 리두 로그 파일과 데이터 파일이 다른 저장 장치에 상주하고 배터리 백업이되지 않은 장치 캐시에서 데이터 파일 쓰기가 플러시되기 전에 충돌이 발생합니다.
# 리두 로그 파일 및 데이터 파일에 다른 저장 장치를 사용하거나 사용하려는 경우 데이터 파일이 배터리로 백업되지 않는 캐시가있는 장치에있는 경우 대신 O_DIRECT를 사용하십시오.
#
# Windows 시스템의 innodb_flush_method 옵션은 다음과 같습니다.
# + async_unbuffered : InnoDB는 Windows 비동기 I / O 및 비 버퍼 I / O를 사용합니다. async_unbuffered는 Windows 시스템의 기본 설정입니다.
# Windows의 4K 섹터 하드 드라이브에서 MySQL 서버를 실행하는 것은 async_unbuffered에서 지원되지 않습니다. 해결 방법은 innodb_flush_method = normal을 사용하는 것입니다.
# + 정상 : InnoDB는 시뮬레이션 된 비동기 I / O 및 버퍼 된 I / O를 사용합니다.
# + 버퍼링되지 않음 : InnoDB는 시뮬레이션 된 비동기 I / O 및 버퍼되지 않은 I / O를 사용합니다.
#
# 각 설정이 성능에 미치는 영향은 하드웨어 구성 및 작업 부하에 따라 다릅니다. 사용할 구성 또는 기본 설정을 유지할지 여부를 결정하기 위해 특정 구성을 벤치마킹하십시오.
# Innodb_data_fsyncs 상태 변수를 검사하여 각 설정에 대한 전체 fsync () 호출 수를 확인하십시오. 워크로드에서 읽기 및 쓰기 작업을 혼합하면 설정 수행 방법에 영향을 줄 수 있습니다.
# 예를 들어, 하드웨어 RAID 컨트롤러 및 배터리 지원 쓰기 캐시가있는 시스템에서 O_DIRECT는 InnoDB 버퍼 풀과 운영 체제 파일 시스템 캐시 간의 이중 버퍼링을 피하는 데 도움이 될 수 있습니다.
# InnoDB 데이터 및 로그 파일이 SAN에있는 일부 시스템에서 대부분 SELECT 문이있는 읽기 작업량이 많은 경우 기본값 또는 O_DSYNC가 더 빠를 수 있습니다.
# 프로덕션 환경을 반영하는 하드웨어 및 워크로드로이 매개 변수를 항상 테스트하십시오. 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
#
# * Apply Option
# innodb_flush_method=NULL
#
# --------------------------------------------
#
# @ innodb_flush_neighbors
#
# Property : Value
# Command-Line Format : --innodb-flush-neighbors=#
# System Variable : innodb_flush_neighbors
# Scope : Global
# Dynamic	Yes
# Type : Enumeration
# Default Value : 1
# Valid Values 0, 1, 2
#
# InnoDB 버퍼 풀에서 페이지를 플러시 할 때 다른 더티 페이지를 같은 정도로 플러시할지 여부를 지정합니다.
# + 0으로 설정하면 innodb_flush_neighbors가 비활성화됩니다. 같은 정도로 더러운 페이지는 플러시되지 않습니다.
# + 기본 설정 1은 같은 범위의 연속 더티 페이지를 플러시합니다.
# + 2로 설정하면 더티 페이지가 같은 정도로 플러시됩니다.
#
# 테이블 데이터가 기존 HDD 저장 장치에 저장되면 한 번의 작업으로 이러한 인접 페이지를 플러시하면 다른 시간에 개별 페이지를 플러시하는 것과 비교하여 (주로 디스크 탐색 작업의 경우) I / O 오버 헤드가 줄어 듭니다.
# SSD에 저장된 테이블 데이터의 경우 검색 시간은 중요한 요소가 아니며 쓰기 작업을 분산시키기 위해이 설정을 해제 할 수 있습니다. 관련 정보는 14.8.3.5 절“버퍼 풀 플러시 구성”을 참조하십시오.
#
# * Apply Option
# innodb_flush_neighbors=1
#
# --------------------------------------------
#
# @ innodb_flush_sync
#
# Property : Value
# Command-Line Format : --innodb-flush-sync[={OFF|ON}]
# System Variable : innodb_flush_sync
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# 기본적으로 사용되는 innodb_flush_sync 변수는 검사 점에서 발생하는 I / O 활동 버스트 중에 innodb_io_capacity 설정이 무시되도록합니다.
# innodb_io_capacity 설정으로 정의 된 I / O 비율을 준수하려면 innodb_flush_sync를 비활성화하십시오.
#
# innodb_flush_sync 변수 구성에 대한 자세한 내용은 14.8.8 절“InnoDB I / O 용량 구성”을 참조하십시오.
#
# * Apply Option
# innodb_flush_sync=ON
#
# --------------------------------------------
#
# @ innodb_flushing_avg_loops
#
# Property : Value
# Command-Line Format : --innodb-flushing-avg-loops=#
# System Variable : innodb_flushing_avg_loops
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 30
# Minimum Value	1
# Maximum Value	1000
#
# InnoDB가 이전에 계산 된 플러싱 상태의 스냅 샷을 유지하면서 변화하는 워크로드에 적응 형 플러싱이 얼마나 빨리 응답 하는지를 제어하는 ​​반복 횟수입니다.
# 값이 증가하면 워크로드가 변경 될 때 플러시 작업의 속도가 매끄럽고 점진적으로 변경됩니다.
# 값을 줄이면 적응 형 플러싱이 작업 부하 변경에 신속하게 조정되어 작업 부하가 급격히 증가하거나 감소하는 경우 플러싱 활동이 급증 할 수 있습니다.
#
# 관련 정보는 14.8.3.5 절“버퍼 풀 플러시 구성”을 참조하십시오.
#
# * Apply Option
# innodb_flushing_avg_loops=30
#
# --------------------------------------------
#
# @ innodb_force_load_corrupted
#
# Property : Value
# Command-Line Format : --innodb-force-load-corrupted[={OFF|ON}]
# System Variable : innodb_force_load_corrupted
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : OFF
#
# 시작시 손상된 것으로 표시된 테이블을 InnoDB가로드하도록 허용합니다. 액세스 할 수없는 데이터를 복구하려면 문제 해결 중에 만 사용하십시오. 문제 해결이 완료되면이 설정을 비활성화하고 서버를 다시 시작하십시오.
#
#
# * Apply Option
# innodb_force_load_corrupted=OFF
#
# --------------------------------------------
#
# @ innodb_force_recovery
#
# Property : Value
# Command-Line Format : --innodb-force-recovery=#
# System Variable : innodb_force_recovery
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 0
# Minimum Value	0
# Maximum Value	6
#
# 응급 복구 모드는 일반적으로 심각한 문제 해결 상황에서만 변경되었습니다. 가능한 값은 0 ~ 6입니다.이 값의 의미와 innodb_force_recovery에 대한 중요한 정보는 14.22.2 절“InnoDB 복구 강제”를 참조하십시오.
#
# 경고
# 응급 상황에서는 InnoDB를 시작하고 테이블을 덤프 할 수 있도록이 변수를 0보다 큰 값으로 만 설정하십시오.
# 안전 조치로 InnoDB는 innodb_force_recovery가 0보다 클 때 INSERT, UPDATE 또는 DELETE 작업을 방지합니다. innodb_force_recovery 설정이 4 이상이면 InnoDB가 읽기 전용 모드가됩니다.
#
# relay_log_info_repository = TABLE 및 master_info_repository = TABLE과 같은 복제 설정이 InnoDB 테이블에 정보를 저장하기 때문에 이러한 제한으로 인해 복제 관리 명령이 오류와 함께 실패 할 수 있습니다.
#
# * Apply Option
# innodb_force_recovery0
#
# --------------------------------------------
#
# @ innodb_ft_aux_table
#
# Property : Value
# System Variable : innodb_ft_aux_table
# Scope : Global
# Dynamic	Yes
# Type : String
#
# FULLTEXT 인덱스를 포함하는 InnoDB 테이블의 규정 된 이름을 지정합니다. 이 변수는 진단 목적으로 사용되며 런타임시에만 설정할 수 있습니다. 예를 들면 다음과 같습니다.
# SET GLOBAL innodb_ft_aux_table = 'test/t1';
#
# 이 변수를 db_name / table_name 형식의 이름으로 설정하면 INFORMATION_SCHEMA 테이블 INNODB_FT_INDEX_TABLE, INNODB_FT_INDEX_CACHE, INNODB_FT_CONFIG, INNODB_FT_DELETED 및
# INNODB_FT_BEING_DELETED는 지정된 테이블의 검색 색인에 대한 정보를 표시합니다.
#
# 자세한 내용은 14.16.4 절“InnoDB INFORMATION_SCHEMA FULLTEXT 인덱스 테이블”을 참조하십시오.
#
# * Apply Option
# innodb_ft_aux_table=none
#
# --------------------------------------------
#
# @ innodb_ft_cache_size
#
# Property : Value
# Command-Line Format : --innodb-ft-cache-size=#
# System Variable : innodb_ft_cache_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 8000000
# Minimum Value	1600000
# Maximum Value	80000000
#
# InnoDB FULLTEXT 인덱스를 생성하는 동안 구문 분석 된 문서를 메모리에 보유하는 InnoDB FULLTEXT 검색 인덱스 캐시에 할당 된 메모리 (바이트)입니다.
# 인덱스 삽입 및 업데이트는 innodb_ft_cache_size 크기 제한에 도달 한 경우에만 디스크에 커밋됩니다. innodb_ft_cache_size는 테이블별로 캐시 크기를 정의합니다.
# 모든 테이블에 대한 전역 제한을 설정하려면 innodb_ft_total_cache_size를 참조하십시오.
#
# 자세한 내용은 InnoDB 전체 텍스트 인덱스 캐시를 참조하십시오.
#
# * Apply Option
# innodb_ft_cache_size=8000000
#
# --------------------------------------------
#
# @ innodb_ft_enable_diag_print
#
# Property : Value
# Command-Line Format : --innodb-ft-enable-diag-print[={OFF|ON}]
# System Variable : innodb_ft_enable_diag_print
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# 추가 전체 텍스트 검색 (FTS) 진단 출력을 사용할지 여부입니다. 이 옵션은 주로 고급 FTS 디버깅을위한 것이며 대부분의 사용자에게는 관심이 없습니다. 출력은 오류 로그에 인쇄되며 다음과 같은 정보가 포함됩니다.
# + FTS 인덱스 동기화 진행률 (FTS 캐시 제한에 도달 한 경우). 예를 들면 다음과 같습니다.
# FTS SYNC for table test, deleted count: 100 size: 10000 bytes
# SYNC words: 100
#
# + FTS는 진행 상황을 최적화합니다. 예를 들면 다음과 같습니다.
# FTS start optimize test
# FTS_OPTIMIZE: optimize "mysql"
# FTS_OPTIMIZE: processed "mysql"
#
# + FTS 인덱스 구축 진행. 예를 들면 다음과 같습니다.
# Number of doc processed: 1000
#
# + FTS 쿼리의 경우 쿼리 구문 분석 트리, 단어 가중치, 쿼리 처리 시간 및 메모리 사용량이 인쇄됩니다. 예를 들면 다음과 같습니다.
# FTS Search Processing time: 1 secs: 100 millisec: row(s) 10000
# Full Search Memory: 245666 (bytes),  Row: 10000
#
# * Apply Option
# innodb_ft_enable_diag_print=OFF
#
# --------------------------------------------
#
# @ innodb_ft_enable_stopword
#
# Property : Value
# Command-Line Format : --innodb-ft-enable-stopword[={OFF|ON}]
# System Variable : innodb_ft_enable_stopword
# Scope : Global, Session
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# 인덱스가 작성 될 때 일련의 중지 단어가 InnoDB FULLTEXT 인덱스와 연관되도록 지정합니다. innodb_ft_user_stopword_table 옵션이 설정되면 해당 테이블에서 중지 어를 가져옵니다.
# 그렇지 않으면 innodb_ft_server_stopword_table 옵션이 설정되면 해당 테이블에서 중지 어를 가져옵니다. 그렇지 않으면 내장 된 기본 중지 단어 세트가 사용됩니다.
#
# 자세한 내용은 12.9.4 절“전체 텍스트 중지어”를 참조하십시오.
#
# * Apply Option
# innodb_ft_enable_stopword=ON
#
# --------------------------------------------
#
# @ innodb_ft_max_token_size
#
# Property : Value
# Command-Line Format : --innodb-ft-max-token-size=#
# System Variable : innodb_ft_max_token_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 84
# Minimum Value	10
# Maximum Value	84
#
# InnoDB FULLTEXT 인덱스에 저장된 단어의 최대 문자 길이입니다. 이 값에 대한 제한을 설정하면 색인의 크기가 줄어들어 실제 단어가 아니고 검색어가 아닐 수있는 긴 키워드 또는 임의의 문자 모음을 생략하여 쿼리 속도를 높입니다.
#
# 자세한 정보는 12.9.6 절.“Fine-Tuning MySQL 전체 텍스트 검색”에서 참조하십시오.
#
# * Apply Option
# innodb_ft_max_token_size=84
#
# --------------------------------------------
#
# @ innodb_ft_min_token_size
#
# Property : Value
# Command-Line Format : --innodb-ft-min-token-size=#
# System Variable : innodb_ft_min_token_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 3
# Minimum Value	0
# Maximum Value	16
#
# InnoDB FULLTEXT 인덱스에 저장된 최소 단어 길이. 이 값을 늘리면 영어 단어 "a"및 "to"와 같이 검색 컨텍스트에서 중요하지 않은 일반적인 단어를 생략하여 인덱스 크기를 줄이므로 쿼리 속도가 향상됩니다.
# CJK (중국어, 일본어, 한국어) 문자 세트를 사용하는 컨텐츠의 경우 값을 1로 지정하십시오.
#
# 자세한 정보는 12.9.6 절.“Fine-Tuning MySQL 전체 텍스트 검색”에서 참조하십시오.
#
# * Apply Option
# innodb_ft_min_token_size=3
#
# --------------------------------------------
#
# @ innodb_ft_num_word_optimize
#
# Property : Value
# Command-Line Format : --innodb-ft-num-word-optimize=#
# System Variable : innodb_ft_num_word_optimize
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 2000
#
# InnoDB FULLTEXT 인덱스에서 각 OPTIMIZE TABLE 작업 중에 처리 할 단어 수입니다.
# 전체 텍스트 검색 인덱스를 포함하는 테이블에 대한 대량 삽입 또는 업데이트 작업은 모든 변경 사항을 통합하기 위해 상당한 인덱스 유지 관리가 필요할 수 있으므로
# 각각 마지막에 중단 된 부분을 선택하는 일련의 OPTIMIZE TABLE 문을 수행 할 수 있습니다.
#
# 자세한 정보는 12.9.6 절.“Fine-Tuning MySQL 전체 텍스트 검색”에서 참조하십시오.
#
# * Apply Option
# innodb_ft_num_word_optimize=2000
#
# --------------------------------------------
#
# @ innodb_ft_result_cache_limit
#
# Property : Value
# Command-Line Format : --innodb-ft-result-cache-limit=#
# System Variable : innodb_ft_result_cache_limit
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 2000000000
# Minimum Value	1000000
# Maximum Value	2**32-1
#
# 전체 텍스트 검색 쿼리 또는 스레드 당 InnoDB 전체 텍스트 검색 쿼리 결과 캐시 제한 (바이트로 정의). 중간 및 최종 InnoDB 전체 텍스트 검색 쿼리 결과는 메모리에서 처리됩니다.
# InnoDB 전체 텍스트 검색 쿼리 결과가 매우 큰 경우 (예 : 수백만 또는 수억 행) 전체 텍스트 검색 쿼리 결과 캐시에 크기 제한을 설정하려면 innodb_ft_result_cache_limit를 사용하십시오.
# 전체 텍스트 검색 쿼리가 처리 될 때 필요에 따라 메모리가 할당됩니다. 결과 캐시 크기 제한에 도달하면 쿼리가 최대 허용 메모리를 초과했음을 나타내는 오류가 반환됩니다.
#
# 모든 플랫폼 유형 및 비트 크기에 대한 innodb_ft_result_cache_limit의 최대 값은 2 ** 32-1입니다.
#
# * Apply Option
# innodb_ft_result_cache_limit=2000000000
#
# --------------------------------------------
#
# @ innodb_ft_server_stopword_table
#
# Property : Value
# Command-Line Format : --innodb-ft-server-stopword-table=db_name/table_name
# System Variable : innodb_ft_server_stopword_table
# Scope : Global
# Dynamic	Yes
# Type : String
# Default Value : NULL
#
# 이 옵션은 모든 InnoDB 테이블에 대해 고유 한 InnoDB FULLTEXT 인덱스 중지 단어 목록을 지정하는 데 사용됩니다. 특정 InnoDB 테이블에 대한 고유 한 중지 단어 목록을 구성하려면 innodb_ft_user_stopword_table을 사용하십시오.
#
# innodb_ft_server_stopword_table을 중지 단어 목록이 포함 된 테이블 이름으로 db_name / table_name 형식으로 설정하십시오.
#
# innodb_ft_server_stopword_table을 구성하기 전에 중지 단어 테이블이 있어야합니다. FULLTEXT 색인을 작성하기 전에 innodb_ft_enable_stopword를 사용으로 설정하고 innodb_ft_server_stopword_table 옵션을 구성해야합니다.
#
# 중지 단어 테이블은 value라는 단일 VARCHAR 열을 포함하는 InnoDB 테이블이어야합니다.
#
# 자세한 내용은 12.9.4 절“전체 텍스트 중지어”를 참조하십시오.
#
# * Apply Option
# innodb_ft_server_stopword_table=NULL
#
# --------------------------------------------
#
# @ innodb_ft_sort_pll_degree
#
# Property : Value
# Command-Line Format : --innodb-ft-sort-pll-degree=#
# System Variable : innodb_ft_sort_pll_degree
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 2
# Minimum Value	1
# Maximum Value	32
#
# 검색 색인을 작성할 때 InnoDB FULLTEXT 색인에서 텍스트를 색인화하고 토큰 화하기 위해 병렬로 사용되는 스레드 수입니다.
#
# 관련 정보는 14.6.2.4 절.“InnoDB FULLTEXT 인덱스”및 innodb_sort_buffer_size를 참조하십시오.
#
# * Apply Option
# innodb_ft_sort_pll_degree=2
#
# --------------------------------------------
#
# @ innodb_ft_total_cache_size
#
# Property : Value
# Command-Line Format : --innodb-ft-total-cache-size=#
# System Variable : innodb_ft_total_cache_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 640000000
# Minimum Value	32000000
# Maximum Value	1600000000
#
# 모든 테이블에 대한 InnoDB 전체 텍스트 검색 인덱스 캐시에 할당 된 총 메모리 (바이트)입니다. 각각 FULLTEXT 검색 색인이있는 수많은 테이블을 작성하면 사용 가능한 메모리의 상당 부분이 소비 될 수 있습니다.
# innodb_ft_total_cache_size는 모든 전체 텍스트 검색 인덱스에 대한 전체 메모리 제한을 정의하여 과도한 메모리 소비를 방지합니다. 인덱스 작업으로 전역 제한에 도달하면 강제 동기화가 트리거됩니다.
#
# 자세한 내용은 InnoDB 전체 텍스트 인덱스 캐시를 참조하십시오.
#
# * Apply Option
# innodb_ft_total_cache_size=640000000
#
# --------------------------------------------
#
# @ innodb_ft_user_stopword_table
#
# Property : Value
# Command-Line Format : --innodb-ft-user-stopword-table=db_name/table_name
# System Variable : innodb_ft_user_stopword_table
# Scope : Global, Session
# Dynamic	Yes
# Type : String
# Default Value : NULL
#
# 이 옵션은 특정 테이블에 고유 한 InnoDB FULLTEXT 인덱스 중지 단어 목록을 지정하는 데 사용됩니다. 모든 InnoDB 테이블에 대한 고유 한 중지 단어 목록을 구성하려면 innodb_ft_server_stopword_table을 사용하십시오.
#
# innodb_ft_user_stopword_table을 db_name / table_name 형식으로 중지 단어 목록을 포함하는 테이블 이름으로 설정하십시오.
#
# innodb_ft_user_stopword_table을 구성하기 전에 중지 단어 테이블이 있어야합니다. FULLTEXT 색인을 작성하기 전에 innodb_ft_enable_stopword가 사용 가능하고 innodb_ft_user_stopword_table을 구성해야합니다.
#
# 중지 단어 테이블은 value라는 단일 VARCHAR 열을 포함하는 InnoDB 테이블이어야합니다.
#
# 자세한 내용은 12.9.4 절“전체 텍스트 중지 어”를 참조하십시오.
#
# * Apply Option
# innodb_ft_user_stopword_table=NULL
#
# --------------------------------------------
#
# @ innodb_io_capacity
#
# Property : Value
# Command-Line Format : --innodb-io-capacity=#
# System Variable : innodb_io_capacity
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 200
# Minimum Value	100
# Maximum Value (64-bit platforms)	2**64-1
# Maximum Value (32-bit platforms)	2**32-1
#
# innodb_io_capacity 변수는 버퍼 풀에서 페이지를 플러시하고 변경 버퍼에서 데이터를 병합하는 등 InnoDB 백그라운드 작업에 사용할 수있는 초당 I / O 작업 (IOPS) 수를 정의합니다.
#
# innodb_io_capacity 변수 구성에 대한 자세한 내용은 14.8.8 절“InnoDB I / O 용량 구성”을 참조하십시오.
#
# * Apply Option
# innodb_io_capacity=200
#
# --------------------------------------------
#
# @ innodb_io_capacity_max
#
# Property : Value
# Command-Line Format : --innodb-io-capacity-max=#
# System Variable : innodb_io_capacity_max
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : see description
# Minimum Value	100
# Maximum Value (Windows, 64-bit platforms)	2**32-1
# Maximum Value (Unix, 64-bit platforms)	2**64-1
# Maximum Value (32-bit platforms)	2**32-1
#
# 플러싱 활동이 뒤처지면 InnoDB는 innodb_io_capacity 변수에 의해 정의 된 것보다 더 높은 초당 I / O 작업 속도 (IOPS)로 더 적극적으로 플러시 할 수 있습니다.
# innodb_io_capacity_max 변수는 이러한 상황에서 InnoDB 백그라운드 작업이 수행하는 최대 IOPS 수를 정의합니다.
#
# innodb_io_capacity_max 변수 구성에 대한 자세한 내용은 14.8.8 절“InnoDB I / O 용량 구성”을 참조하십시오.
#
# * Apply Option
# innodb_io_capacity_max=none
#
# --------------------------------------------
#
# @ innodb_limit_optimistic_insert_debug
#
# Property : Value
# Command-Line Format : --innodb-limit-optimistic-insert-debug=#
# System Variable : innodb_limit_optimistic_insert_debug
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
# Minimum Value	0
# Maximum Value	2**32-1
#
# B- 트리 페이지 당 레코드 수를 제한합니다. 기본값 0은 제한이 없음을 의미합니다. 이 옵션은 디버깅 지원이 WITH_DEBUG CMake 옵션을 사용하여 컴파일 된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# innodb_limit_optimistic_insert_debug=0
#
# --------------------------------------------
#
# @ innodb_lock_wait_timeout
#
# Property : Value
# Command-Line Format : --innodb-lock-wait-timeout=#
# System Variable : innodb_lock_wait_timeout
# Scope : Global, Session
# Dynamic	Yes
# Type : Integer
# Default Value : 50
# Minimum Value	1
# Maximum Value	1073741824
#
# InnoDB 트랜잭션이 포기하기 전에 행 잠금을 기다리는 시간 (초)입니다. 기본값은 50 초입니다.
# 다른 InnoDB 트랜잭션에 의해 잠긴 행에 액세스하려고 시도하는 트랜잭션은 다음 오류를 발행하기 전에 최대 몇 초 동안 행에 대한 쓰기 액세스를 기다립니다.
# 오류 1205 (HY000) : 잠금 대기 시간 초과를 초과했습니다. 거래를 다시 시작하십시오
#
# 잠금 대기 시간 종료가 발생하면 현재 명령문이 롤백됩니다 (전체 트랜잭션이 아님).
# 전체 트랜잭션을 롤백하려면 --innodb-rollback-on-timeout 옵션을 사용하여 서버를 시작하십시오. 14.22.4 절“InnoDB 에러 처리”도 참조하십시오.
#
# 대화식 응용 프로그램 또는 OLTP 시스템의 경우이 값을 낮추어 사용자 피드백을 빠르게 표시하거나 나중에 처리 할 수 ​​있도록 업데이트를 대기열에 넣을 수 있습니다.
# 다른 대규모 삽입 또는 업데이트 작업이 완료 될 때까지 기다리는 데이터웨어 하우스의 변환 단계와 같이 장기 실행 백엔드 작업의 경우이 값을 증가시킬 수 있습니다.
#
# innodb_lock_wait_timeout은 InnoDB 행 잠금에만 적용됩니다. MySQL 테이블 잠금은 InnoDB 내에서 발생하지 않으며이 시간 제한은 테이블 잠금 대기에 적용되지 않습니다.
#
# InnoDB가 교착 상태를 즉시 감지하고 교착 상태 트랜잭션 중 하나를 롤백하기 때문에 innodb_deadlock_detect가 활성화되면 (기본값) 잠금 대기 시간 초과 값이 교착 상태에 적용되지 않습니다.
# innodb_deadlock_detect가 비활성화되면 InnoDB는 교착 상태 발생시 트랜잭션 롤백을 위해 innodb_lock_wait_timeout을 사용합니다. 14.7.5.2 절“교착 상태 감지 및 롤백”을 참조하십시오.
#
# innodb_lock_wait_timeout은 SET GLOBAL 또는 SET SESSION 문으로 런타임시 설정할 수 있습니다.
# GLOBAL 설정을 변경하려면 전역 시스템 변수를 설정하기에 충분한 권한이 필요하며 (5.1.8.1 절.“시스템 변수 권한”참조) 이후에 연결되는 모든 클라이언트의 작동에 영향을 미칩니다.
# 모든 클라이언트는 해당 클라이언트에만 영향을주는 innodb_lock_wait_timeout의 SESSION 설정을 변경할 수 있습니다.
#
# * Apply Option
# innodb_lock_wait_timeout=50
#
# --------------------------------------------
# innodb_locks_unsafe_for_binlog
#
# Property	Value
# Command-Line Format	--innodb-locks-unsafe-for-binlog[={OFF|ON}]
# Deprecated	Yes
# System Variable	innodb_locks_unsafe_for_binlog
# Scope	Global
# Dynamic	No
# Type	Boolean
# Default Value	OFF
# 이 변수는 InnoDB가 검색 및 인덱스 스캔에 갭 잠금을 사용하는 방법에 영향을줍니다. innodb_locks_unsafe_for_binlog는 더 이상 사용되지 않으며 향후 MySQL 릴리스에서 제거 될 예정입니다.
#
# 일반적으로 InnoDB는 인덱스 행 잠금과 갭 잠금을 결합한 다음 키 잠금이라는 알고리즘을 사용합니다.
# InnoDB는 테이블 인덱스를 검색하거나 스캔 할 때 발생하는 인덱스 레코드에 공유 잠금 또는 독점 잠금을 설정하는 방식으로 행 수준 잠금을 수행합니다.
# 따라서 행 레벨 잠금은 실제로 인덱스 레코드 잠금입니다. 또한 인덱스 레코드의 다음 키 잠금은 인덱스 레코드 이전의 간격에도 영향을줍니다.
# 즉, 다음 키 잠금은 인덱스 레코드 잠금과 인덱스 레코드 앞의 간격에 대한 간격 잠금입니다.
# 한 세션의 인덱스에서 레코드 R에 대한 공유 또는 독점 잠금이있는 경우, 다른 세션은 인덱스 순서에서 R 바로 앞의 간격에 새 인덱스 레코드를 삽입 할 수 없습니다. 14.7.1 절“InnoDB 잠금”을 참조하십시오.
#
# 기본적으로 innodb_locks_unsafe_for_binlog의 값은 0 (비활성화 됨)으로, 갭 잠금이 활성화되어 있음을 의미합니다. InnoDB는 검색 및 인덱스 스캔에 다음 키 잠금을 사용합니다.
# 변수를 활성화하려면 1로 설정하십시오. 이렇게하면 간격 잠금이 비활성화됩니다. InnoDB는 검색 및 인덱스 스캔에 인덱스 레코드 잠금만 사용합니다.
#
# innodb_locks_unsafe_for_binlog를 활성화해도 외래 키 제약 조건 검사 또는 중복 키 검사에 갭 잠금을 사용할 수 없습니다.
#
# innodb_locks_unsafe_for_binlog를 활성화하면 트랜잭션 격리 수준을 READ COMMITTED로 설정하는 것과 동일하지만 다음과 같은 예외가 있습니다.
# + innodb_locks_unsafe_for_binlog를 활성화하면 전역 설정이며 모든 세션에 영향을주는 반면 격리 수준은 모든 세션에 대해 전체적으로 또는 세션별로 개별적으로 설정할 수 있습니다.
# + innodb_locks_unsafe_for_binlog는 서버 시작시에만 설정할 수있는 반면 격리 수준은 시작시 설정하거나 런타임에 변경할 수 있습니다.
#
# READ COMMITTED는 innodb_locks_unsafe_for_binlog보다 더 정교하고 유연한 제어 기능을 제공합니다. 간격 잠금에 대한 격리 수준의 영향에 대한 자세한 내용은 14.7.2.1 절“트랜잭션 격리 수준”을 참조하십시오.
#
# innodb_locks_unsafe_for_binlog를 활성화하면 간격 잠금이 비활성화 된 경우 다른 세션이 간격에 새 행을 삽입 할 수 있으므로 팬텀 문제가 발생할 수 있습니다.
# 자식 테이블의 id 열에 인덱스가 있고 나중에 선택한 행의 일부 열을 업데이트할 의도로 식별자 값이 100보다 큰 테이블의 모든 행을 읽고 잠그고 싶다고 가정하십시오.
# SELECT * FROM child WHERE id > 100 FOR UPDATE;
#
# 쿼리는 id가 100보다 큰 첫 번째 레코드에서 시작하여 인덱스를 스캔합니다. 해당 범위의 인덱스 레코드에 설정된 잠금이 갭에서 작성된 삽입을 잠그지 않으면 다른 세션이 테이블에 새 행을 삽입 할 수 있습니다.
# 결과적으로 동일한 트랜잭션 내에서 동일한 SELECT를 다시 실행하면 쿼리에서 반환 한 결과 집합에 새 행이 표시됩니다.
# 이것은 또한 새로운 아이템이 데이터베이스에 추가되면 InnoDB가 직렬화를 보장하지 않음을 의미합니다. 따라서 innodb_locks_unsafe_for_binlog가 활성화되면 InnoDB는 최대 격리 수준 READ COMMITTED를 보장합니다.
# 팬텀에 대한 자세한 내용은 14.7.4 절.“팬텀 행”을 참조하십시오.
#
#
# innodb_locks_unsafe_for_binlog를 활성화하면 추가 효과가 있습니다.
# + UPDATE 또는 DELETE 문의 경우 InnoDB는 업데이트하거나 삭제하는 행에 대해서만 잠금을 유지합니다. 일치하지 않는 행에 대한 레코드 잠금은 MySQL이 WHERE 조건을 평가 한 후에 해제됩니다.
# 이는 교착 상태의 가능성을 크게 줄이지 만 여전히 발생할 수 있습니다.
# + UPDATE 문의 경우 행이 이미 잠겨있는 경우 InnoDB는 "반 일치"읽기를 수행하여 최신 커밋 된 버전을 MySQL로 반환하여 MySQL이 행이 UPDATE의 WHERE 조건과 일치하는지 확인할 수 있도록합니다.
# 행이 일치하면 (갱신해야 함) MySQL은 행을 다시 읽고 이번에는 InnoDB가 행을 잠 그거나 잠금을 기다립니다.
#
# 이 테이블로 시작하여 다음 예제를 고려하십시오.
# CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
# INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
# COMMIT;
# 이 경우 테이블에 인덱스가 없으므로 검색 및 인덱스 스캔은 숨겨진 클러스터 된 인덱스를 사용하여 레코드 잠금을 수행합니다 (14.6.2.1 절“클러스터 및 보조 인덱스”참조).
#
# 한 클라이언트가 다음 명령문을 사용하여 UPDATE를 수행한다고 가정하십시오.
# SET autocommit = 0;
# UPDATE t SET b = 5 WHERE b = 3;
#
# 또한 두 번째 클라이언트가 첫 번째 클라이언트의 다음 명령문을 실행하여 UPDATE를 수행한다고 가정하십시오.
# SET autocommit = 0;
# UPDATE t SET b = 4 WHERE b = 2;
#
# InnoDB는 각 UPDATE를 실행할 때 먼저 각 행에 대한 배타적 잠금을 획득 한 후 수정할지 여부를 결정합니다. InnoDB가 행을 수정하지 않고 innodb_locks_unsafe_for_binlog가 활성화되면 잠금이 해제됩니다.
# 그렇지 않으면 InnoDB는 트랜잭션이 끝날 때까지 잠금을 유지합니다. 이는 다음과 같이 트랜잭션 처리에 영향을줍니다.
#
# innodb_locks_unsafe_for_binlog가 비활성화 된 경우 첫 번째 UPDATE는 x-lock을 획득하고 어떤 것도 해제하지 않습니다.
# x-lock(1,2); retain x-lock
# x-lock(2,3); update(2,3) to (2,5); retain x-lock
# x-lock(3,2); retain x-lock
# x-lock(4,3); update(4,3) to (4,5); retain x-lock
# x-lock(5,2); retain x-lock
#
# 두 번째 UPDATE는 잠금을 획득하려고 시도하는 즉시 (첫 번째 업데이트가 모든 행에 대한 잠금을 유지하기 때문에) 차단하며 첫 번째 UPDATE가 커밋되거나 롤백 될 때까지 진행되지 않습니다.
# x-lock(1,2); block and wait for first UPDATE to commit or roll back
#
# innodb_locks_unsafe_for_binlog가 사용 가능한 경우 첫 번째 UPDATE는 x 잠금을 획득하고 수정하지 않은 행에 대해 x 잠금을 해제합니다.
# x-lock(1,2); unlock(1,2)
# x-lock(2,3); update(2,3) to (2,5); retain x-lock
# x-lock(3,2); unlock(3,2)
# x-lock(4,3); update(4,3) to (4,5); retain x-lock
# x-lock(5,2); unlock(5,2)
#
# 두 번째 UPDATE의 경우 InnoDB는 "반 일치"읽기를 수행하여 각 행의 최신 커밋 된 버전을 MySQL로 반환하여 MySQL이 행이 UPDATE의 WHERE 조건과 일치하는지 여부를 확인할 수 있도록합니다.
# x-lock(1,2); update(1,2) to (1,4); retain x-lock
# x-lock(2,3); unlock(2,3)
# x-lock(3,2); update(3,2) to (3,4); retain x-lock
# x-lock(4,3); unlock(4,3)
# x-lock(5,2); update(5,2) to (5,4); retain x-lock
#
#
#  * Apply Option
#  innodb_locks_unsafe_for_binlog=OFF

# --------------------------------------------

#
# @ innodb_log_buffer_size
#
# Property : Value
# Command-Line Format : --innodb-log-buffer-size=#
# System Variable : innodb_log_buffer_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 16777216
# Minimum Value	1048576
# Maximum Value	4294967295
#
# InnoDB가 디스크의 로그 파일에 쓰는 데 사용하는 버퍼 크기 (바이트)입니다. 32KB 및 64KB innodb_page_size 값을 도입하여 기본값이 8MB에서 16MB로 변경되었습니다.
# 큰 로그 버퍼를 사용하면 트랜잭션을 커밋하기 전에 디스크에 로그를 쓰지 않아도 큰 트랜잭션을 실행할 수 있습니다.
# 따라서 많은 행을 업데이트, 삽입 또는 삭제하는 트랜잭션이있는 경우 로그 버퍼를 크게하면 디스크 I / O가 절약됩니다.
# 관련 정보는 메모리 구성 및 8.5.4 절“InnoDB Redo 로깅 최적화”를 참조하십시오. 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_log_buffer_size=16777216
#
# --------------------------------------------
#
# @ innodb_log_checkpoint_now
#
# Property : Value
# Command-Line Format : --innodb-log-checkpoint-now[={OFF|ON}]
# System Variable : innodb_log_checkpoint_now
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# InnoDB가 체크 포인트를 작성하도록하려면이 디버그 옵션을 활성화하십시오. 이 옵션은 디버깅 지원이 WITH_DEBUG CMake 옵션을 사용하여 컴파일 된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# innodb_log_checkpoint_now=OFF
#
# --------------------------------------------
#
# @ innodb_log_checksums
#
# Property : Value
# Command-Line Format : --innodb-log-checksums[={OFF|ON}]
# System Variable : innodb_log_checksums
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# 리두 로그 페이지의 체크섬을 활성화 또는 비활성화합니다.
#
# innodb_log_checksums = ON은 리두 로그 페이지에 대한 CRC-32C 체크섬 알고리즘을 활성화합니다. innodb_log_checksums가 비활성화되면 리두 로그 페이지 체크섬 필드의 내용이 무시됩니다.
#
# 리두 로그 헤더 페이지 및 리두 로그 체크 포인트 페이지의 체크섬은 비활성화되지 않습니다.
#
# * Apply Option
# innodb_log_checksums=ON
#
# --------------------------------------------
#
# @ innodb_log_compressed_pages
#
# Property : Value
# Command-Line Format : --innodb-log-compressed-pages[={OFF|ON}]
# System Variable : innodb_log_compressed_pages
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# 재 압축 된 페이지의 이미지가 리두 로그에 기록되는지 여부를 지정합니다. 압축 된 데이터를 변경하면 다시 압축이 발생할 수 있습니다.
#
# innodb_log_compressed_pages는 기본적으로 복구 중에 다른 버전의 zlib 압축 알고리즘을 사용하는 경우 발생할 수있는 손상을 방지하기 위해 활성화되어 있습니다.
# zlib 버전이 변경되지 않을 것으로 확신하는 경우 innodb_log_compressed_pages를 비활성화하여 압축 된 데이터를 수정하는 워크로드에 대한 재실행 로그 생성을 줄일 수 있습니다.
#
# innodb_log_compressed_pages 활성화 또는 비활성화 효과를 측정하려면 동일한 워크로드에서 두 설정에 대한 리두 로그 생성을 비교하십시오.
# 리두 로그 생성을 측정하는 옵션에는 SHOW ENGINE INNODB STATUS 출력의 LOG 섹션에서 LSN (Log sequence number) 관찰 또는 리두 로그 파일에 기록 된 바이트 수에 대한 Innodb_os_log_written 상태 모니터링이 포함됩니다.
#
# 관련 정보는 14.9.1.6 절“OLTP 작업 부하 압축”을 참조하십시오.
#
# * Apply Option
# innodb_log_compressed_pages=ON
#
# --------------------------------------------
#
# @ innodb_log_file_size
#
# Property : Value
# Command-Line Format : --innodb-log-file-size=#
# System Variable : innodb_log_file_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 50331648
# Minimum Value (≥ 5.7.11) - 4194304
# Minimum Value (≤ 5.7.10) - 1048576
# Maximum Value	512GB / innodb_log_files_in_group
#
# 로그 그룹에있는 각 로그 파일의 크기 (바이트)입니다. 로그 파일의 크기 (innodb_log_file_size * innodb_log_files_in_group)는 512GB보다 약간 작은 최대 값을 초과 할 수 없습니다. 예를 들어 한 쌍의 255GB 로그 파일이 한계에 근접하지만이를 # 초과하지는 않습니다. 기본값은 48MB입니다.
#
# 일반적으로 로그 파일의 결합 된 크기는 서버가 워크로드 활동의 최고점과 최저점을 매끄럽게 할 수있을 정도로 커야합니다. 이는 종종 1 시간 이상의 쓰기 활동을 처리하기에 충분한 재실행 로그 공간이 있음을 의미합니다. 값이 클수록 버퍼 풀에 필요한 검사 # 점 플러시 활동이 줄어들어 디스크 I / O가 절약됩니다. 로그 파일이 크면 충돌 복구 속도가 느려집니다.
#
# MySQL 5.7.11에서 최소 innodb_log_file_size 값이 1MB에서 4MB로 증가했습니다.
#
# 관련 정보는 재실행 로그 파일 구성을 참조하십시오. 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_log_file_size=50331648
#
# --------------------------------------------
#
# @ innodb_log_files_in_group
#
# Property : Value
# Command-Line Format : --innodb-log-files-in-group=#
# System Variable : innodb_log_files_in_group
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 2
# Minimum Value	2
# Maximum Value	100
#
# 로그 그룹의 로그 파일 수 InnoDB는 순환 방식으로 파일에 씁니다. 기본 (권장) 값은 2입니다. 파일의 위치는 innodb_log_group_home_dir에 의해 지정됩니다.
# 로그 파일의 크기 (innodb_log_file_size * innodb_log_files_in_group)는 최대 512GB 일 수 있습니다.
#
# 관련 정보는 재실행 로그 파일 구성을 참조하십시오.
#
# * Apply Option
# innodb_log_files_in_group=2
#
# --------------------------------------------
#
# @ innodb_log_group_home_dir
#
# Property : Value
# Command-Line Format : --innodb-log-group-home-dir=dir_name
# System Variable : innodb_log_group_home_dir
# Scope : Global
# Dynamic	No
# Type : Directory name
#
# innodb_log_files_in_group에 의해 번호가 지정되는 InnoDB 리두 로그 파일의 디렉토리 경로.
# InnoDB 로그 변수를 지정하지 않으면 기본적으로 MySQL 데이터 디렉토리에 ib_logfile0 및 ib_logfile1이라는 두 개의 파일이 생성됩니다. 로그 파일 크기는 innodb_log_file_size 시스템 변수로 제공됩니다.
#
# 관련 정보는 재실행 로그 파일 구성을 참조하십시오.
#
# * Apply Option
# innodb_log_group_home_dir=directory
#
# --------------------------------------------
#
# @ innodb_log_write_ahead_size
#
# Property : Value
# Command-Line Format : --innodb-log-write-ahead-size=#
# System Variable : innodb_log_write_ahead_size
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 8192
# Minimum Value	512 (log file block size)
# Maximum Value	Equal to innodb_page_size
#
# 재실행 로그의 미리 쓰기 블록 크기 (바이트)를 정의합니다. “읽기시 읽기”를 피하려면 운영 체제 또는 파일 시스템 캐시 블록 크기와 일치하도록 innodb_log_write_ahead_size를 설정하십시오. 기본 설정은 8192 바이트입니다. 재기록 로그 블록이 재실행 # 로그의 미리 쓰기 블록 크기와 운영 체제 또는 파일 시스템 캐시 블록 크기 사이의 불일치로 인해 재실행 로그 블록이 운영 체제 또는 파일 시스템에 완전히 캐시되지 않은 경우 읽기-쓰기가 발생합니다.
#
# innodb_log_write_ahead_size의 유효한 값은 InnoDB 로그 파일 블록 크기 (2n)의 배수입니다. 최소값은 InnoDB 로그 파일 블록 크기 (512)입니다. 최소값을 지정하면 미리 쓰기가 발생하지 않습니다. 최대 값은 innodb_page_size 값과 같습니다. # innodb_log_write_ahead_size에 innodb_page_size 값보다 큰 값을 지정하면 innodb_log_write_ahead_size 설정이 innodb_page_size 값으로 잘립니다.
#
# 운영 체제 또는 파일 시스템 캐시 블록 크기와 관련하여 innodb_log_write_ahead_size 값을 너무 낮게 설정하면 "read-on-write"가됩니다. 값을 너무 높게 설정하면 여러 블록이 한 번에 기록되므로 로그 파일 쓰기의 fsync 성능에 약간의 영향을 줄 수 # 있습니다.
#
# 관련 정보는 8.5.4 절.“InnoDB Redo 로깅 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_log_write_ahead_size=8192
#
# --------------------------------------------
#
# @ innodb_lru_scan_depth
#
# Property : Value
# Command-Line Format : --innodb-lru-scan-depth=#
# System Variable : innodb_lru_scan_depth
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 1024
# Minimum Value	100
# Maximum Value (64-bit platforms)	2**64-1
# Maximum Value (32-bit platforms)	2**32-1
#
# InnoDB 버퍼 풀의 플러시 조작에 대한 알고리즘 및 휴리스틱에 영향을주는 매개 변수입니다. I / O 집약적 인 워크로드를 튜닝하는 성능 전문가가 주로 관심을 갖습니다.
# 버퍼 풀 인스턴스 당 버퍼 풀 LRU 페이지 목록에서 더티 페이지를 플러시하기 위해 페이지 클리너 스레드가 스캔하는 거리를 지정합니다. 이는 초당 한 번씩 수행되는 백그라운드 작업입니다.
#
# 기본값보다 작은 설정은 일반적으로 대부분의 작업에 적합합니다. 필요한 것보다 훨씬 높은 값은 성능에 영향을 줄 수 있습니다.
# 일반적인 워크로드에서 예비 I / O 용량이있는 경우에만 값을 늘리십시오. 반대로, 쓰기 집약적 인 워크로드가 I / O 용량을 포화시키는 경우 특히 큰 버퍼 풀의 경우 값을 줄이십시오.
#
# innodb_lru_scan_depth를 조정할 때 낮은 값으로 시작하여 사용 가능한 페이지가 거의없는 것을 목표로 설정을 위로 구성하십시오.
# 또한 innodb_lru_scan_depth * innodb_buffer_pool_instances는 초당 페이지 클리너 스레드가 수행하는 작업량을 정의하므로 버퍼 풀 인스턴스 수를 변경할 때 innodb_lru_scan_depth 조정을 고려하십시오.
#
# 관련 정보는 14.8.3.5 절“버퍼 풀 플러시 구성”을 참조하십시오. 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_lru_scan_depth=1024
#
# --------------------------------------------
#
# @ innodb_max_dirty_pages_pct
#
# Property : Value
# Command-Line Format : --innodb-max-dirty-pages-pct=#
# System Variable : innodb_max_dirty_pages_pct
# Scope : Global
# Dynamic	Yes
# Type : Numeric
# Default Value : 75
# Minimum Value	0
# Maximum Value	99.99
#
# InnoDB는 더티 페이지의 백분율이이 값을 초과하지 않도록 버퍼 풀에서 데이터를 플러시하려고합니다. 기본값은 75입니다.
#
# innodb_max_dirty_pages_pct 설정은 플러시 활동의 대상을 설정합니다. 세척 속도에는 영향을 미치지 않습니다. 플러시 비율 관리에 대한 내용은 14.8.3.5 절“버퍼 풀 플러시 구성”을 참조하십시오.
#
# 관련 정보는 14.8.3.5 절“버퍼 풀 플러시 구성”을 참조하십시오. 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_max_dirty_pages_pct=75
#
# --------------------------------------------
#
# @ innodb_max_dirty_pages_pct_lwm
#
# Property : Value
# Command-Line Format : --innodb-max-dirty-pages-pct-lwm=#
# System Variable : innodb_max_dirty_pages_pct_lwm
# Scope : Global
# Dynamic	Yes
# Type : Numeric
# Default Value : 0
# Minimum Value	0
# Maximum Value	99.99
#
# 더티 페이지 비율을 제어하기 위해 프리 플러싱을 사용할 수있는 더티 페이지의 백분율을 나타내는 낮은 워터 마크를 정의합니다. 기본값 0은 사전 플러싱 동작을 완전히 비활성화합니다.
# 자세한 내용은 14.8.3.5 절“버퍼 풀 플러시 구성”을 참조하십시오.
#
# * Apply Option
# innodb_max_dirty_pages_pct_lwm=0
#
# --------------------------------------------
#
# @ innodb_max_purge_lag
#
# Property : Value
# Command-Line Format : --innodb-max-purge-lag=#
# System Variable : innodb_max_purge_lag
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
# Minimum Value	0
# Maximum Value	4294967295
#
# 원하는 최대 퍼지 지연을 정의합니다. 이 값을 초과하면 INSERT, UPDATE 및 DELETE 조작에 지연이 발생하여 제거 시간을 따라 잡을 수 있습니다. 기본값은 0이며, 최대 퍼지 지연이없고 지연이 없음을 의미합니다.
#
# 자세한 내용은 14.8.10 절.“퍼지 구성”을 참조하십시오.
#
# * Apply Option
# innodb_max_purge_lag=0
#
# --------------------------------------------
#
# @ innodb_max_purge_lag_delay
#
# Property : Value
# Command-Line Format : --innodb-max-purge-lag-delay=#
# System Variable : innodb_max_purge_lag_delay
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
# Minimum Value	0
# Maximum Value	10000000
#
# innodb_max_purge_lag 임계 값을 초과 할 때 부과되는 지연에 대한 최대 지연 (마이크로 초)을 지정합니다. 지정된 innodb_max_purge_lag_delay 값은 innodb_max_purge_lag 공식으로 계산 된 지연 기간의 상한입니다.
#
# 자세한 내용은 14.8.10 절.“퍼지 구성”을 참조하십시오.
#
# * Apply Option
# innodb_max_purge_lag_delay=0
#
# --------------------------------------------
#
# @ innodb_max_undo_log_size
#
# Property : Value
# Command-Line Format : --innodb-max-undo-log-size=#
# System Variable : innodb_max_undo_log_size
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 1073741824
# Minimum Value	10485760
# Maximum Value	2**64-1
#
# 실행 취소 테이블 스페이스의 임계 값 크기를 정의합니다. 실행 취소 테이블 공간이 임계 값을 초과하면 innodb_undo_log_truncate가 사용 가능한 경우 잘린 것으로 표시 될 수 있습니다. 기본값은 1073741824 바이트 (1024MiB)입니다.
#
# 자세한 정보는 실행 취소 테이블 스페이스 자르기를 참조하십시오.
#
# * Apply Option
# innodb_max_undo_log_size=1073741824
#
# --------------------------------------------
#
# @ innodb_merge_threshold_set_all_debug
#
# Property : Value
# Command-Line Format : --innodb-merge-threshold-set-all-debug=#
# System Variable : innodb_merge_threshold_set_all_debug
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 50
# Minimum Value	1
# Maximum Value	50
#
# 현재 사전 캐시에있는 모든 색인에 대한 현재 MERGE_THRESHOLD 설정을 대체하는 색인 ​​페이지의 전체 페이지 백분율 값을 정의합니다.
# 이 옵션은 디버깅 지원이 WITH_DEBUG CMake 옵션을 사용하여 컴파일 된 경우에만 사용할 수 있습니다. 관련 정보는 14.8.12 절“색인 페이지의 병합 임계 값 구성”을 참조하십시오.
#
# * Apply Option
# innodb_merge_threshold_set_all_debug=50
#
# --------------------------------------------
#
# @ innodb_monitor_disable
#
# Property : Value
# Command-Line Format : --innodb-monitor-disable={counter|module|pattern|all}
# System Variable : innodb_monitor_disable
# Scope : Global
# Dynamic	Yes
# Type : String
#
# InnoDB 메트릭 카운터를 비활성화합니다. INFORMATION_SCHEMA.INNODB_METRICS 테이블을 사용하여 카운터 데이터를 쿼리 할 수 ​​있습니다.
# 사용법에 대한 정보는 14.16.6 절.“InnoDB INFORMATION_SCHEMA 지표 테이블”에서 참조하십시오.
#
# innodb_monitor_disable = 'latch'는 SHOW ENGINE INNODB MUTEX에 대한 통계 수집을 비활성화합니다. 자세한 내용은 13.7.5.15 절“SHOW ENGINE 문”을 참조하십시오.
#
# * Apply Option
# innodb_monitor_disable=counter|module|pattern|all
#
# --------------------------------------------
#
# @ innodb_monitor_enable
#
# Property : Value
# Command-Line Format : --innodb-monitor-enable={counter|module|pattern|all}
# System Variable : innodb_monitor_enable
# Scope : Global
# Dynamic	Yes
# Type : String
#
# InnoDB 메트릭 카운터를 활성화합니다. INFORMATION_SCHEMA.INNODB_METRICS 테이블을 사용하여 카운터 데이터를 쿼리 할 수 ​​있습니다. 사용법에 대한 정보는 14.16.6 절.“InnoDB INFORMATION_SCHEMA 지표 테이블”에서 참조하십시오.
#
# innodb_monitor_enable = 'latch'는 SHOW ENGINE INNODB MUTEX에 대한 통계 수집을 활성화합니다. 자세한 내용은 13.7.5.15 절“SHOW ENGINE 문”을 참조하십시오.
#
# * Apply Option
# innodb_monitor_enable=counter|module|pattern|all
#
# --------------------------------------------
#
# @ innodb_monitor_reset
#
# Property : Value
# Command-Line Format : --innodb-monitor-reset={counter|module|pattern|all}
# System Variable : innodb_monitor_reset
# Scope : Global
# Dynamic	Yes
# Type : Enumeration
# Default Value : empty string
# Valid Values counter, module, pattern, all
#
# InnoDB 메트릭 카운터의 카운트 값을 0으로 재설정합니다. INFORMATION_SCHEMA.INNODB_METRICS 테이블을 사용하여 카운터 데이터를 쿼리 할 수 ​​있습니다.
# 사용법에 대한 정보는 14.16.6 절.“InnoDB INFORMATION_SCHEMA 지표 테이블”에서 참조하십시오.
#
# innodb_monitor_reset = 'latch'는 SHOW ENGINE INNODB MUTEX가보고 한 통계를 재설정합니다. 자세한 내용은 13.7.5.15 절“SHOW ENGINE 문”을 참조하십시오.
#
# * Apply Option
# innodb_monitor_reset=empty string
#
# --------------------------------------------
#
# @ innodb_monitor_reset_all
#
# Property : Value
# Command-Line Format : --innodb-monitor-reset-all={counter|module|pattern|all}
# System Variable : innodb_monitor_reset_all
# Scope : Global
# Dynamic	Yes
# Type : Enumeration
# Default Value : empty string
# Valid Values counter, module, pattern, all
#
# InnoDB 메트릭 카운터에 대한 모든 값 (최소, 최대 등)을 재설정합니다. INFORMATION_SCHEMA.INNODB_METRICS 테이블을 사용하여 카운터 데이터를 쿼리 할 수 ​​있습니다.
# 사용법에 대한 정보는 14.16.6 절.“InnoDB INFORMATION_SCHEMA 지표 테이블”에서 참조하십시오.
#
# * Apply Option
# innodb_monitor_reset_all=empty string
#
# --------------------------------------------
#
# @ innodb_numa_interleave
#
# Property : Value
# Command-Line Format : --innodb-numa-interleave[={OFF|ON}]
# System Variable : innodb_numa_interleave
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : OFF
#
# InnoDB 버퍼 풀 할당을 위해 NUMA 인터리브 메모리 정책을 활성화합니다. innodb_numa_interleave가 활성화되면 NUMA 메모리 정책이 mysqld 프로세스에 대해 MPOL_INTERLEAVE로 설정됩니다. InnoDB 버퍼 풀이 할당 된 후 NUMA 메모리 정책은 # MPOL_DEFAULT로 다시 설정됩니다. innodb_numa_interleave 옵션을 사용하려면 MySQL을 NUMA 지원 Linux 시스템에서 컴파일해야합니다.
#
# MySQL 5.7.17부터 CMake는 현재 플랫폼에 NUMA 지원 여부에 따라 기본 WITH_NUMA 값을 설정합니다. 자세한 내용은 2.9.7 절“MySQL 소스 구성 옵션”을 참조하십시오.
#
# * Apply Option
# innodb_numa_interleave=OFF
#
# --------------------------------------------
#
# @ innodb_old_blocks_pct
#
# Property : Value
# Command-Line Format : --innodb-old-blocks-pct=#
# System Variable : innodb_old_blocks_pct
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 37
# Minimum Value	5
# Maximum Value	95
#
# 이전 블록 서브리스트에 사용 된 InnoDB 버퍼 풀의 대략적인 백분율을 지정합니다. 값의 범위는 5-95입니다. 기본값은 37 (풀의 3/8)입니다. 종종 innodb_old_blocks_time과 함께 사용됩니다.
#
# 자세한 내용은 14.8.3.3 절“버퍼 풀 검색 방지”를 참조하십시오. 버퍼 풀 관리, LRU 알고리즘 및 제거 정책에 대한 자세한 내용은 14.5.1 절“버퍼 풀”을 참조하십시오.
#
# * Apply Option
# innodb_old_blocks_pct=37
#
# --------------------------------------------
#
# @ innodb_old_blocks_time
#
# Property : Value
# Command-Line Format : --innodb-old-blocks-time=#
# System Variable : innodb_old_blocks_time
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 1000
# Minimum Value	0
# Maximum Value	2**32-1
#
# 0이 아닌 값은 전체 테이블 스캔과 같이 짧은 기간 동안 만 참조되는 데이터로 채워지는 버퍼 풀로부터 보호합니다. 이 값을 늘리면 버퍼 풀에 캐시 된 데이터를 방해하는 전체 테이블 스캔에 대한 보호 기능이 향상됩니다.
#
# 이전 하위 목록에 삽입 된 블록이 새 하위 목록으로 이동하기 전에 첫 번째 액세스 후 블록에 머무르는 시간을 밀리 초 단위로 지정합니다.
# 값이 0 인 경우 삽입 후 얼마나 빨리 액세스하든 이전 서브리스트에 삽입 된 블록이 처음 액세스 할 때 즉시 새로운 서브리스트로 이동합니다.
# 값이 0보다 크면 첫 번째 액세스 후 액세스가 최소한 몇 밀리 초가 될 때까지 블록이 이전 서브리스트에 남아 있습니다.
# 예를 들어 값이 1000이면 새 액세스 목록으로 이동하기 전에 첫 번째 액세스 후 1 초 동안 블록이 이전 서브리스트에 유지됩니다.
#
# 기본값은 1000입니다.
#
# 이 변수는 종종 innodb_old_blocks_pct와 함께 사용됩니다. 자세한 내용은 14.8.3.3 절“버퍼 풀 검색 방지”를 참조하십시오. 버퍼 풀 관리, LRU 알고리즘 및 제거 정책에 대한 자세한 내용은 14.5.1 절“버퍼 풀”을 참조하십시오.
#
# * Apply Option
# innodb_old_blocks_time=1000
#
# --------------------------------------------
#
# @ innodb_online_alter_log_max_size
#
# Property : Value
# Command-Line Format : --innodb-online-alter-log-max-size=#
# System Variable : innodb_online_alter_log_max_size
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 134217728
# Minimum Value	65536
# Maximum Value	2**64-1
#
# InnoDB 테이블에 대한 온라인 DDL 조작 중에 사용되는 임시 로그 파일의 크기에 대한 상한을 바이트 단위로 지정합니다.
# 작성중인 각 색인 또는 변경되는 테이블마다 하나의 이러한 로그 파일이 있습니다. 이 로그 파일은 DDL 조작 중 테이블에 삽입, 갱신 또는 삭제 된 데이터를 저장합니다.
# 임시 로그 파일은 innodb_sort_buffer_size 값으로 필요할 때 innodb_online_alter_log_max_size에 지정된 최대 값까지 확장됩니다.
# 임시 로그 파일이 상한 크기를 초과하면 ALTER TABLE 작업이 실패하고 커밋되지 않은 모든 동시 DML 작업이 롤백됩니다.
# 따라서이 옵션의 값이 크면 온라인 DDL 조작 중에 더 많은 DML이 발생할 수 있지만, 테이블이 로그의 데이터를 적용하기 위해 잠겨있을 때 DDL 조작 종료시 시간이 연장됩니다.
#
# * Apply Option
# innodb_online_alter_log_max_size=134217728
#
# --------------------------------------------
#
# @ innodb_open_files
#
# Property : Value
# Command-Line Format : --innodb-open-files=#
# System Variable : innodb_open_files
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value	10
# Maximum Value	4294967295
#
# 이 변수는 여러 InnoDB 테이블 스페이스를 사용하는 경우에만 관련이 있습니다. MySQL이 한 번에 열어 둘 수있는 최대 .ibd 파일 수를 지정합니다. 최소값은 10입니다.
# innodb_file_per_table을 사용하지 않으면 기본값은 300이고, 그렇지 않으면 300보다 높습니다.
#
# .ibd 파일에 사용 된 파일 디스크립터는 InnoDB 테이블 전용입니다. 그것들은 open_files_limit 시스템 변수에 의해 지정된 것과 독립적이며, 테이블 캐시의 작동에는 영향을 미치지 않습니다.
# 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_open_files=-1
#
# --------------------------------------------
#
# @ innodb_optimize_fulltext_only
#
# Property : Value
# Command-Line Format : --innodb-optimize-fulltext-only[={OFF|ON}]
# System Variable : innodb_optimize_fulltext_only
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# OPTIMIZE TABLE이 InnoDB 테이블에서 작동하는 방식을 변경합니다. FULLTEXT 인덱스가있는 InnoDB 테이블에 대한 유지 관리 작업 중에 일시적으로 활성화되었습니다.
#
# 기본적으로 OPTIMIZE TABLE은 테이블의 클러스터형 인덱스에서 데이터를 재구성합니다.
# 이 옵션이 활성화되면 OPTIMIZE TABLE은 테이블 데이터의 재구성을 건너 뛰고 대신 InnoDB FULLTEXT 인덱스에 대해 새로 추가, 삭제 및 업데이트 된 토큰 데이터를 처리합니다. 자세한 내용은 InnoDB 전체 텍스트 인덱스 최적화를 참조하십시오.
#
# * Apply Option
# innodb_optimize_fulltext_only=OFF|ON
#
# --------------------------------------------
#
# @ innodb_page_cleaners
#
# Property : Value
# Command-Line Format : --innodb-page-cleaners=#
# System Variable : innodb_page_cleaners
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 4
# Minimum Value	1
# Maximum Value	64
#
# 버퍼 풀 인스턴스에서 더티 페이지를 플러시하는 페이지 클리너 스레드 수입니다. 페이지 클리너 스레드는 플러시 목록 및 LRU 플러시를 수행합니다.
# InnoDB 마스터 스레드에서 버퍼 풀 플러싱 작업을 오프로드하기 위해 MySQL 5.6에 단일 페이지 클리너 스레드가 도입되었습니다. MySQL 5.7에서 InnoDB는 여러 페이지 클리너 스레드를 지원합니다.
# 값이 1이면 단일 페이지 클리너 스레드가있는 MySQL 5.7 이전 구성이 유지됩니다.
# 여러 페이지 클리너 스레드가있는 경우 각 버퍼 풀 인스턴스에 대한 버퍼 풀 플러시 태스크가 유휴 페이지 클리너 스레드로 디스패치됩니다.
# MySQL 5.7에서는 innodb_page_cleaners 기본값이 1에서 4로 변경되었습니다. 페이지 클리너 스레드 수가 버퍼 풀 인스턴스 수를 초과하면 innodb_page_cleaners는 자동으로 innodb_buffer_pool_instances와 동일한 값으로 설정됩니다.
#
# 더티 페이지를 버퍼 풀 인스턴스에서 데이터 파일로 플러시 할 때 워크로드가 쓰기 -IO 바인드되고 시스템 하드웨어에 사용 가능한 용량이있는 경우 페이지 클리너 스레드 수를 늘리면 write-IO 처리량이 향상 될 수 있습니다.
#
# 다중 스레드 페이지 클리너 지원은 MySQL 5.7에서 종료 및 복구 단계로 확장되었습니다.
#
# setpriority () 시스템 호출은 지원되는 Linux 플랫폼 및 mysqld 실행 사용자에게 페이지 플러싱이 현재 작업 부하에 보조를 맞추기 위해 다른 MySQL 및 InnoDB 스레드보다
# page_cleaner 스레드 우선 순위를 부여 할 권한이있는 경우에 사용됩니다. setpriority () 지원은 다음 InnoDB 시작 메시지로 표시됩니다.
# [Note] InnoDB: If the mysqld execution user is authorized, page cleaner
# thread priority can be changed. See the man page of setpriority().
#
# systemd에서 서버 시작 및 종료를 관리하지 않는 시스템의 경우 mysqld 실행 사용자 권한을 /etc/security/limits.conf에서 구성 할 수 있습니다.
# 예를 들어, mysqld가 mysql 사용자로 실행되는 경우 /etc/security/limits.conf에 다음 행을 추가하여 mysql 사용자에게 권한을 부여 할 수 있습니다.
# mysql              hard    nice       -20
# mysql              soft    nice       -20
#
# 시스템 관리 시스템의 경우 지역화 된 시스템 구성 파일에 LimitNICE = -20을 지정하여 동일하게 수행 할 수 있습니다.
# 예를 들어, /etc/systemd/system/mysqld.service.d/override.conf에 override.conf라는 파일을 작성하고 다음 항목을 추가하십시오.
# [Service]
# LimitNICE=-20
#
# override.conf를 만들거나 변경 한 후 systemd 구성을 다시로드 한 다음 systemd에게 MySQL 서비스를 다시 시작하도록 지시하십시오.
# systemctl daemon-reload
# systemctl restart mysqld  # RPM platforms
# systemctl restart mysql   # Debian platforms
#
# 지역화 된 시스템 구성 파일 사용에 대한 자세한 정보는 MySQL 용 systemd 구성을 참조하십시오.
#
# mysqld 실행 사용자에게 권한을 부여한 후 cat 명령을 사용하여 mysqld 프로세스에 대해 구성된 Nice 한계를 확인하십시오.
# shell> cat /proc/mysqld_pid/limits | grep nice
# Max nice priority         18446744073709551596 18446744073709551596
#
# * Apply Option
# innodb_page_cleaners=4
#
# --------------------------------------------
#
# @ innodb_page_size
#
# Property : Value
# Command-Line Format : --innodb-page-size=#
# System Variable : innodb_page_size
# Scope : Global
# Dynamic	No
# Type : Enumeration
# Default Value : 16384
# Valid Values 4096, 8192, 16384, 32768, 65536
#
# InnoDB 테이블 스페이스의 페이지 크기를 지정합니다. 값은 바이트 또는 킬로바이트로 지정할 수 있습니다. 예를 들어 16KB 페이지 크기 값은 16384, 16KB 또는 16k로 지정할 수 있습니다.
#
# innodb_page_size는 MySQL 인스턴스를 초기화하기 전에 만 구성 할 수 있으며 나중에 변경할 수 없습니다. 값을 지정하지 않으면 기본 페이지 크기를 사용하여 인스턴스가 초기화됩니다. 14.8.1 절“InnoDB 시작 구성”을 참조하십시오.
#
# 32KB 및 64KB 페이지 크기에 대한 지원이 MySQL 5.7에 추가되었습니다.
# 32KB 및 64KB 페이지 크기 모두 최대 행 길이는 약 16000 바이트입니다. innodb_page_size가 32KB 또는 64KB로 설정된 경우 ROW_FORMAT = COMPRESSED가 지원되지 않습니다.
# innodb_page_size = 32k의 경우 범위 크기는 2MB입니다. innodb_page_size = 64KB의 경우 익스텐트 크기는 4MB입니다.
# 32KB 또는 64KB 페이지 크기를 사용하는 경우 innodb_log_buffer_size를 16M (기본값) 이상으로 설정해야합니다.
#
# 기본 16KB 페이지 크기 이상은 광범위한 워크로드, 특히 테이블 스캔과 관련된 쿼리 및 대량 업데이트와 관련된 DML 작업에 적합합니다.
# 단일 페이지에 많은 행이있을 때 경합이 문제가 될 수있는 작은 쓰기 작업이 많은 OLTP 워크로드에는 페이지 크기가 작을수록 더 효율적일 수 있습니다.
# 작은 페이지는 일반적으로 작은 블록 크기를 사용하는 SSD 저장 장치에서 효율적일 수 있습니다.
# InnoDB 페이지 크기를 스토리지 장치 블록 크기에 가깝게 유지하면 디스크에 다시 쓰여지는 변경되지 않은 데이터의 양이 최소화됩니다.
#
# 첫 번째 시스템 테이블 스페이스 데이터 파일 (ibdata1)의 최소 파일 크기는 innodb_page_size 값에 따라 다릅니다. 자세한 정보는 innodb_data_file_path 옵션 설명을 참조하십시오.
#
# 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_page_size=16384
#
# --------------------------------------------
#
# @ innodb_print_all_deadlocks
#
# Property : Value
# Command-Line Format : --innodb-print-all-deadlocks[={OFF|ON}]
# System Variable : innodb_print_all_deadlocks
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# 이 옵션을 활성화하면 InnoDB 사용자 트랜잭션의 모든 교착 상태에 대한 정보가 mysqld 오류 로그에 기록됩니다.
# 그렇지 않으면 SHOW ENGINE INNODB STATUS 명령을 사용하여 마지막 교착 상태에 대한 정보 만 표시됩니다.
# InnoDB가 상황을 즉시 감지하고 트랜잭션 중 하나를 자동으로 롤백하기 때문에 가끔 InnoDB 교착 상태가 반드시 문제가되는 것은 아닙니다.
# 응용 프로그램에 롤백을 감지하고 조작을 재 시도 할 적절한 오류 처리 로직이없는 경우 교착 상태가 발생하는 이유를 해결하려면이 옵션을 사용할 수 있습니다.
# 교착 상태가 많으면 여러 테이블에 대해 DML 또는 SELECT ... FOR UPDATE 문을 실행하는 트랜잭션을 재구성해야하므로 각 트랜잭션이 동일한 순서로 테이블에 액세스하여 교착 상태를 피할 수 있습니다.
#
# 관련 정보는 14.7.5 절“InnoDB의 데드락”을 참조하십시오.
#
# * Apply Option
# innodb_print_all_deadlocks=OFF
#
# --------------------------------------------
#
# @ innodb_purge_batch_size
#
# Property : Value
# Command-Line Format : --innodb-purge-batch-size=#
# System Variable : innodb_purge_batch_size
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 300
# Minimum Value	1
# Maximum Value	5000
#
# 히스토리 목록에서 구문 분석 및 처리를 취소하는 실행 취소 로그 페이지 수를 정의합니다.
# 다중 스레드 제거 구성에서 코디네이터 제거 스레드는 innodb_purge_batch_size를 innodb_purge_threads로 나누고 해당 페이지 수를 각 제거 스레드에 할당합니다.
# innodb_purge_batch_size 변수는 실행 취소 로그를 통해 128 회 반복 할 때마다 제거 할 실행 취소 로그 페이지 수를 정의합니다.
#
# innodb_purge_batch_size 옵션은 innodb_purge_threads 설정과 함께 고급 성능 조정을위한 것입니다. 대부분의 사용자는 innodb_purge_batch_size를 기본값에서 변경할 필요가 없습니다.
#
# 관련 정보는 14.8.10 절.“퍼지 구성”을 참조하십시오.
#
# * Apply Option
# innodb_purge_batch_size=300
#
# --------------------------------------------
#
# @ innodb_purge_threads
#
# Property : Value
# Command-Line Format : --innodb-purge-threads=#
# System Variable : innodb_purge_threads
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 4
# Minimum Value	1
# Maximum Value	32
#
# InnoDB 제거 작업에 사용 된 백그라운드 스레드 수입니다. 기본값은 1입니다. 값을 늘리면 추가 제거 스레드가 생성되어 여러 테이블에서 DML 작업이 수행되는 시스템의 효율성이 향상 될 수 있습니다. 최대 값은 32입니다.
#
# 관련 정보는 14.8.10 절.“퍼지 구성”을 참조하십시오.
#
# * Apply Option
# innodb_purge_threads=4
#
# --------------------------------------------
#
# @ innodb_purge_rseg_truncate_frequency
#
# Property : Value
# Command-Line Format : --innodb-purge-rseg-truncate-frequency=#
# System Variable : innodb_purge_rseg_truncate_frequency
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 128
# Minimum Value	1
# Maximum Value	128
#
# 퍼지 시스템이 롤백 세그먼트를 해제하는 빈도를 제거 호출 횟수로 정의합니다. 롤백 세그먼트가 해제 될 때까지 실행 취소 테이블 스페이스를 절단 할 수 없습니다.
# 일반적으로 제거 시스템은 제거가 호출 된 128 회마다 한 번씩 롤백 세그먼트를 해제합니다. 기본값은 128입니다.이 값을 줄이면 퍼지 스레드가 롤백 세그먼트를 해제하는 빈도가 증가합니다.
#
# innodb_purge_rseg_truncate_frequency는 innodb_undo_log_truncate와 함께 사용하기위한 것입니다. 자세한 정보는 실행 취소 테이블 스페이스 자르기를 참조하십시오.
#
# * Apply Option
# innodb_purge_rseg_truncate_frequency=128
#
# --------------------------------------------
#
# @ innodb_random_read_ahead
#
# Property : Value
# Command-Line Format : --innodb-random-read-ahead[={OFF|ON}]
# System Variable : innodb_random_read_ahead
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# InnoDB I / O를 최적화하기 위해 임의 미리 읽기 기술을 활성화합니다.
#
# 다른 유형의 미리 읽기 요청에 대한 성능 고려 사항에 대한 자세한 내용은 14.8.3.4 절“InnoDB 버퍼 풀 프리 페치 구성 (미리 읽기)”을 참조하십시오.
# 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_random_read_ahead=OFF
#
# --------------------------------------------
#
# @ innodb_read_ahead_threshold
#
# Property : Value
# Command-Line Format : --innodb-read-ahead-threshold=#
# System Variable : innodb_read_ahead_threshold
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 56
# Minimum Value	0
# Maximum Value	64
#
# InnoDB가 페이지를 버퍼 풀로 프리 페치하는 데 사용하는 선형 미리 읽기의 감도를 제어합니다.
# InnoDB는 최소한 innodb_read_ahead_threshold 페이지를 익스텐트 (64 페이지)에서 순차적으로 읽는 경우 다음의 전체 익스텐트에 대해 비동기 읽기를 시작합니다.
# 허용되는 값 범위는 0-64입니다. 값 0은 미리 읽기를 비활성화합니다. 기본값이 56 인 경우 InnoDB는 다음 범위에 대해 비동기 읽기를 시작하려면 익스텐트에서 최소 56 페이지를 순차적으로 읽어야합니다.
#
# 미리 읽기 메커니즘을 통해 읽은 페이지 수와 액세스하지 않고 버퍼 풀에서 제거 된 페이지 수를 아는 것은 innodb_read_ahead_threshold 설정을 미세 조정할 때 유용 할 수 있습니다.
# SHOW ENGINE INNODB STATUS 출력은 Innodb_buffer_pool_read_ahead 및 Innodb_buffer_pool_read_ahead_evicted 전역 상태 변수의 카운터 정보를 표시하여 미리 읽기 요청에 의해
# 버퍼 풀로 가져온 페이지 수와 액세스하지 않고 버퍼 풀에서 제거 된 페이지 수를보고합니다. 각기. 상태 변수는 마지막 서버 재시작 이후의 전역 값을보고합니다.
#
# SHOW ENGINE INNODB STATUS는 또한 미리 읽기 페이지를 읽는 속도와 이러한 페이지가 액세스되지 않고 제거되는 속도를 보여줍니다.
# 초당 평균은 SHOW ENGINE INNODB STATUS의 마지막 호출 이후 수집 된 통계를 기반으로하며 SHOW ENGINE INNODB STATUS 출력의 BUFFER POOL AND MEMORY 섹션에 표시됩니다.
#
# 자세한 내용은 14.8.3.4 절“InnoDB 버퍼 풀 프리 페치 구성 (미리 읽기)”을 참조하십시오. 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_read_ahead_threshold=56
#
# --------------------------------------------
#
# @ innodb_read_io_threads
#
# Property : Value
# Command-Line Format : --innodb-read-io-threads=#
# System Variable : innodb_read_io_threads
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 4
# Minimum Value	1
# Maximum Value	64
#
# InnoDB의 읽기 작업을위한 I / O 스레드 수 쓰기 스레드의 상대는 innodb_write_io_threads입니다.
# 자세한 내용은 14.8.6 절“백그라운드 InnoDB I / O 스레드 수 구성”을 참조하십시오. 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# 노트
# Linux 시스템에서 innodb_read_io_threads, innodb_write_io_threads 및 Linux aio-max-nr 설정에 대한 기본 설정으로 여러 MySQL 서버 (일반적으로 12 개 이상)를 실행하면 시스템 제한을 초과 할 수 있습니다.
# 이상적으로는 aio-max-nr 설정을 늘리십시오. 해결 방법으로 MySQL 변수 중 하나 또는 둘 다에 대한 설정을 줄일 수 있습니다.
#
# * Apply Option
# innodb_read_io_threads=4
#
# --------------------------------------------
#
# @ innodb_read_only
#
# Property : Value
# Command-Line Format : --innodb-read-only[={OFF|ON}]
# System Variable : innodb_read_only
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : OFF
#
# InnoDB를 읽기 전용 모드로 시작합니다. 읽기 전용 매체에 데이터베이스 애플리케이션 또는 데이터 세트를 분배합니다.
# 데이터웨어 하우스에서 여러 인스턴스간에 동일한 데이터 디렉토리를 공유 할 수도 있습니다. 자세한 내용은 14.8.2 절“읽기 전용 작업을위한 InnoDB 구성”을 참조하십시오.
#
# * Apply Option
# innodb_read_only=OFF
#
# --------------------------------------------
#
# @ innodb_replication_delay
#
# Property : Value
# Command-Line Format : --innodb-replication-delay=#
# System Variable : innodb_replication_delay
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
# Minimum Value	0
# Maximum Value	4294967295
#
# innodb_thread_concurrency에 도달하면 슬레이브 서버에서 복제 스레드 지연 (밀리 초)입니다.
#
# * Apply Option
# innodb_replication_delay=0
#
# --------------------------------------------
#
# @ innodb_rollback_on_timeout
#
# Property : Value
# Command-Line Format : --innodb-rollback-on-timeout[={OFF|ON}]
# System Variable : innodb_rollback_on_timeout
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : OFF
#
# InnoDB는 기본적으로 트랜잭션 시간 종료시 마지막 명령문 만 롤백합니다. --innodb-rollback-on-timeout이 지정되면 트랜잭션 시간 초과로 인해 InnoDB가 전체 트랜잭션을 중단하고 롤백합니다.
#
# 노트
# 시작 트랜잭션 명령문이 START TRANSACTION 또는 BEGIN 문인 경우 롤백은 해당 명령문을 취소하지 않습니다.
# COMMIT, ROLLBACK 또는 암시 적 커미트를 유발하는 일부 SQL 문이 발생할 때까지 추가 SQL 문이 트랜잭션의 일부가됩니다.
#
# * Apply Option
# innodb_rollback_on_timeout=OFF
#
# --------------------------------------------
#
# @ innodb_rollback_segments
#
# Property : Value
# Command-Line Format : --innodb-rollback-segments=#
# System Variable : innodb_rollback_segments
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 128
# Minimum Value	1
# Maximum Value	128
#
# 실행 취소 레코드를 생성하는 트랜잭션에 InnoDB에서 사용하는 롤백 세그먼트 수를 정의합니다.
# 각 롤백 세그먼트가 지원하는 트랜잭션 수는 InnoDB 페이지 크기와 각 트랜잭션에 할당 된 실행 취소 로그 수에 따라 다릅니다.
# 자세한 내용은 14.6.7 절“실행 취소 로그”를 참조하십시오.
#
# 하나의 롤백 세그먼트는 항상 시스템 테이블 스페이스에 지정되며 32 개의 롤백 세그먼트는 임시 테이블에서 사용하도록 예약되어 있으며 임시 테이블 스페이스 (ibtmp1)에 상주합니다.
# 추가 롤백 세그먼트를 할당하려면 innodb_rollback_segments를 33보다 큰 값으로 설정해야합니다. 별도의 실행 취소 테이블 스페이스를 구성하면 시스템 테이블 스페이스의 롤백 세그먼트가 비활성화됩니다.
#
# innodb_rollback_segments가 32 이하로 설정되면 InnoDB는 하나의 롤백 세그먼트를 시스템 테이블 스페이스에, 32는 임시 테이블 스페이스에 할당합니다.
#
# innodb_rollback_segments가 32보다 큰 값으로 설정되면 InnoDB는 하나의 롤백 세그먼트를 시스템 테이블 스페이스에 할당하고, 32 개의 롤백 세그먼트를 임시 테이블 스페이스에 할당하고,
# 추가 롤백 세그먼트가 있으면 테이블 스페이스를 실행 취소합니다. 실행 취소 테이블 스페이스가 없으면 추가 롤백 세그먼트가 시스템 테이블 스페이스에 지정됩니다.
#
# InnoDB에서 사용하는 롤백 세그먼트 수를 늘리거나 줄일 수 있지만 시스템에 실제로 존재하는 롤백 세그먼트 수는 줄어들지 않습니다.
# 따라서, 낮은 값으로 시작하여 필요하지 않은 롤백 세그먼트 할당을 피하기 위해 점차 증가시킬 수 있습니다. innodb_rollback_segments 기본값 및 최대 값은 128입니다.
#
# 관련 정보는 14.3 절.“InnoDB 멀티 버전 관리”에서 참조하십시오. 별도의 실행 취소 테이블 스페이스 구성에 대한 정보는 14.6.3.4 절.“테이블 스페이스 실행 취소”를 참조하십시오.
#
# * Apply Option
# innodb_rollback_segments=128
#
# --------------------------------------------
#
# @ innodb_saved_page_number_debug
#
# Property : Value
# Command-Line Format : --innodb-saved-page-number-debug=#
# System Variable : innodb_saved_page_number_debug
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
# Maximum Value	2**23-1
#
# 페이지 번호를 저장합니다. innodb_fil_make_page_dirty_debug 옵션을 설정하면 innodb_saved_page_number_debug에서 정의한 페이지가 지저분합니다.
# innodb_saved_page_number_debug 옵션은 WITH_DEBUG CMake 옵션을 사용하여 디버깅 지원이 컴파일 된 경우에만 사용 가능합니다.
#
# * Apply Option
# innodb_saved_page_number_debug=0
#
# --------------------------------------------
#
# @ innodb_sort_buffer_size
#
# Property : Value
# Command-Line Format : --innodb-sort-buffer-size=#
# System Variable : innodb_sort_buffer_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 1048576
# Minimum Value	65536
# Maximum Value	67108864
#
#
# InnoDB 인덱스를 생성하는 동안 데이터를 정렬하는 데 사용되는 정렬 버퍼의 크기를 지정합니다. 지정된 크기는 내부 정렬을 위해 메모리로 읽은 다음 디스크에 기록되는 데이터의 양을 정의합니다. 이 프로세스를 "실행"이라고합니다.
# 병합 단계 동안 지정된 크기의 버퍼 쌍을 읽고 병합합니다. 설정이 클수록 실행 및 병합 수가 줄어 듭니다.
#
# 이 정렬 영역은 인덱스 생성 중 병합 정렬에만 사용되며 이후의 인덱스 유지 관리 작업에는 사용되지 않습니다. 인덱스 생성이 완료되면 버퍼 할당이 해제됩니다.
#
# 이 옵션의 값은 또한 온라인 DDL 조작 중에 동시 DML을 기록하기 위해 임시 로그 파일이 확장되는 양을 제어합니다.
#
# 이 설정을 구성하기 전에 크기는 1048576 바이트 (1MB)로 하드 코딩되어 기본값으로 유지됩니다.
#
# 인덱스를 작성하는 ALTER TABLE 또는 CREATE TABLE 문 중에 각각이 옵션으로 정의 된 크기를 가진 3 개의 버퍼가 할당됩니다.
# 또한 보조 포인터는 정렬 버퍼의 행에 할당되므로 정렬 작업 중에 행을 이동하는 것과 반대로 포인터에서 정렬을 실행할 수 있습니다.
#
# 일반적인 정렬 작업의 경우 다음과 같은 수식을 사용하여 메모리 소비를 추정 할 수 있습니다.
# (6 /*FTS_NUM_AUX_INDEX*/ * (3*@@GLOBAL.innodb_sort_buffer_size)
# + 2 * number_of_partitions * number_of_secondary_indexes_created
# * (@@GLOBAL.innodb_sort_buffer_size/dict_index_get_min_size(index)*/)
# * 8 /*64-bit sizeof *buf->tuples*/")
#
# @@GLOBAL.innodb_sort_buffer_size/dict_index_get_min_size(index)는 보유 된 최대 튜플을 나타냅니다.
# 2 * ((@@GLOBAL.innodb_sort_buffer_size/*dict_index_get_min_size(index)*/) * 8 /*64-bit size of *buf->tuples*/는 할당 된 보조 포인터를 나타냅니다.
#
# 노트
# 32 비트의 경우 8 대신 4를 곱하십시오.
#
# 전체 텍스트 인덱스에 대한 병렬 정렬의 경우 innodb_ft_sort_pll_degree 설정을 곱하십시오.
# (6 /*FTS_NUM_AUX_INDEX*/ * @@GLOBAL.innodb_ft_sort_pll_degree)
#
# * Apply Option
# innodb_sort_buffer_size=1048576
#
# --------------------------------------------
#
# @ innodb_spin_wait_delay
#
# Property : Value
# Command-Line Format : --innodb-spin-wait-delay=#
# System Variable : innodb_spin_wait_delay
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 6
# Minimum Value	0
# Maximum Value (64-bit platforms)	2**64-1
# Maximum Value (32-bit platforms)	2**32-1
#
# 스핀 잠금에 대한 폴링 사이의 최대 지연. 이 메커니즘의 저수준 구현은 하드웨어와 운영 체제의 조합에 따라 달라 지므로 지연은 고정 된 시간 간격에 해당하지 않습니다. 자세한 내용은 14.8.9 절“스핀 잠금 폴링 구성”을 참조하십시오.
#
# * Apply Option
# innodb_spin_wait_delay=6
#
# --------------------------------------------
#
# @ innodb_stats_auto_recalc
#
# Property : Value
# Command-Line Format : --innodb-stats-auto-recalc[={OFF|ON}]
# System Variable : innodb_stats_auto_recalc
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# 테이블의 데이터가 크게 변경된 후 InnoDB가 지속적 통계를 자동으로 다시 계산하도록합니다. 임계 값은 테이블에있는 행의 10 %입니다.
# 이 설정은 innodb_stats_persistent 옵션이 활성화 된 경우 생성 된 테이블에 적용됩니다. CREATE TABLE 또는 ALTER TABLE 문에서 STATS_PERSISTENT = 1을 지정하여 자동 통계 재 계산을 구성 할 수도 있습니다.
# 통계를 생성하기 위해 샘플링 된 데이터의 양은 innodb_stats_persistent_sample_pages 변수에 의해 제어됩니다.
#
# 자세한 내용은 14.8.11.1 절.“Persistent Optimizer Statistics 매개 변수 구성”을 참조하십시오.
#
# * Apply Option
# innodb_stats_auto_recalc=ON
#
# --------------------------------------------
#
# @ innodb_stats_include_delete_marked
#
# Property : Value
# Command-Line Format : --innodb-stats-include-delete-marked[={OFF|ON}]
# Introduced	5.7.17
# System Variable : innodb_stats_include_delete_marked
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# 기본적으로 InnoDB는 통계를 계산할 때 커밋되지 않은 데이터를 읽습니다.
# 테이블에서 행을 삭제하는 커밋되지 않은 트랜잭션의 경우 InnoDB는 행 추정값 및 인덱스 통계를 계산할 때 삭제 표시되는 레코드를 제외하므로 테이블에서
# 동시에 작동하는 다른 트랜잭션에 대해 최적이 아닌 실행 계획이 발생할 수 있습니다.
# COMM UNCOMMITTED 이외의 트랜잭션 격리 수준 이 시나리오를 피하기 위해 지속적인 최적화 알고리즘 통계를 계산할 때 InnoDB에 삭제 표시 레코드가 포함되도록 innodb_stats_include_delete_marked를 활성화 할 수 있습니다.
#
# innodb_stats_include_delete_marked가 활성화되면 ANALYZE TABLE은 통계를 다시 계산할 때 삭제 표시 레코드를 고려합니다.
#
# innodb_stats_include_delete_marked는 모든 InnoDB 테이블에 영향을주는 전역 설정입니다. 지속적 옵티 마이저 통계에만 적용됩니다.
#
# 관련 정보는 14.8.11.1 절.“Persistent Optimizer Statistics 매개 변수 구성”에서 참조하십시오.
#
# * Apply Option
# innodb_stats_include_delete_marked=OFF
#
# --------------------------------------------
#
# @ innodb_stats_method
#
# Property : Value
# Command-Line Format : --innodb-stats-method=value
# System Variable : innodb_stats_method
# Scope : Global
# Dynamic	Yes
# Type : Enumeration
# Default Value : nulls_equal
# Valid Values nulls_equal, nulls_unequal, nulls_ignored
#
# InnoDB 테이블의 인덱스 값 분배에 대한 통계를 수집 할 때 서버가 NULL 값을 처리하는 방법 허용되는 값은 nulls_equal, nulls_unequal 및 nulls_ignored입니다.
# nulls_equal의 경우 모든 NULL 인덱스 값은 동일한 것으로 간주되며 NULL 값 수와 동일한 크기의 단일 값 그룹을 형성합니다.
# nulls_unequal의 경우 NULL 값은 동일하지 않은 것으로 간주되며 각 NULL은 크기 1의 고유 한 값 그룹을 형성합니다. nulls_ignored의 경우 NULL 값은 무시됩니다.
#
# 테이블 통계를 생성하는 데 사용되는 방법은 8.3.7 절“InnoDB 및 MyISAM 인덱스 통계 수집”에 설명 된대로 옵티마이 저가 쿼리 실행을위한 인덱스를 선택하는 방법에 영향을줍니다.
#
# * Apply Option
# innodb_stats_method=nulls_equal
#
# --------------------------------------------
#
# @ innodb_stats_on_metadata
#
# Property : Value
# Command-Line Format : --innodb-stats-on-metadata[={OFF|ON}]
# System Variable : innodb_stats_on_metadata
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# 이 옵션은 옵티 마이저 통계가 비 지속성으로 구성된 경우에만 적용됩니다.
# innodb_stats_persistent가 사용 불가능하거나 STATS_PERSISTENT = 0으로 개별 테이블이 작성되거나 변경 될 때 옵티 마이저 통계는 디스크에 유지되지 않습니다.
# 자세한 내용은 14.8.11.2 절.“비 영구 옵티 마이저 통계 매개 변수 구성”을 참조하십시오.
#
# innodb_stats_on_metadata를 활성화하면 SHOW TABLE STATUS와 같은 메타 데이터 문이나 INFORMATION_SCHEMA.TABLES 또는 INFORMATION_SCHEMA.STATISTICS 테이블에 액세스 할 때 InnoDB가 비 지속적 통계를 업데이트합니다.
# (이 업데이트는 ANALYZE TABLE의 경우와 유사합니다.) 비활성화하면 InnoDB는 이러한 작업 중에 통계를 업데이트하지 않습니다.
# 설정을 사용하지 않으면 테이블 또는 인덱스가 많은 스키마의 액세스 속도가 향상 될 수 있습니다. 또한 InnoDB 테이블과 관련된 쿼리에 대한 실행 계획의 안정성을 향상시킬 수 있습니다.
#
# 설정을 변경하려면 SET GLOBAL innodb_stats_on_metadata = mode 문을 실행하십시오.
# 여기서 mode는 ON 또는 OFF (또는 1 또는 0)입니다. 설정을 변경하면 전역 시스템 변수를 설정하기에 충분한 권한 (5.1.8.1 절“시스템 변수 권한”참조)이 필요하며 모든 연결 작업에 즉시 영향을 미칩니다.
#
# * Apply Option
# innodb_stats_on_metadata=OFF
#
# --------------------------------------------
#
# @ innodb_stats_persistent
#
# Property : Value
# Command-Line Format : --innodb-stats-persistent[={OFF|ON}]
# System Variable : innodb_stats_persistent
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# InnoDB 인덱스 통계가 디스크에 유지되는지 여부를 지정합니다. 그렇지 않으면 통계가 자주 다시 계산되어 쿼리 실행 계획이 달라질 수 있습니다.
# 이 설정은 테이블을 만들 때 각 테이블과 함께 저장됩니다.
# 테이블을 작성하기 전에 글로벌 레벨에서 innodb_stats_persistent를 설정하거나 CREATE TABLE 및 ALTER TABLE 문의 STATS_PERSISTENT 절을 사용하여 시스템 전체 설정을 대체하고 개별 테이블에 대한 지속적 통계를 구성 할 수 있습니다.
#
# 자세한 내용은 14.8.11.1 절.“Persistent Optimizer Statistics 매개 변수 구성”을 참조하십시오.
#
# * Apply Option
# innodb_stats_persistent=ON
#
# --------------------------------------------
#
# @ innodb_stats_persistent_sample_pages
#
# Property : Value
# Command-Line Format : --innodb-stats-persistent-sample-pages=#
# System Variable : innodb_stats_persistent_sample_pages
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 20
#
# ANALYZE TABLE에 의해 계산 된 것과 같이 인덱스 된 열에 대한 카디널리티 및 기타 통계를 추정 할 때 샘플링 할 인덱스 페이지 수입니다.
# 값을 늘리면 InnoDB 테이블에 대해 ANALYZE TABLE을 실행하는 동안 I/O가 증가하는 대신 인덱스 통계의 정확도가 향상되어 쿼리 실행 계획이 향상 될 수 있습니다.
# 자세한 내용은 14.8.11.1 절.“Persistent Optimizer Statistics 매개 변수 구성”을 참조하십시오.
#
# 노트
# innodb_stats_persistent_sample_pages에 높은 값을 설정하면 ANALYZE TABLE 실행 시간이 길어질 수 있습니다.
# ANALYZE TABLE이 액세스하는 데이터베이스 페이지 수를 추정하려면 14.8.11.3 절“InnoDB 테이블의 ANALYZE TABLE 복잡성 추정”을 참조하십시오.
#
# innodb_stats_persistent_sample_pages는 테이블에 대해 innodb_stats_persistent가 활성화 된 경우에만 적용됩니다.
# innodb_stats_persistent가 비활성화되면 innodb_stats_transient_sample_pages가 대신 적용됩니다.
#
# * Apply Option
# innodb_stats_persistent_sample_pages=20
#
# --------------------------------------------
# 
# @ innodb_stats_sample_pages
# 
# Command-Line Format	--innodb-stats-sample-pages=#
# Deprecated	Yes
# System Variable	innodb_stats_sample_pages
# Scope	Global
# Dynamic	Yes
# Type	Integer
# Default Value	8
# Minimum Value	1
# Maximum Value	2**64-1
# 
# 더 이상 사용되지 않습니다. 대신 innodb_stats_transient_sample_pages를 사용하십시오.
# 
# * Apply Option
# innodb_stats_sample_pages=8
# 
# --------------------------------------------
#
# @ innodb_stats_transient_sample_pages
#
# Property : Value
# Command-Line Format : --innodb-stats-transient-sample-pages=#
# System Variable : innodb_stats_transient_sample_pages
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 8
#
# ANALYZE TABLE에 의해 계산 된 것과 같이 인덱스 된 열에 대한 카디널리티 및 기타 통계를 추정 할 때 샘플링 할 인덱스 페이지 수입니다. 기본값은 8입니다.
# 값을 늘리면 InnoDB 테이블을 열거 나 통계를 다시 계산할 때 I / O가 증가하는 대신 인덱스 통계의 정확도가 향상되어 쿼리 실행 계획이 향상 될 수 있습니다.
# 자세한 내용은 14.8.11.2 절.“비 영구 옵티 마이저 통계 매개 변수 구성”을 참조하십시오.
#
# 노트
# innodb_stats_transient_sample_pages에 높은 값을 설정하면 ANALYZE TABLE 실행 시간이 길어질 수 있습니다.
# ANALYZE TABLE이 액세스하는 데이터베이스 페이지 수를 추정하려면 14.8.11.3 절“InnoDB 테이블의 ANALYZE TABLE 복잡성 추정”을 참조하십시오.
#
# innodb_stats_transient_sample_pages는 테이블에 대해 innodb_stats_persistent가 비활성화 된 경우에만 적용됩니다.
# innodb_stats_persistent가 활성화되면 innodb_stats_persistent_sample_pages가 대신 적용됩니다. innodb_stats_sample_pages를 대신합니다. 자세한 내용은 14.8.11.2 절.“비 영구 옵티 마이저 통계 매개 변수 구성”을 참조하십시오.
#
# * Apply Option
# @ innodb_stats_transient_sample_pages=0
#
# --------------------------------------------
#
# @ innodb_status_output
#
# Property : Value
# Command-Line Format : --innodb-status-output[={OFF|ON}]
# System Variable : innodb_status_output
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# 표준 InnoDB 모니터에 대한 주기적 출력을 활성화 또는 비활성화합니다.
# InnoDB Lock Monitor의 주기적 출력을 활성화 또는 비활성화하기 위해 innodb_status_output_locks와 함께 사용됩니다.
# 자세한 내용은 14.18.2 절“InnoDB 모니터 활성화”를 참조하십시오.
#
# * Apply Option
# innodb_status_output=OFF
#
# --------------------------------------------
#
# @ innodb_status_output_locks
#
# Property : Value
# Command-Line Format : --innodb-status-output-locks[={OFF|ON}]
# System Variable : innodb_status_output_locks
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# InnoDB 잠금 모니터를 활성화 또는 비활성화합니다. 활성화되면 InnoDB 잠금 모니터는 SHOW ENGINE INNODB STATUS 출력 및 MySQL 오류 로그에 주기적으로 출력되는 잠금에 대한 추가 정보를 인쇄합니다.
# InnoDB 잠금 모니터의 주기적 출력은 표준 InnoDB 모니터 출력의 일부로 인쇄됩니다. 따라서 InnoDB 잠금 모니터가 정기적으로 MySQL 오류 로그에 데이터를 인쇄하려면 표준 InnoDB 모니터를 활성화해야합니다.
# 자세한 내용은 14.18.2 절“InnoDB 모니터 활성화”를 참조하십시오.
#
# * Apply Option
# innodb_status_output_locks=OFF
#
# --------------------------------------------
#
# @ innodb_strict_mode
#
# Property : Value
# Command-Line Format : --innodb-strict-mode[={OFF|ON}]
# System Variable : innodb_strict_mode
# Scope : Global, Session
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# innodb_strict_mode가 활성화되면 InnoDB는 특정 조건에 대한 경고가 아닌 오류를 반환합니다.
#
# 엄격 모드는 SQL에서 무시 된 오타 및 구문 오류 또는 다양한 작동 모드 및 SQL 문 조합의 의도하지 않은 기타 결과로부터 보호합니다.
# innodb_strict_mode가 활성화되면 InnoDB는 경고를 발행하고 지정된 명령문 (아마도 의도하지 않은 동작으로)을 처리하는 대신 오류 조건을 발생시킵니다.
# 이것은 MySQL의 sql_mode와 유사합니다.이 구문은 MySQL이 허용하는 SQL 구문을 제어하고 자동으로 오류를 무시할지 또는 입력 구문과 데이터 값의 유효성을 검사하는지 결정합니다.
#
# innodb_strict_mode 설정은 CREATE TABLE, ALTER TABLE, CREATE INDEX 및 OPTIMIZE TABLE 문의 구문 오류 처리에 영향을줍니다.
# innodb_strict_mode는 레코드 크기 검사도 가능하므로 선택한 페이지 크기에 비해 레코드가 너무 커서 INSERT 또는 UPDATE가 실패하지 않습니다.
#
# CREATE TABLE, ALTER TABLE 및 CREATE INDEX 문에서 ROW_FORMAT 및 KEY_BLOCK_SIZE 절을 사용할 때는 innodb_strict_mode를 활성화하는 것이 좋습니다.
# innodb_strict_mode가 비활성화되면 InnoDB는 충돌하는 절을 무시하고 메시지 로그에 경고만으로 테이블 또는 인덱스를 만듭니다.
# 결과 테이블은 압축 테이블 작성시 압축 지원 부족과 같이 의도 한 것과 다른 특성을 가질 수 있습니다. innodb_strict_mode가 활성화되면 이러한 문제로 인해 즉시 오류가 발생하고 테이블 또는 인덱스가 생성되지 않습니다.
#
# mysqld를 시작할 때 또는 MySQL 구성 파일에서 innodb_strict_mode를 활성화 또는 비활성화 할 수 있습니다.
# SET [GLOBAL | SESSION] innodb_strict_mode = mode 문을 사용하여 런타임시 innodb_strict_mode를 활성화 또는 비활성화 할 수 있습니다.
# 여기서 mode는 ON 또는 OFF입니다. GLOBAL 설정을 변경하려면 전역 시스템 변수를 설정하기에 충분한 권한이 필요하며 (5.1.8.1 절.“시스템 변수 권한”참조) 이후에 연결되는 모든 클라이언트의 작동에 영향을 미칩니다.
# 모든 클라이언트는 innodb_strict_mode에 대한 SESSION 설정을 변경할 수 있으며 설정은 해당 클라이언트에만 영향을줍니다.
#
# innodb_strict_mode는 일반 테이블 스페이스에는 적용되지 않습니다. 일반 테이블 스페이스에 대한 테이블 스페이스 관리 규칙은 innodb_strict_mode와 독립적으로 엄격하게 적용됩니다.
# 자세한 내용은 13.1.19 절“CREATE TABLESPACE 문”을 참조하십시오.
#
# * Apply Option
# innodb_strict_mode=ON
#
# --------------------------------------------
#
# @ innodb_support_xa
#
# Property : Value
# Command-Line Format : --innodb-support-xa[={OFF|ON}]
# Deprecated	5.7.10
# System Variable : innodb_support_xa
# Scope : Global, Session
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# XA 트랜잭션에서 2 단계 커밋에 대한 InnoDB 지원을 활성화하여 트랜잭션 준비를위한 추가 디스크 플러시를 발생시킵니다.
# XA 메커니즘은 내부적으로 사용되며 2 진 로그가 켜져 있고 둘 이상의 스레드에서 데이터 변경 사항을 승인하는 모든 서버에 필수적입니다.
# innodb_support_xa를 비활성화하면 라이브 데이터베이스에서 커밋하는 것과 다른 순서로 이진 로그에 트랜잭션을 기록 할 수 있습니다.
# 이로 인해 재해 복구 또는 복제 슬레이브에서 이진 로그를 재생할 때 다른 데이터가 생성 될 수 있습니다.
# 하나의 스레드 만 데이터를 변경할 수있는 비정상적인 설정이없는 경우 복제 마스터 서버에서 innodb_support_xa를 비활성화하지 마십시오.
#
# innodb_support_xa는 더 이상 사용되지 않으며 향후 MySQL 릴리스에서 제거 될 예정입니다.
# XA 트랜잭션에서 2 단계 커밋에 대한 InnoDB 지원은 항상 MySQL 5.7.10부터 활성화됩니다.
# innodb_support_xa를 비활성화하면 복제를 안전하지 않게하고 이진 로그 그룹 커밋과 관련된 성능 향상을 방지하므로 더 이상 허용되지 않습니다.
#
# * Apply Option
# innodb_support_xa=ON
#
# --------------------------------------------
#
# @ innodb_sync_array_size
#
# Property : Value
# Command-Line Format : --innodb-sync-array-size=#
# System Variable : innodb_sync_array_size
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 1
# Minimum Value	1
# Maximum Value	1024
#
# 뮤텍스 / 잠금 대기 배열의 크기를 정의합니다. 값이 증가하면 스레드를 조정하는 데 사용되는 내부 데이터 구조가 분할되어 대기 스레드 수가 많은 워크로드에서 동시성이 향상됩니다.
# 이 설정은 MySQL 인스턴스가 시작될 때 구성되어야하며 나중에 변경할 수 없습니다. 일반적으로 768보다 많은 대기 스레드를 자주 생성하는 워크로드에는이 값을 높이는 것이 좋습니다.
#
# * Apply Option
# innodb_sync_array_size=1
#
# --------------------------------------------
#
# @ c
#
# Property : Value
# Command-Line Format : --innodb-sync-spin-loops=#
# System Variable : innodb_sync_spin_loops
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 30
# Minimum Value	0
# Maximum Value	4294967295
#
# 스레드가 일시 중단되기 전에 스레드가 InnoDB 뮤텍스가 해제되기를 기다리는 횟수입니다.
#
# * Apply Option
# innodb_sync_spin_loops=30
#
# --------------------------------------------
#
# @ innodb_sync_debug
#
# Property : Value
# Command-Line Format : --innodb-sync-debug[={OFF|ON}]
# System Variable : innodb_sync_debug
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : OFF
#
# InnoDB 스토리지 엔진에 대한 동기화 디버그 검사를 활성화합니다. 이 옵션은 디버깅 지원이 WITH_DEBUG CMake 옵션을 사용하여 컴파일 된 경우에만 사용할 수 있습니다.
#
# 이전에는 InnoDB 동기화 디버그 검사를 활성화하려면 ENABLE_DEBUG_SYNC CMake 옵션을 사용하여 디버그 동기화 기능을 활성화해야했습니다. 이 요구 사항은이 변수의 도입으로 MySQL 5.7에서 제거되었습니다.
#
# * Apply Option
# innodb_sync_debug=OFF
#
# --------------------------------------------
#
# @ innodb_table_locks
#
# Property : Value
# Command-Line Format : --innodb-table-locks[={OFF|ON}]
# System Variable : innodb_table_locks
# Scope : Global, Session
# Dynamic	Yes
# Type : Boolean
# Default Value : ON
#
# autocommit = 0이면 InnoDB는 LOCK TABLES를 따릅니다. 다른 모든 스레드가 테이블에 대한 모든 잠금을 해제 할 때까지 MySQL은 LOCK TABLES ... WRITE에서 반환되지 않습니다.
# innodb_table_locks의 기본값은 1이며, 이는 autocommit = 0 인 경우 LOCK TABLES로 인해 InnoDB가 내부적으로 테이블을 잠 그게됩니다.
#
# innodb_table_locks = 0은 LOCK TABLES ... WRITE로 명시 적으로 잠긴 테이블에는 영향을 미치지 않습니다.
# LOCK TABLES ... WRITE에 의해 암시 적으로 (예 : 트리거를 통해) 또는 LOCK TABLES ... READ에 의해 읽기 또는 쓰기를 위해 잠긴 테이블에 영향을줍니다.
#
# 관련 정보는 14.7 절“InnoDB 잠금 및 트랜잭션 모델”을 참조하십시오.
#
# * Apply Option
# innodb_table_locks=ON
#
# --------------------------------------------
#
# @ innodb_temp_data_file_path
#
# Property : Value
# Command-Line Format : --innodb-temp-data-file-path=file_name
# System Variable : innodb_temp_data_file_path
# Scope : Global
# Dynamic	No
# Type : String
# Default Value : ibtmp1:12M:autoextend
#
# InnoDB 임시 테이블 스페이스 데이터 파일의 상대 경로, 이름, 크기 및 속성을 정의합니다.
# innodb_temp_data_file_path에 값을 지정하지 않으면 기본 동작은 MySQL 데이터 디렉토리에 ibtmp1이라는 단일 자동 확장 데이터 파일을 만드는 것입니다. 초기 파일 크기는 12MB보다 약간 큽니다.
#
# 임시 테이블 스페이스 데이터 파일 스펙의 전체 구문에는 파일 이름, 파일 크기 및 자동 확장 및 최대 속성이 포함됩니다.
# file_name:file_size[:autoextend[:max:max_file_size]]
#
# 임시 테이블 스페이스 데이터 파일은 다른 InnoDB 데이터 파일과 동일한 이름을 가질 수 없습니다.
# 임시 테이블 스페이스 데이터 파일을 작성하는 데 실패하거나 오류가 발생하면 치명적인 것으로 간주되어 서버 시작이 거부됩니다.
# 임시 테이블 스페이스에는 동적으로 생성 된 스페이스 ID가 있으며 각 서버를 다시 시작할 때마다 변경할 수 있습니다.
#
# 파일 크기는 K, M 또는 G를 크기 값에 추가하여 KB, MB 또는 GB (1024MB)로 지정됩니다. 파일 크기의 합은 12MB보다 약간 커야합니다.
#
# 개별 파일의 크기 제한은 운영 체제에 따라 결정됩니다. 큰 파일을 지원하는 운영 체제에서 파일 크기를 4GB 이상으로 설정할 수 있습니다.
# 임시 테이블 스페이스 데이터 파일에 원시 디스크 파티션을 사용할 수 없습니다.
#
# autoextend 및 max 속성은 innodb_temp_data_file_path 설정에서 마지막에 지정된 데이터 파일에 대해서만 사용할 수 있습니다. 예를 들면 다음과 같습니다.
# [mysqld]
# innodb_temp_data_file_path=ibtmp1:50M;ibtmp2:12M:autoextend:max:500MB
# 자동 확장 옵션을 지정하면 InnoDB는 여유 공간이 부족한 경우 데이터 파일을 확장합니다. 자동 확장 증분은 기본적으로 64MB입니다. 증분을 수정하려면 innodb_autoextend_increment 시스템 변수를 변경하십시오.
#
# 임시 테이블 스페이스 데이터 파일의 전체 디렉토리 경로는 innodb_data_home_dir 및 innodb_temp_data_file_path에 의해 정의 된 경로를 연결하여 구성됩니다.
#
# 임시 테이블 스페이스는 압축되지 않은 모든 InnoDB 임시 테이블과 공유됩니다. 압축 임시 테이블은 tmpdir 구성 옵션으로 정의 된 임시 파일 디렉토리에 작성된 테이블 당 파일 공간 테이블 파일에 있습니다.
#
# InnoDB를 읽기 전용 모드로 실행하기 전에 innodb_temp_data_file_path를 데이터 디렉토리 외부의 위치로 설정하십시오. 경로는 데이터 디렉토리에 상대적이어야합니다. 예를 들면 다음과 같습니다.
# --innodb-temp-data-file-path=../../../tmp/ibtmp1:12M:autoextend
# 활성 InnoDB 임시 테이블에 대한 메타 데이터는 INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO에 있습니다.
#
# 관련 정보는 14.6.3.5 절“임시 테이블 스페이스”를 참조하십시오.
#
# * Apply Option
# innodb_temp_data_file_path=ibtmp1:12M:autoextend
#
# --------------------------------------------
#
# @ innodb_thread_concurrency
#
# Property : Value
# Command-Line Format : --innodb-thread-concurrency=#
# System Variable : innodb_thread_concurrency
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
# Minimum Value	0
# Maximum Value	1000
#
# InnoDB는 InnoDB 내부에서 동시에 운영 체제 스레드 수를이 변수가 제공 한 한도 이하로 유지하려고 시도합니다 (InnoDB는 운영 체제 스레드를 사용하여 사용자 트랜잭션 처리). 스레드 수가이 제한에 도달하면 추가 스레드는 "FIFO (First In, First Out)# "대기열 내에서 대기 상태가되어 실행됩니다. 잠금을 대기중인 스레드는 동시에 실행중인 스레드 수에 포함되지 않습니다.
#
# 이 변수의 범위는 0-1000입니다. 값 0 (기본값)은 무한 동시성 (동시성 검사 없음)으로 해석됩니다. 스레드 동시성 검사를 비활성화하면 InnoDB가 필요한 수의 스레드를 만들 수 있습니다. 값이 0이면 SHOW ENGINE INNODB STATUS 출력의 ROW OPERATIONS # 섹션에있는 InnoDB 내부 쿼리와 대기열 카운터 쿼리가 비활성화됩니다.
#
# MySQL 인스턴스가 다른 응용 프로그램과 CPU 리소스를 공유하거나 작업 부하 또는 동시 사용자 수가 증가하는 경우이 변수를 설정하십시오. 올바른 설정은 워크로드, 컴퓨팅 환경 및 실행중인 MySQL 버전에 따라 다릅니다. 최상의 성능을 제공하는 설정을 # 결정하려면 값 범위를 테스트해야합니다. innodb_thread_concurrency는 동적 변수이므로 라이브 테스트 시스템에서 다른 설정을 실험 할 수 있습니다. 특정 설정이 제대로 수행되지 않으면 innodb_thread_concurrency를 다시 0으로 빠르게 설정할 수 # 있습니다.
#
# 다음 지침을 사용하여 적절한 설정을 찾고 유지하십시오.
# + 워크로드에 대한 동시 사용자 스레드 수가 64 미만인 경우 innodb_thread_concurrency = 0을 설정하십시오.
# + 워크로드가 지속적으로 무겁거나 간헐적으로 급증하는 경우 innodb_thread_concurrency = 128을 설정 한 다음 최상의 성능을 제공하는 스레드 수를 찾을 때까지 값을 96, 80, 64 등으로 낮추십시오.
# 일반적으로 시스템에 40-50 명의 사용자가 있지만 주기적으로 60, 70 또는 200으로 증가한다고 가정하십시오.
# 80 명의 동시 사용자에서 성능은 안정적이지만이 숫자보다 높은 회귀를 보이기 시작합니다. 이 경우 성능에 영향을 미치지 않도록 innodb_thread_concurrency = 80을 설정합니다.
# + InnoDB가 사용자 스레드에 특정 개수 이상의 가상 CPU를 사용하지 못하게하려면 (예 : 20 개의 가상 CPU) innodb_thread_concurrency를이 수로 설정하십시오 (성능 결과에 따라 더 낮음).
# 다른 응용 프로그램에서 MySQL을 격리하는 것이 목표라면 mysqld 프로세스를 가상 CPU에만 독점적으로 바인딩하는 것을 고려할 수 있습니다.
# 그러나 mysqld 프로세스가 지속적으로 사용 중이 아닌 경우 독점 바인딩으로 인해 하드웨어 사용이 최적화되지 않을 수 있습니다.
# 이 경우 mysqld 프로세스를 가상 CPU에 바인딩 할 수 있지만 다른 응용 프로그램이 가상 CPU의 일부 또는 전부를 사용할 수 있습니다.
#
# 노트
# 운영 체제 관점에서, 리소스 관리 솔루션을 사용하여 애플리케이션간에 CPU 시간을 공유하는 방법을 관리하는 것이 mysqld 프로세스를 바인딩하는 것보다 좋습니다.
# 예를 들어, 다른 중요 프로세스가 실행되고 있지 않은 동안 지정된 애플리케이션에 가상 CPU 시간의 90 %를 할당하고 다른 중요 프로세스가 실행 중일 때 해당 값을 40 %로 다시 스케일 할 수 있습니다.
#
# + innodb_thread_concurrency 값이 너무 높으면 시스템 내부 및 자원에 대한 경합이 증가하여 성능이 저하 될 수 있습니다.
# + 경우에 따라 최적의 innodb_thread_concurrency 설정은 가상 CPU 수보다 작을 수 있습니다.
# + 시스템을 정기적으로 모니터링하고 분석하십시오. 워크로드, 사용자 수 또는 컴퓨팅 환경을 변경하려면 innodb_thread_concurrency 설정을 조정해야합니다.
#
# 관련 정보는 14.8.5 절“InnoDB에 대한 스레드 동시성 구성”을 참조하십시오.
#
# * Apply Option
# innodb_thread_concurrency=0
#
# --------------------------------------------
#
# @ innodb_thread_sleep_delay
#
# Property : Value
# Command-Line Format : --innodb-thread-sleep-delay=#
# System Variable : innodb_thread_sleep_delay
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 10000
# Minimum Value	0
# Maximum Value	1000000
#
# InnoDB 대기열에 참여하기 전에 InnoDB 스레드가 잠자기 시간을 마이크로 초 단위로 정의합니다. 기본값은 10000입니다. 값이 0이면 절전 모드가 해제됩니다.
# innodb_adaptive_max_sleep_delay를 innodb_thread_sleep_delay에 허용하는 가장 높은 값으로 설정할 수 있으며 InnoDB는
# 현재 스레드 예약 활동에 따라 innodb_thread_sleep_delay를 자동으로 위 또는 아래로 조정합니다.
# 이 동적 조정은 시스템이 약간로드되거나 전체 용량 근처에서 작동 할 때 스레드 스케줄링 메커니즘이 원활하게 작동하도록 도와줍니다.
#
# 자세한 내용은 14.8.5 절“InnoDB에 대한 스레드 동시성 구성”을 참조하십시오.
#
# * Apply Option
# innodb_thread_sleep_delay=10000
#
# --------------------------------------------
#
# @ innodb_tmpdir
#
# Property : Value
# Command-Line Format : --innodb-tmpdir=dir_name
# Introduced	5.7.11
# System Variable : innodb_tmpdir
# Scope : Global, Session
# Dynamic	Yes
# Type : Directory name
# Default Value : NULL
#
# 온라인 ALTER TABLE 조작 중에 테이블을 재 빌드하는 동안 작성된 임시 정렬 파일의 대체 디렉토리를 정의하는 데 사용됩니다.
#
# 테이블을 재 빌드하는 온라인 ALTER TABLE 조작은 또한 원래 테이블과 동일한 디렉토리에 중간 테이블 파일을 작성합니다. innodb_tmpdir 옵션은 중간 테이블 파일에는 적용되지 않습니다.
#
# 유효한 값은 MySQL 데이터 디렉토리 경로가 아닌 다른 디렉토리 경로입니다.
# 값이 NULL (기본값) 인 경우 임시 파일은 MySQL 임시 디렉토리 (Unix의 경우 $ TMPDIR, Windows의 경우 % TEMP % 또는 --tmpdir 구성 옵션으로 지정된 디렉토리)로 작성됩니다.
# 디렉토리가 지정되면 디렉토리 및 권한의 존재 여부는 SET 문을 사용하여 innodb_tmpdir을 구성한 경우에만 확인됩니다. 디렉토리 문자열에 심볼릭 링크가 제공되면 심볼릭 링크가 확인되어 절대 경로로 저장됩니다.
# 경로는 512 바이트를 초과하지 않아야합니다. innodb_tmpdir이 유효하지 않은 디렉토리로 설정된 경우 온라인 ALTER TABLE 조작은 오류를보고합니다.
# innodb_tmpdir은 MySQL tmpdir 설정을 무시하지만 온라인 ALTER TABLE 작업에만 적용됩니다.
#
# innodb_tmpdir을 구성하려면 FILE 권한이 필요합니다.
#
# innodb_tmpdir 옵션은 tmpfs 파일 시스템에있는 임시 파일 디렉토리의 오버 플로우를 피하기 위해 도입되었습니다. 이러한 오버 플로우는 테이블을 재 빌드하는 온라인 ALTER TABLE 조작 중에 작성된 대형 임시 정렬 파일의 결과로 발생할 수 있습니다.
#
# 복제 환경에서 모든 서버의 운영 체제 환경이 동일한 경우에만 innodb_tmpdir 설정 복제를 고려하십시오.
# 그렇지 않으면, innodb_tmpdir 설정을 복제하면 테이블을 재 빌드하는 온라인 ALTER TABLE 조작을 실행할 때 복제 실패가 발생할 수 있습니다.
# 서버 운영 환경이 다른 경우 각 서버에서 개별적으로 innodb_tmpdir을 구성하는 것이 좋습니다.
#
# 자세한 내용은 14.13.3 절“온라인 DDL 공간 요구 사항”을 참조하십시오. 온라인 ALTER TABLE 작업에 대한 자세한 내용은 14.13 절“InnoDB 및 온라인 DDL”을 참조하십시오.
#
# * Apply Option
# innodb_tmpdir=Directory name
#
# --------------------------------------------
#
# @ innodb_trx_purge_view_update_only_debug
#
# Property : Value
# Command-Line Format : --innodb-trx-purge-view-update-only-debug[={OFF|ON}]
# System Variable : innodb_trx_purge_view_update_only_debug
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# 삭제보기를 업데이트하면서 삭제 표시 레코드 삭제를 일시 중지합니다. 이 옵션은 제거 뷰가 업데이트되었지만 제거가 아직 수행되지 않은 상황을 인위적으로 만듭니다.
# 이 옵션은 디버깅 지원이 WITH_DEBUG CMake 옵션을 사용하여 컴파일 된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# innodb_trx_purge_view_update_only_debug=OFF
#
# --------------------------------------------
#
# @ innodb_trx_rseg_n_slots_debug
#
# Property : Value
# Command-Line Format : --innodb-trx-rseg-n-slots-debug=#
# System Variable : innodb_trx_rseg_n_slots_debug
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 0
# Maximum Value	1024
#
# TRX_RSEG_N_SLOTS를 실행 취소 로그 세그먼트에 대한 여유 슬롯을 찾는 trx_rsegf_undo_find_free 함수에 대해 지정된 값으로 제한하는 디버그 플래그를 설정합니다.
# 이 옵션은 디버깅 지원이 WITH_DEBUG CMake 옵션을 사용하여 컴파일 된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# innodb_trx_rseg_n_slots_debug=0
#
# --------------------------------------------
#
# @ innodb_undo_directory
#
# Property : Value
# Command-Line Format : --innodb-undo-directory=dir_name
# System Variable : innodb_undo_directory
# Scope : Global
# Dynamic	No
# Type : Directory name
#
# InnoDB가 실행 취소 테이블 스페이스를 생성하는 경로입니다. 일반적으로 실행 취소 로그를 다른 저장 장치에 배치하는 데 사용됩니다. innodb_rollback_segments 및 innodb_undo_tablespaces와 함께 사용됩니다.
#
# 기본값은 없습니다 (NULL). 경로를 지정하지 않으면 datadir에 의해 정의 된대로 실행 취소 테이블 스페이스가 MySQL 데이터 디렉토리에 작성됩니다.
#
# 자세한 내용은 14.6.3.4 절“테이블 스페이스 실행 취소”를 참조하십시오.
#
# * Apply Option
# innodb_undo_directory=Directory name
#
# --------------------------------------------
#
# @ innodb_undo_log_truncate
#
# Property : Value
# Command-Line Format : --innodb-undo-log-truncate[={OFF|ON}]
# System Variable : innodb_undo_log_truncate
# Scope : Global
# Dynamic	Yes
# Type : Boolean
# Default Value : OFF
#
# 사용 가능한 경우, innodb_max_undo_log_size에 의해 정의 된 임계 값을 초과하는 실행 취소 테이블 스페이스는 잘림으로 표시됩니다.
# 실행 취소 테이블 스페이스 만 잘릴 수 있습니다. 시스템 테이블 스페이스에있는 실행 취소 로그 자르기는 지원되지 않습니다.
# 잘림이 발생하려면 실행 취소 테이블 스페이스를 사용하도록 구성된 두 개의 실행 취소 테이블 스페이스와 두 개의 다시 실행 가능 실행 취소 로그가 있어야합니다.
# 즉, innodb_undo_tablespaces는 2 이상의 값으로 설정되어야하고 innodb_rollback_segments는 35 이상의 값으로 설정되어야합니다.
#
# innodb_purge_rseg_truncate_frequency 변수를 사용하여 실행 취소 테이블 스페이스를 신속하게자를 수 있습니다.
#
# 자세한 정보는 실행 취소 테이블 스페이스 자르기를 참조하십시오.
#
# * Apply Option
# innodb_undo_log_truncate=OFF
#
# --------------------------------------------
#
# @ innodb_undo_logs
#
# Property : Value
# Command-Line Format : --innodb-undo-logs=#
# Deprecated	5.7.19
# System Variable : innodb_undo_logs
# Scope : Global
# Dynamic	Yes
# Type : Integer
# Default Value : 128
# Minimum Value	1
# Maximum Value	128
#
# 노트
# innodb_undo_logs는 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다.
#
# InnoDB에서 사용하는 롤백 세그먼트 수를 정의합니다. innodb_undo_logs 옵션은 innodb_rollback_segments의 별명입니다. 자세한 정보는 innodb_rollback_segments에 대한 설명을 참조하십시오.
#
# * Apply Option
# innodb_undo_logs=128
#
# --------------------------------------------
#
# @ innodb_undo_tablespaces
#
# Property : Value
# Command-Line Format : --innodb-undo-tablespaces=#
# Deprecated	5.7.21
# System Variable : innodb_undo_tablespaces
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 0
# Minimum Value	0
# Maximum Value	95
#
# InnoDB에서 사용하는 실행 취소 테이블 스페이스 수입니다. 기본값은 0입니다.
#
# 노트
# innodb_undo_tablespaces는 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다.
#
# 장기 실행 트랜잭션 중에 실행 취소 로그가 커질 수 있으므로 여러 테이블 스페이스에 실행 취소 로그가 있으면 한 테이블 스페이스의 최대 크기가 줄어 듭니다.
# undoN 형식의 이름으로 innodb_undo_directory에 의해 정의 된 위치에 실행 취소 테이블 공간 파일이 작성됩니다. 여기서 N은 공간 ID를 나타내는 일련의 정수 (앞에 오는 0 포함)입니다.
#
# 실행 취소 테이블 스페이스 파일의 초기 크기는 innodb_page_size 값에 따라 다릅니다. 기본 16KB InnoDB 페이지 크기의 경우 초기 실행 취소 테이블 스페이스 파일 크기는 10MiB입니다.
# 4KB, 8KB, 32KB 및 64KB 페이지 크기의 경우 초기 실행 취소 테이블 스페이스 파일 크기는 각각 7MiB, 8MiB, 20MiB 및 40MiB입니다.
#
# 실행 취소 로그를 자르려면 최소 두 개의 실행 취소 테이블 스페이스가 필요합니다. 실행 취소 테이블 스페이스 자르기를 참조하십시오.
#
# Important
# innodb_undo_tablespaces는 MySQL 인스턴스를 초기화하기 전에 만 구성 할 수 있으며 나중에 변경할 수 없습니다. 값을 지정하지 않으면 인스턴스는 기본 설정 0을 사용하여 초기화됩니다.
# MySQL 인스턴스를 초기화 할 때 지정된 것보다 많은 실행 취소 테이블 스페이스로 InnoDB를 다시 시작하려고하면 시작 오류가 발생하고 InnoDB가 찾지 못했다는 오류가 발생합니다 예상 실행 취소 테이블 스페이스 수
#
# 14.6.7 절“실행 취소 로그”에 설명 된대로 128 개 롤백 세그먼트 중 32 개가 임시 테이블 용으로 예약되어 있습니다.
# 하나의 롤백 세그먼트는 항상 시스템 테이블 스페이스에 지정되므로 실행 취소 테이블 스페이스에 95 개의 롤백 세그먼트를 사용할 수 있습니다. 이는 innodb_undo_tablespaces 최대 한계가 95임을 의미합니다.
#
# 자세한 내용은 14.6.3.4 절“테이블 스페이스 실행 취소”를 참조하십시오.
#
# * Apply Option
# innodb_undo_tablespaces=0
#
# --------------------------------------------
#
# @ innodb_use_native_aio
#
# Property : Value
# Command-Line Format : --innodb-use-native-aio[={OFF|ON}]
# System Variable : innodb_use_native_aio
# Scope : Global
# Dynamic	No
# Type : Boolean
# Default Value : ON
#
# Linux 비동기 I / O 서브 시스템 사용 여부를 지정합니다. 이 변수는 Linux 시스템에만 적용되며 서버가 실행중인 동안에는 변경할 수 없습니다.
# 일반적으로이 옵션은 기본적으로 활성화되어 있으므로 구성 할 필요가 없습니다.
#
# Windows 시스템에서 InnoDB의 비동기 I / O 기능은 Linux 시스템에서 사용할 수 있습니다. (다른 유닉스 계열 시스템은 계속해서 동기 I / O 호출을 사용합니다.)
# 이 기능은 I / O 바운드 시스템의 확장 성을 향상시킵니다.이 기능은 일반적으로 SHOW ENGINE INNODB STATUS \ G 출력에서 ​​많은 보류중인 읽기 / 쓰기를 표시합니다.
#
# 많은 수의 InnoDB I / O 스레드를 사용하여 실행하고 특히 동일한 서버 시스템에서 여러 인스턴스를 실행하면 Linux 시스템의 용량 제한을 초과 할 수 있습니다.
# 이 경우 다음과 같은 오류가 발생할 수 있습니다.
#
# EAGAIN : 지정된 maxevents가 사용자의 사용 가능한 이벤트 한계를 초과합니다.
# 일반적으로 / proc / sys / fs / aio-max-nr에 더 높은 제한을 작성하여이 오류를 해결할 수 있습니다.
#
# 그러나 OS의 비동기 I / O 하위 시스템에 문제가있어 InnoDB가 시작되지 않으면 innodb_use_native_aio = 0으로 서버를 시작할 수 있습니다.
# InnoDB가 tmpdir 위치, tmpfs 파일 시스템 및 tmpfs에서 AIO를 지원하지 않는 Linux 커널의 조합과 같은 잠재적 인 문제를 감지하면 시작 중에이 옵션을 자동으로 비활성화 할 수도 있습니다.
#
# 자세한 내용은 14.8.7 절“Linux에서 비동기 I / O 사용”을 참조하십시오.
#
# * Apply Option
# innodb_use_native_aio=ON
#
# --------------------------------------------
# 
# @ innodb_use_sys_malloc
# 
# Command-Line Format	--innodb-use-sys-malloc[={OFF|ON}]
# Deprecated	Yes
# System Variable	innodb_use_sys_malloc
# Scope	Global
# Dynamic	No
# Type	Boolean
# Default Value	ON
# 
# 운영 체제 메모리 할당자를 활성화합니다. 비활성화되면 InnoDB는 자체 할당자를 사용합니다. 기본값은 ON입니다.
# 자세한 내용은 Section 14.8.4,“InnoDB 용 메모리 할당 자 구성”을 참조하십시오.
# 
# innodb_use_sys_malloc은 더 이상 사용되지 않습니다. 향후 MySQL 릴리스에서 제거 될 것으로 예상됩니다.
# 
# * Apply Option
# innodb_use_sys_malloc=ON
# 
# --------------------------------------------
#
# @ innodb_version
#
# InnoDB 버전 번호 MySQL 5.7에서는 InnoDB에 대한 별도의 버전 번호가 적용되지 않으며이 값은 서버의 버전 번호와 동일합니다.
#
# * Apply Option
# innodb_version=OFF
#
# --------------------------------------------
#
# @ innodb_write_io_threads
#
# Property : Value
# Command-Line Format : --innodb-write-io-threads=#
# System Variable : innodb_write_io_threads
# Scope : Global
# Dynamic	No
# Type : Integer
# Default Value : 4
# Minimum Value	1
# Maximum Value	64
#
# InnoDB의 쓰기 작업을위한 I / O 스레드 수 기본값은 4입니다. 읽기 스레드에 해당하는 것은 innodb_read_io_threads입니다. 자세한 내용은 14.8.6 절“백그라운드 InnoDB I / O 스레드 수 구성”을 참조하십시오.
# 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# 노트
# Linux 시스템에서 innodb_read_io_threads, innodb_write_io_threads 및 Linux aio-max-nr 설정에 대한 기본 설정으로 여러 MySQL 서버 (일반적으로 12 개 이상)를 실행하면 시스템 제한을 초과 할 수 있습니다.
# 이상적으로는 aio-max-nr 설정을 늘리십시오. 해결 방법으로 MySQL 변수 중 하나 또는 둘 다에 대한 설정을 줄일 수 있습니다.
#
# 바이너리 로그의 디스크 동기화를 제어하는 ​​sync_binlog의 값도 고려하십시오.
#
# 일반적인 I / O 튜닝에 대한 조언은 8.5.8 절.“InnoDB 디스크 I / O 최적화”에서 참조하십시오.
#
# * Apply Option
# innodb_write_io_threads=4
#
# --------------------------------------------
# 
# @ ignore_builtin_innodb
# 
# Command-Line Format : --ignore-builtin-innodb[={OFF|ON}]
# Deprecated : Yes
# System Variable : ignore_builtin_innodb
# Scope : Global
# Dynamic : No
# Type : Boolean
# 
# In earlier versions of MySQL, enabling this variable caused the server to behave as if the built-in InnoDB were not present, which enabled the InnoDB Plugin to be used instead. In MySQL 5.7, InnoDB is the default storage engine and InnoDB Plugin is not used, so this variable is ignored.
# 
# 
# 이전 버전의 MySQL에서는이 변수를 활성화하면 서버가 내장 InnoDB가없는 것처럼 작동하여 대신 InnoDB 플러그인을 사용할 수 있게되었습니다.
# MySQL 5.7에서는 InnoDB가 기본 스토리지 엔진이고 InnoDB Plugin이 사용되지 않으므로이 변수는 무시됩니다.
#
# * Apply Option
# ignore_builtin_innodb=ON
# 
# --------------------------------------------