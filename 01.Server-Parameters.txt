# ===================================
# ======= 서버 시스템 변수  ==========
# ===================================
# @ avoid_temporal_upgrade
# 
# Command-Line Format : --avoid-temporal-upgrade[={OFF|ON}]
# Deprecated : Yes
# System Variable : avoid_temporal_upgrade
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
#
# 이 변수는 ALTER TABLE이 5.6.4 이전 형식 (분수 초 정밀도를 지원하지 않는 TIME, DATETIME 및 TIMESTAMP 컬럼)인 것으로 확인된 임시 컬럼을 암시 적으로 업그레이드할지 여부를 제어합니다.
# 이러한 컬럼을 업그레이드하려면 테이블을 다시 빌드해야하므로 수행할 작업에 적용할 수 있는 빠른 변경을 사용할 수 없습니다.
# 
# 이 변수는 기본적으로 비활성화되어 있습니다. 이를 활성화하면 ALTER TABLE이 임시 컬럼을 다시 작성하지 않으므로 가능한 빠른 변경을 활용할 수 있습니다.
# 
# 이 변수는 더 이상 사용되지 않습니다. MySQL의 향후 릴리스에서 제거 될 것으로 예상됩니다.
# 
# * Apply Option
# avoid_temporal_upgrade=OFF
# 
# --------------------------------------------
# 
# @ autocommit
# 
# Property : Value
# Command-Line Format : --autocommit[={OFF|ON}]
# System Variable : autocommit
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 자동 커밋 모드 1로 설정하면 테이블에 대한 모든 변경 사항이 즉시 적용됩니다.
# 0으로 설정 COMMIT하면 트랜잭션을 수락하거나 ROLLBACK 취소 하는 데 사용해야 합니다. 경우 autocommit 0과 1로 변경, MySQL은 자동으로 수행 COMMIT열려있는 거래.
# 트랜잭션을 시작하는 또 다른 방법은 START TRANSACTIONor BEGIN 문 을 사용하는 것입니다. 페이지의 섹션 13.3.1, "START TRANSACTION은 COMMIT 및 ROLLBACK 문" .
# 기본적으로 클라이언트 연결은 1로 autocommit설정됩니다. 클라이언트를 기본값 0 autocommit으로 시작하려면 --autocommit=0옵션으로 서버를 시작하여 전역 값을 설정하십시오.
# 
# 옵션 파일을 사용하여 변수를 설정하려면 다음 행을 포함하십시오.
# [mysqld]
# autocommit=0
# 
# * Apply Option
# autocommit=ON
# 
# --------------------------------------------
# 
# @ automatic_sp_privileges
# 
# Command-Line Format	--automatic-sp-privileges[={OFF|ON}]
# System Variable	automatic_sp_privileges
# Scope	Global
# Dynamic	Yes
# Type	Boolean
# Default Value	ON
# 
# 이 변수의 값이 1 (기본값)이면 사용자가 루틴을 이미 실행하고 변경 또는 삭제할 수 없는 경우 서버는 저장 루틴의 작성자에게 EXECUTE 및 ALTER ROUTINE 권한을 자동으로 부여합니다.
# (루틴을 삭제하려면 ALTER ROUTINE 권한이 필요합니다.) 또한 루틴이 삭제될 때 서버는 작성자로부터 해당 권한을 자동으로 삭제합니다.
# automatic_sp_privileges가 0이면 서버는 이러한 권한을 자동으로 추가하거나 삭제하지 않습니다.
# 
# The creator of a routine is the account used to execute the CREATE statement for it. This might not be the same as the account named as the DEFINER in the # routine definition.
# 
# 루틴의 작성자는 CREATE 문을 실행하는데 사용되는 계정입니다. 이것은 루틴 정의에서 DEFINER로 명명된 계정과 동일하지 않을 수 있습니다.
# 
# --skip-new로 mysqld를 시작하면 automatic_sp_privileges는 OFF로 설정됩니다.
#
# * Apply Option
# automatic_sp_privileges=ON
# 
# --------------------------------------------
# 
# @ auto_increment_increment
# 
# Command-Line Format	--auto-increment-increment=#
# System Variable	auto_increment_increment
# Scope	Global, Session
# Dynamic	Yes
# Type	Integer
# Default Value	1
# Minimum Value	1
# Maximum Value	65535

# auto_increment_increment 및 auto_increment_offset은 소스간 복제와 함께 사용하기위한 것이며 AUTO_INCREMENT 열의 작업을 제어하는 데 사용할 수 있습니다.
# 두 변수 모두 전역 및 세션값이 있으며 각각 1에서 65,535 사이의 정수 값을 가정 할 수 있습니다. 이 두 변수중 하나의 값을 0으로 설정하면 값이 대신 1로 설정됩니다.
# 이 두 변수 중 하나의 값을 65,535보다 크거나 0보다 작은 정수로 설정하려고하면 값이 대신 65,535로 설정됩니다.
# auto_increment_increment 또는 auto_increment_offset의 값을 정수가 아닌 값으로 설정하려고 하면 오류가 발생하고 변수의 실제값은 변경되지 않습니다.
# 
# 참고사항
# auto_increment_increment는 NDB 테이블과 함께 사용하도록 지원됩니다.
# 
# 서버에서 그룹 복제가 시작되면 auto_increment_increment 값이 group_replication_auto_increment_increment 값으로 변경되며
# 기본값은 7이며 auto_increment_offset 값은 서버 ID로 변경됩니다. 그룹 복제가 중지되면 변경 사항이 되돌려집니다.
# 이러한 변경 사항은 auto_increment_increment 및 auto_increment_offset의 기본값이 각각 1 인 경우에만 수행되고 되돌려집니다.
# 해당 값이 이미 기본값에서 # 수정 된 경우 그룹 복제는 해당 값을 변경하지 않습니다.
# 
# auto_increment_increment 및 auto_increment_offset은 다음과 같이 AUTO_INCREMENT 컬럼 동작에 영향을줍니다.
# 
# auto_increment_increment는 연속 컬럼값 사이의 간격을 제어합니다. 예를 들면 :
# mysql> SHOW VARIABLES LIKE 'auto_inc%';
# +--------------------------+-------+
# | Variable_name            | Value |
# +--------------------------+-------+
# | auto_increment_increment | 1     |
# | auto_increment_offset    | 1     |
# +--------------------------+-------+
# 2 rows in set (0.00 sec)
# 
# mysql> CREATE TABLE autoinc1
#     -> (col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
#   Query OK, 0 rows affected (0.04 sec)
# 
# mysql> SET @@auto_increment_increment=10;
# Query OK, 0 rows affected (0.00 sec)
# 
# mysql> SHOW VARIABLES LIKE 'auto_inc%';
# +--------------------------+-------+
# | Variable_name            | Value |
# +--------------------------+-------+
# | auto_increment_increment | 10    |
# | auto_increment_offset    | 1     |
# +--------------------------+-------+
# 2 rows in set (0.01 sec)
# 
# mysql> INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);
# Query OK, 4 rows affected (0.00 sec)
# Records: 4  Duplicates: 0  Warnings: 0
# 
# mysql> SELECT col FROM autoinc1;
# +-----+
# | col |
# +-----+
# |   1 |
# |  11 |
# |  21 |
# |  31 |
# +-----+
# 4 rows in set (0.00 sec)
# 
# auto_increment_offset은 AUTO_INCREMENT 컬럼값의 시작점을 결정합니다.
# auto_increment_increment에 대한 설명에 제공된 예제와 동일한 세션동안 이러한 명령문이 실행된다고 가정합니다.
# mysql> SET @@auto_increment_offset=5;
# Query OK, 0 rows affected (0.00 sec)
# 
# mysql> SHOW VARIABLES LIKE 'auto_inc%';
# +--------------------------+-------+
# | Variable_name            | Value |
# +--------------------------+-------+
# | auto_increment_increment | 10    |
# | auto_increment_offset    | 5     |
# +--------------------------+-------+
# 2 rows in set (0.00 sec)
# 
# mysql> CREATE TABLE autoinc2
#     -> (col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
# Query OK, 0 rows affected (0.06 sec)
# 
# mysql> INSERT INTO autoinc2 VALUES (NULL), (NULL), (NULL), (NULL);
# Query OK, 4 rows affected (0.00 sec)
# Records: 4  Duplicates: 0  Warnings: 0
# 
# mysql> SELECT col FROM autoinc2;
# +-----+
# | col |
# +-----+
# |   5 |
# |  15 |
# |  25 |
# |  35 |
# +-----+
# 4 rows in set (0.02 sec)
# auto_increment_offset의 값이 auto_increment_increment의 값보다 크면 auto_increment_offset의 값은 무시됩니다.
# 
# 이러한 변수 중 하나가 변경된 후 AUTO_INCREMENT 열이 포함 된 테이블에 새 행이 삽입되면 일련의 AUTO_INCREMENT 값이 컬럼에 이미 있는 값과 관계없이
# 계산되고 다음 값이 삽입되기 때문에 결과가 직관적이지 않은 것처럼 보일 수 있습니다. AUTO_INCREMENT 컬럼의 기존 최대 값보다 큰 계열의 최소값입니다. 시리즈는 다음과 같이 계산됩니다.
# 
# auto_increment_offset + N × auto_increment_increment
# 
# 여기서 N은 계열 [1, 2, 3, ...]의 양의 정수 값입니다. 예를 들면 :
# mysql> SHOW VARIABLES LIKE 'auto_inc%';
# +--------------------------+-------+
# | Variable_name            | Value |
# +--------------------------+-------+
# | auto_increment_increment | 10    |
# | auto_increment_offset    | 5     |
# +--------------------------+-------+
# 2 rows in set (0.00 sec)
# 
# mysql> SELECT col FROM autoinc1;
# +-----+
# | col |
# +-----+
# |   1 |
# |  11 |
# |  21 |
# |  31 |
# +-----+
# 4 rows in set (0.00 sec)
# 
# mysql> INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);
# Query OK, 4 rows affected (0.00 sec)
# Records: 4  Duplicates: 0  Warnings: 0
# 
# mysql> SELECT col FROM autoinc1;
# +-----+
# | col |
# +-----+
# |   1 |
# |  11 |
# |  21 |
# |  31 |
# |  35 |
# |  45 |
# |  55 |
# |  65 |
# +-----+
# 8 rows in set (0.00 sec)
# 
# auto_increment_increment 및 auto_increment_offset에 대해 표시된 값은 시리즈 5 + N × 10, 즉 [5, 15, 25, 35, 45, ...]를 생성합니다.
# INSERT 이전의 col 열에있는 가장 높은 값은 31이고 AUTO_INCREMENT 시리즈에서 다음으로 사용 가능한 값은 35이므로 col에 대해 삽입된 값은 해당 지점에서
# 시작되고 결과는 SELECT 쿼리에 대해 표시된 것과 같습니다.
# 
# 이 두 변수의 효과를 단일 테이블로 제한하는 것은 불가능합니다. 이러한 변수는 MySQL 서버의 모든 테이블에있는 모든 AUTO_INCREMENT 열의 동작을 제어합니다.
# 두 변수의 전역 값이 설정되면 전역 값이 변경되거나 세션 값을 설정하여 재정의 될때까지 또는 mysqld가 다시 시작될 때까지 그 효과가 지속됩니다.
# 로컬 값이 설정된 경우 해당 세션중에 값이 변경되지 않는한 새 값은 세션 기간 동안 현재 사용자가 새 행을 삽입한 모든 테이블의 AUTO_INCREMENT 열에 영향을줍니다.
# 
# auto_increment_increment의 기본값은 1입니다.
#
# * Apply Option
# auto_increment_increment=1
# 
# --------------------------------------------
#
# @ auto_increment_offset
# 
# Command-Line Format	--auto-increment-offset=#
# System Variable	auto_increment_offset
# Scope	Global, Session
# Dynamic	Yes
# Type	Integer
# Default Value	1
# Minimum Value	1
# Maximum Value	65535
# 
# 이 변수의 기본값은 1입니다. 기본값을 그대로두고 서버에서 그룹 복제를 시작하면 서버 ID로 변경됩니다.
# 
# 참고사항
# auto_increment_offset도 NDB 테이블과 함께 사용할 수 있도록 지원됩니다.
#
# * Apply Option
# auto_increment_increment=1
# 
# --------------------------------------------
# 
# @ back_log :
# 
# Property : Value
# Command-Line Format : --back-log=#
# System Variable : back_log
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : 1
# Maximum Value : 65535
# 
# MySQL이 가질 수있는 미해결 연결 요청 수 이것은 메인 MySQL 스레드가 매우 짧은 시간에 많은 연결 요청을 받으면 작동합니다.
# 그런 다음 주 스레드가 연결을 확인하고 새 스레드를 시작하는 데 약간의 시간이 걸리지만 (아주 적은 시간이 소요됨) 이 back_log값은 MySQL이 일시적으로 새 요청에 대한 응답을 중지하기 전에
# 이 짧은 시간 동안 누적 될 수있는 요청 수를 나타냅니다. 단기간에 많은 수의 연결이 필요한 경우에만이 값을 늘려야합니다.
# 
# 즉,이 값은 들어오는 TCP / IP 연결에 대한 청취 큐의 크기입니다. 운영 체제에는이 큐의 크기에 대한 자체 제한이 있습니다.
# 
# Unix listen()시스템 호출 매뉴얼 페이지에 자세한 내용이 있어야합니다. 이 변수의 최대 값에 대해서는 OS 문서를 확인하십시오. back_log 운영 체제 제한보다 높게 설정할 수 없습니다.
# 기본값은 다음 수식을 기반으로하며 900으로 제한됩니다.
# 
# 50 + (max_connections / 5)
#
# * Apply Option
# back_log=-1
# 
# --------------------------------------------
# 
# @ basedir
# 
# Command-Line Format : --basedir=dir_name
# System Variable : basedir
# Scope : Global
# Dynamic : No
# Type : Directory name
# 
# MySQL 설치 기본 디렉토리
#
# * Apply Option
# basedir=<Directory>
# 
# --------------------------------------------
# 
# @ big_tables :
# 
# Property : Value
# Command-Line Format : --big-tables[={OFF|ON}]
# System Variable : big_tables
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 사용 가능한 경우, 서버는 모든 임시 테이블을 메모리가 아닌 디스크에 저장합니다.
# 이렇게하면 큰 임시 테이블이 필요한 작업의 대부분의 오류를 방지 할 수있을 뿐만 아니라 메모리 내 테이블이 충분한 쿼리 속도도 느려집니다. The table tbl_name is fullSELECT
# 
# 새 연결의 기본값은 OFF (메모리 내 임시 테이블 사용)입니다.
# 일반적으로 서버가 작은 임시 테이블의 메모리를 사용하고 필요에 따라 디스크 기반 테이블로 전환하여 큰 결과 세트를 자동으로 처리 할 수 ​​있으므로이 변수를 사용하지 않아도됩니다.
# * Apply Option
# big_tables=OFF
# 
# --------------------------------------------
# 
# @ connect_timeout :
# 
# Property : Value
# Command-Line Format : --connect-timeout=#
# System Variable : connect_timeout
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10
# Minimum Value : 2
# Maximum Value : 31536000
# 
# mysqld 서버가로 응답하기 전에 연결 패킷을 기다리는 시간 ( 초) Bad handshake. 기본값은 10 초입니다.
# 
# connect_timeout값을 늘리면 클라이언트에서 양식 오류가 자주 발생하는 경우 도움이 될 수 있습니다 . Lost connection to MySQL server at 'XXX', system error: errno
#
# * Apply Option
# connect_timeout=10
# 
# --------------------------------------------
# 
# bind_address
# 
# Command-Line Format	--bind-address=addr
# System Variable	bind_address
# Scope	Global
# Dynamic	No
# Type	String
# Default Value	*
# 
# MySQL 서버는 TCP / IP 연결을 위해 단일 네트워크 소켓에서 수신합니다. 이 소켓은 단일 주소에 바인딩되지만 주소가 여러 네트워크 인터페이스에 매핑 될 수 있습니다.
# 주소를 지정하려면 서버 시작시 bind_address = addr을 설정하십시오. 여기서 addr은 IPv4 또는 IPv6 주소 또는 호스트 이름입니다. addr이 호스트 이름이면 서버는 이름을 IP 주소로 확인하고 해당 주소에 바인딩합니다.
# 호스트 이름이 여러 IP 주소로 확인되는 경우 서버는 첫 번째 IPv4 주소 (있는 경우)를 사용하거나 첫 번째 IPv6 주소를 사용합니다.
# 
# 서버는 다음과 같이 다양한 유형의 주소를 처리합니다.
# 주소가 * 이면 서버는 모든 서버 호스트 IPv4 인터페이스에서 TCP / IP 연결을 허용하고 서버 호스트가 IPv6를 지원하는 경우 모든 IPv6 인터페이스에서 TCP / IP 연결을 허용합니다.
# 이 주소를 사용하여 모든 서버 인터페이스에서 IPv4 및 IPv6 연결을 모두 허용합니다. 이 값이 기본값입니다.
# 
# 주소가 0.0.0.0이면 서버는 모든 서버 호스트 IPv4 인터페이스에서 TCP / IP 연결을 허용합니다. 
# 주소가 ::이면 서버는 모든 서버 호스트 IPv4 및 IPv6 인터페이스에서 TCP / IP 연결을 허용합니다.
# 
# 주소가 IPv4 매핑 주소 인 경우 서버는 IPv4 또는 IPv6 형식의 해당 주소에 대한 TCP / IP 연결을 허용합니다.
# 예를 들어 서버가 :: ffff : 127.0.0.1에 바인딩 된 경우 클라이언트는 --host = 127.0.0.1 또는 --host = :: ffff : 127.0.0.1을 사용하여 연결할 수 있습니다.
# 주소가 "일반"IPv4 또는 IPv6 주소 (예 : 127.0.0.1 또는 :: 1) 인 경우 서버는 해당 IPv4 또는 IPv6 주소에 대해서만 TCP / IP 연결을 허용합니다.
# 주소 바인딩에 실패하면 서버에서 오류가 발생하고 시작되지 않습니다.
# 
# 서버를 특정 주소에 바인딩하려는 경우 mysql.user 시스템 테이블에 해당 주소에 연결하는 데 사용할 수있는 관리 권한이있는 계정이 포함되어 있는지 확인하십시오.
# 그렇지 않으면 서버를 종료 할 수 없습니다. 예를 들어 서버를 *에 바인딩하면 기존의 모든 계정을 사용하여 연결할 수 있습니다.
# 그러나 서버를 :: 1로 바인딩하면 해당 주소에서만 연결을 허용합니다. 이 경우 먼저 mysql.user 테이블에 'root'@ ':: 1'계정이 있는지 확인하여 서버에 계속 연결하여 종료 할 수 있습니다.
# 
# 이 변수는 임베디드 서버 (libmysqld)에 영향을 미치지 않으며 임베디드 서버 내에서 보이지 않습니다.
#
# * Apply Option
# bind_address=*
# 
# --------------------------------------------
# 
# @ default_password_lifetime :
# 
# Property : Value
# Command-Line Format : --default-password-lifetime=#
# System Variable : default_password_lifetime
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : (>= 5.7.11)	0
# Default Value : (<= 5.7.10)	360
# Minimum Value : 0
# Maximum Value : 65535
# 
# 이 변수는 글로벌 자동 비밀번호 만료 정책을 정의합니다. 
# 기본값 default_password_lifetime 은 0이며 자동 암호 만료를 비활성화합니다. 의 값이 default_password_lifetime양의 정수 N이면 허용되는 암호 수명을 나타냅니다.
# 비밀번호는 매일 변경해야합니다 N.
# 
# ALTER USER 명령문 의 비밀번호 만기 옵션을 사용하여 개별 계정에 대해 글로벌 비밀번호 만기 정책을 원하는대로 대체 할 수 있습니다 . 6.2.11 절“비밀번호 관리”를 참조하십시오 .
# 
# 노트
# MySQL 5.7.11 이전의 기본값 default_password_lifetime 은 360입니다 (암호는 약 1 년에 한 번 변경해야 함).
# 해당 버전의 경우 default_password_lifetime 변수 또는 개별 사용자 계정을 변경하지 않으면 360 일 후에 모든 사용자 비밀번호가 만료되고이 경우 모든 사용자 계정이 제한 모드로 실행됩니다.
# 그러면 서버에 연결하는 클라이언트 (실제로 사용자 임)는 암호를 변경해야한다는 오류가 발생합니다.
# ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.
# 
# 그러나 서버에서 자동으로 연결하는 클라이언트 (예 : 스크립트로 만든 연결)에서는 놓치기 쉽습니다.
# 비밀번호 만료로 인해 이러한 클라이언트가 갑자기 작동하지 않게하려면 다음과 같이 해당 클라이언트의 비밀번호 만료 설정을 변경하십시오.
# 
# ALTER USER 'script'@'localhost' PASSWORD EXPIRE NEVER
# 또는 default_password_lifetime 변수를로 설정하여 0모든 사용자에 대해 자동 비밀번호 만료를 비활성화하십시오.
#
# * Apply Option
# default_password_lifetime=0
# 
# --------------------------------------------
# 
# @ disconnect_on_expired_password :
# 
# Property : Value
# Command-Line Format : --disconnect-on-expired-password[={OFF|ON}]
# System Variable : disconnect_on_expired_password
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : ON
# 
# 이 변수는 서버가 만료 된 비밀번호로 클라이언트를 처리하는 방법을 제어합니다.
# - 클라이언트가 만료 된 비밀번호를 처리 할 수 ​​있다고 표시하면 disconnect_on_expired_password 값은 관련이 없습니다. 서버는 클라이언트의 연결을 허용하지만 샌드 박스 모드로 둡니다.
# - 클라이언트가 만료 된 비밀번호를 처리 할 수 ​​있다고 표시하지 않으면 서버는 disconnect_on_expired_password 값에 따라 클라이언트를 처리합니다.
#   = disconnect_on_expired_password :가 활성화 된 경우 서버는 클라이언트 연결을 끊습니다.
#   = disconnect_on_expired_password :가 비활성화 된 경우 서버는 클라이언트의 연결을 허용하지만 샌드 박스 모드로 둡니다.
# 
# 만료 된 암호 처리와 관련된 클라이언트 및 서버 설정의 상호 작용에 대한 자세한 내용은 6.2.12 절“만료 된 암호의 서버 처리”를 참조하십시오.
# 
# * Apply Option
# disconnect_on_expired_password=ON
# 
# --------------------------------------------
# 
# @ default_tmp_storage_engine :
# 
# Property : Value
# Command-Line Format : --default-tmp-storage-engine=name
# System Variable : default_tmp_storage_engine
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# 
# Default Value : InnoDB로 TEMPORARY 작성된 기본 스토리지 엔진 (로 작성 CREATE TEMPORARY TABLE) 영구 테이블의 스토리지 엔진을 설정하려면 default_storage_engine시스템 변수를 설정하십시오.
# 가능한 값과 관련하여 해당 변수에 대한 설명도 참조하십시오.
# 
# 서버 시작시 기본 스토리지 엔진을 사용하지 않으면 영구 및 TEMPORARY테이블 의 기본 엔진을 다른 엔진 으로 설정해야합니다. 그렇지 않으면 서버가 시작되지 않습니다.
#
# * Apply Option
# default_tmp_storage_engine=InnoDB
# 
# --------------------------------------------
# 
# @ event_scheduler :
# 
# Property : Value
# Command-Line Format : --event-scheduler[=value]
# System Variable : event_scheduler
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values  : ON, OFF, DISABLED
# 
# 이 변수는 이벤트 스케줄러를 활성화 또는 비활성화하고 시작 또는 중지합니다. 가능한 상태 값은 ON, OFF및 DISABLED이며 기본값은 OFF입니다.
# 이벤트 스케줄러를 켜는 것은 OFF상태를로 설정해야하는 이벤트 스케줄러를 비활성화하는 것과 다릅니다 DISABLED.
# 이 변수와 이벤트 스케줄러 작동에 미치는 영향 은 23.4.2 절.“이벤트 스케줄러 구성” 에서 자세히 설명합니다.
#
# * Apply Option
# event_scheduler=OFF
# 
# --------------------------------------------
# 
# @ foreign_key_checks :
# 
# Property : Value
# System Variable : foreign_key_checks
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 1 (기본값)로 설정하면 외래 키 제약 조건이 검사됩니다. 0으로 설정하면 외래 키 제약 조건이 무시되고 몇 가지 예외가 있습니다.
# 삭제 된 테이블을 재 작성할 때 테이블 정의가 테이블을 참조하는 외부 키 제한 조건을 준수하지 않으면 오류가 리턴됩니다.
# 마찬가지로 ALTER TABLE 외래 키 정의가 잘못 구성된 경우 작업이 오류를 반환합니다. 자세한 내용 은 13.1.18.6 절“FOREIGN 키 제약 조건”을 참조하십시오 .
# 
# 이 변수를 설정하면 NDB테이블과 동일한 효과가 테이블에 적용됩니다 InnoDB. 일반적으로 참조 무결성 을 강화하기 위해 정상 작동 중에이 설정을 활성화 된 상태로 둡니다.
# 외래 키 검사를 비활성화 InnoDB하면 부모 / 자식 관계에 필요한 순서와 다른 순서로 테이블 을 다시로드 할 때 유용 할 수 있습니다 . 13.1.18.6 절.“FOREIGN KEY 제약 조건”을 참조하십시오 .
#
# foreign_key_checks를 0으로 설정하면 데이터 정의 문에도 영향을 미칩니다.
# DROP SCHEMA는 스키마 외부의 테이블에서 참조하는 외래 키가 있는 테이블을 포함하더라도 스키마를 삭제하고, DROP TABLE은 다른 테이블에서 참조하는 외래 키를 가진 테이블을 삭제합니다.
# 
# 노트
# foreign_key_checks를 1로 설정 하면 기존 테이블 데이터의 스캔이 트리거되지 않습니다. 따라서 테이블에 추가 된 행 foreign_key_checks=0은 일관성을 검증하지 않습니다.
# foreign_key_checks = 0 인 경우에도 외래 키 제약 조건에 필요한 인덱스를 삭제할 수 없습니다. 인덱스를 삭제하기 전에 외래 키 제약 조건을 제거해야합니다 (버그 # 70260).
#
# * Apply Option
# foreign_key_checks=ON
# 
# --------------------------------------------
# 
# @ general_log :
# 
# Property : Value
# Command-Line Format : --general-log[={OFF|ON}]
# System Variable : general_log
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 일반 쿼리 로그 사용 여부 OFF로그를 사용하지 않으려면 값을 0 (또는 )으로 설정하고 로그를 사용하려면 1 (또는 ON) 값을 지정할 수 있습니다.
# 로그 출력 대상은 log_output시스템 변수에 의해 제어됩니다 . 해당 값이 NONE인 경우, 로그가 사용 가능하더라도 로그 항목이 기록되지 않습니다.
#
# * Apply Option
# general_log=OFF
# 
# --------------------------------------------
# 
# @ general_log_file :
# 
# Property : Value
# Command-Line Format : --general-log-file=file_name
# System Variable : general_log_file
# Scope : Global
# Dynamic : Yes
# Type : File name
# Default Value : host_name.log
# 
# 일반 쿼리 로그 파일의 이름입니다. 기본값은 host_name.log이지만 --general_log_file옵션을 사용 하여 초기 값을 변경할 수 있습니다 .
# 
# * Apply Option
# general_log_file=host_name.log
# 
# --------------------------------------------
# 
# @ group_concat_max_len :
# 
# Property : Value
# Command-Line Format : --group-concat-max-len=#
# System Variable : group_concat_max_len
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 1024
# Minimum Value : 4
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# GROUP_CONCAT()함수 에 허용되는 최대 결과 길이 (바이트)입니다 . 기본값은 1024입니다.
#
# * Apply Option
# group_concat_max_len=1024
#
# --------------------------------------------
#
# @ interactive_timeout
# 
# Command-Line Format	--interactive-timeout=#
# System Variable	interactive_timeout
# Scope	Global, Session
# Dynamic	Yes
# Type	Integer
# Default Value	28800
# Minimum Value	1
# 서버가 대화식 연결을 닫기 전에 활동을 기다리는 시간 (초)입니다.
# 대화 형 클라이언트는 mysql_real_connect ()에 CLIENT_INTERACTIVE 옵션을 사용하는 클라이언트로 정의됩니다. wait_timeout도 참조하십시오.
#
# 
# --------------------------------------------
# 
# @ join_buffer_size :
# 
# Property : Value
# Command-Line Format : --join-buffer-size=#
# System Variable : join_buffer_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 262144
# Minimum Value : 128
# Maximum Value : (Other, 64-bit platforms)	18446744073709547520
# Maximum Value : (Other, 32-bit platforms)	4294967295
# Maximum Value : (Windows) - 4294967295
# 
# 일반 인덱스 스캔, 범위 인덱스 스캔 및 인덱스를 사용하지 않으므로 전체 테이블 스캔을 수행하는 조인에 사용되는 버퍼의 최소 크기입니다.
# 일반적으로 빠른 조인을 얻는 가장 좋은 방법은 인덱스를 추가하는 것입니다. join_buffer_size인덱스를 추가 할 수없는 경우 더 빠른 전체 조인을 얻으려면 값을 늘리십시오.
# 두 테이블 사이의 각 전체 결합에 대해 하나의 결합 버퍼가 할당됩니다. 인덱스가 사용되지 않는 여러 테이블 간의 복잡한 조인의 경우 여러 조인 버퍼가 필요할 수 있습니다.
# 블록 중첩 루프 또는 배치 키 액세스 알고리즘을 사용하지 않으면 각 일치하는 행을 보유하는 데 필요한 것보다 큰 버퍼를 설정하면 이득이 없으며
# 모든 조인은 최소 크기를 할당하므로이 변수를 전 세계적으로 큰 가치. 큰 조인을 수행하는 세션에서만 전역 설정을 작게 유지하고 세션 설정을 더 큰 값으로 변경하는 것이 좋습니다.
# 전역 크기가이를 사용하는 대부분의 쿼리에 필요한 것보다 큰 경우 메모리 할당 시간으로 인해 상당한 성능 저하가 발생할 수 있습니다.
# 블록 중첩 루프를 사용하면 첫 번째 테이블의 모든 행에서 필요한 모든 열이 조인 버퍼에 저장 될 때까지 큰 조인 버퍼가 유리할 수 있습니다.
# 이것은 쿼리에 따라 다릅니다. 최적의 크기는 첫 번째 테이블의 모든 행을 보유하는 것보다 작을 수 있습니다.
# 배치 키 액세스를 사용하는 경우 값은 join_buffer_size스토리지 엔진에 대한 각 요청의 키 배치 크기 를 정의합니다.
# 버퍼가 클수록 조인 작업의 오른쪽 테이블에 대한 순차적 액세스가 많아 져 성능이 크게 향상 될 수 있습니다.
# 기본값은 256KB입니다. 최대 허용 설정 join_buffer_size은 4GB-1입니다. 64 비트 플랫폼에는 더 큰 값이 허용됩니다 (64 비트 Windows는 큰 값이 경고와 함께 4GB-1로 잘립니다).
# 조인 버퍼링에 대한 추가 정보는 8.2.1.6 절.“중첩 루프 조인 알고리즘”을 참조하십시오 . 배치 키 액세스에 대한 자세한 내용은 8.2.1.11 절“블록 중첩 루프 및 배치 키 액세스 조인”을 참조하십시오 .
#
# * Apply Option
# join_buffer_size=262144
# 
# --------------------------------------------
# 
# @ large_files_support :
# 
# Property : Value
# System Variable : large_files_support
# Scope : Global
# Dynamic : No
# 
# mysqld가 큰 파일 지원 옵션으로 컴파일되었는지 여부
#
# * Apply Option
# large_files_support=없음. 상태만 확인
# 
# --------------------------------------------
# 
# @ large_pages :
# 
# Property : Value
# Command-Line Format : --large-pages[={OFF|ON}]
# System Variable : large_pages
# Scope : Global
# Dynamic : No
# Platform Specific	Linux
# Type : Boolean
# Default Value : OFF
# 
# 큰 페이지 지원 사용 여부 (--large-pages 옵션 사용) 8.12.4.2 절“대형 페이지 지원 활성화”를 참조하십시오.
#
# * Apply Option
# large_pages=OFF
# 
# --------------------------------------------
# 
# @ large_page_size :
# 
# Property : Value
# System Variable : large_page_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 0
# 
# 큰 페이지 지원이 활성화 된 경우 메모리 페이지 크기가 표시됩니다. 큰 메모리 페이지는 Linux에서만 지원됩니다.
# 다른 플랫폼에서는 이 변수의 값이 항상 0입니다. 8.12.4.2 절“대형 페이지 지원 활성화”를 참조하십시오.
#
# * Apply Option
# large_page_size=0
# 
# --------------------------------------------
# 
# @ last_insert_id :
# 
# LAST_INSERT_ID ()에서 반환 할 값입니다. 테이블을 업데이트하는 명령문에서 LAST_INSERT_ID ()를 사용하면 이진 로그에 저장됩니다.
# 이 변수를 설정해도 mysql_insert_id () C API 함수가 반환 한 값은 업데이트되지 않습니다.
# Auto increment에서 마지막으로 생성한 값을 리턴합니다.
# 
# --------------------------------------------
# 
# @ local_infile :
# 
# Property : Value
# Command-Line Format : --local-infile[={OFF|ON}]
# System Variable : local_infile
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 이 변수는 LOAD DATA 문에 대한 서버 측 LOCAL 기능을 제어합니다. local_infile 설정에 따라 서버는 클라이언트 측에서 LOCAL이 활성화 된 클라이언트의 로컬 데이터로드를 거부하거나 허용합니다.
# 
# 서버가 LOAD DATA LOCAL 문을 명시 적으로 거부하거나 허용하게하려면 각각 local_infile을 비활성화 또는 활성화하여 mysqld를 시작하십시오.
# (클라이언트 프로그램 및 라이브러리가 빌드 시간 또는 런타임에 구성되는 방식에 관계없이).
# local_infile은 런타임에 설정할 수도 있습니다. 자세한 내용은 6.1.6 절.“LOAD DATA LOCAL에 대한 보안 고려 사항”을 참조하십시오.
#
# * Apply Option
# local_infile=ON
# 
# --------------------------------------------
# 
# @ lock_wait_timeout :
# 
# Property : Value
# Command-Line Format : --lock-wait-timeout=#
# System Variable : lock_wait_timeout
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 31536000
# Minimum Value : 1
# Maximum Value : 31536000
# 
# 이 변수는 메타 데이터 잠금 획득 시도에 대한 제한 시간 (초)을 지정합니다. 허용되는 값의 범위는 1-31536000 (1 년)입니다. 기본값은 31536000입니다.
# 
# 이 timeout는 메타 데이터 잠금을 사용하는 모든 명령문에 적용됩니다.
# 여기에는 테이블, 뷰, 저장 프로 시저 및 저장 함수에 대한 DML 및 DDL 작업과 LOCK TABLES, FLUSH TABLES WITH READ LOCK 및 HANDLER 문이 포함됩니다.
# 
# GRANT 또는 REVOKE 문 또는 테이블 로깅 문으로 수정 된 권한 부여 테이블과 같이 mysql 데이터베이스의 시스템 테이블에 대한 암시 적 액세스에는 이 시간 제한이 적용되지 않습니다.
# 시간 종료는 SELECT 또는 UPDATE와 같이 직접 액세스 한 시스템 테이블에 적용됩니다.
# 
# timeout 값은 각 메타 데이터 잠금 시도에 대해 별도로 적용됩니다.
# 주어진 명령문에 둘 이상의 잠금이 필요할 수 있으므로 시간 종료 오류를 보고하기 전에 명령문이 lock_wait_timeout 값보다 길게 차단 될 수 있습니다.
# 잠금 시간 종료가 발생하면 ER_LOCK_WAIT_TIMEOUT이 보고됩니다.
# 
# lock_wait_timeout은 지연된 삽입에는 적용되지 않으며 항상 1 년의 시간 제한으로 실행됩니다.
# 지연된 삽입을 발행하는 세션이 지연된 삽입 제한 시간에 대한 알림을받지 않기 때문에 불필요한 시간 종료를 피하기 위해 수행됩니다.
#
# * Apply Option
# lock_wait_timeout=31536000
# 
# --------------------------------------------
# 
# @ log_error :
# 
# Property : Value
# Command-Line Format : --log-error[=file_name]
# System Variable : log_error
# Scope : Global
# Dynamic : No
# Type : File name
# 
# 오류 로그 출력 대상 대상이 콘솔 인 경우 값은 stderr입니다. 그렇지 않으면 대상은 파일이고 log_error 값은 파일 이름입니다.
# 5.4.2 절.“오류 로그”를 참조하십시오.
#
# * Apply Option
# log_error=/directory/file-name.log
# 
# --------------------------------------------
# 
# @ log_error_verbosity :
# 
# Property : Value
# Command-Line Format : --log-error-verbosity=#
# System Variable : log_error_verbosity
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 3
# Minimum Value : 1
# Maximum Value : 3
# 
# 오류, 경고 및 메모 메시지를 오류 로그에 기록 할 때 서버의 자세한 정보입니다. 다음 표는 허용되는 값을 보여줍니다. 기본값은 3입니다.
# 
# Desired Log Filtering	log_error_verbosity Value
# Error messages	1
# Error and warning messages	2
# Error, warning, and information messages	3
# 
# log_error_verbosity는 MySQL 5.7.2에서 추가되었습니다. 이전 log_warnings 시스템 변수보다 선호되며 대신 사용해야 합니다.
# 해당 변수가 log_error_verbosity와 어떤 관련이 있는지에 대한 정보는 log_warnings에 대한 설명을 참조하십시오.
# 특히, log_warnings에 값을 할당하면 log_error_verbosity에 값이 할당되고 그 반대도 마찬가지입니다.
#
# * Apply Option
# log_error_verbosity=3
# 
# --------------------------------------------
# 
# @ log_output :
# 
# Property : Value
# Command-Line Format : --log-output=name
# System Variable : log_output
# Scope : Global
# Dynamic : Yes
# Type : Set
# Default Value : FILE
# Valid Values  : TABLE, FILE, NONE
# 
# 일반 쿼리 로그 및 느린 쿼리 로그 출력의 대상입니다. 값은 TABLE, FILE 및 NONE에서 선택한 하나 이상의 쉼표로 구분된 단어 목록입니다.
# TABLE은 mysql 시스템 데이터베이스에서 general_log 및 slow_log 테이블에 로깅을 선택합니다. FILE은 로그 파일에 로깅을 선택합니다.
# NONE은 로깅을 비활성화합니다. 값에 NONE이 있으면 존재하는 다른 단어보다 우선합니다.
# TABLE 및 FILE 모두 로그 출력 대상을 모두 선택하도록 제공 될 수 있습니다.
# 
# 이 변수는 로그 출력 대상을 선택하지만 로그 출력을 활성화하지는 않습니다. 그렇게하려면 general_log 및 slow_query_log 시스템 변수를 활성화하십시오.
# FILE 로깅의 경우 general_log_file 및 slow_query_log_file 시스템 변수가 로그 파일 위치를 결정합니다.
# 자세한 내용은 5.4.1 절“일반 쿼리 로그 및 느린 쿼리 로그 출력 대상 선택”을 참조하십시오.
#
# * Apply Option
# log_output=FILE
# 
# --------------------------------------------
# 
# @ log_syslog :
# 
# Property : Value
# Command-Line Format : --log-syslog[={OFF|ON}]
# System Variable : log_syslog
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : (Windows) - ON
# Default Value : (Unix) - OFF
# 오류 로그 출력을 시스템 로그에 쓸지 여부. 이것은 Windows의 이벤트 로그이고 Unix 및 Unix 계열 시스템의 syslog입니다. 기본값은 플랫폼마다 다릅니다.
# 
# - Windows에서는 기본적으로 이벤트 로그 출력이 사용됩니다.
# - Unix 및 Unix 계열 시스템에서 syslog 출력은 기본적으로 비활성화되어 있습니다.
# 
# 기본값에 관계없이 지원되는 모든 플랫폼에서 출력을 제어하도록 log_syslog를 명시적으로 설정할 수 있습니다.
# 시스템 로그 출력 제어는 파일이나 콘솔로 오류 출력을 보내는 것과 다릅니다.
# 원하는대로 시스템 로그와 함께 또는 시스템 로그 대신 파일이나 콘솔로 오류 출력을 보낼 수 있습니다. 5.4.2 절.“오류 로그”를 참조하십시오.
#
# * Apply Option
# log_syslog=ON
# 
# --------------------------------------------
# 
# @ log_syslog_tag :
# 
# Property : Value
# Command-Line Format : --log-syslog-tag=tag
# System Variable : log_syslog_tag
# Scope : Global
# Dynamic : Yes
# Type : String
# Default Value : empty string
# syslog에 기록 된 오류 로그 출력에서 ​​서버 식별자에 추가 할 태그입니다.
# log_syslog 시스템 변수가 사용 가능하지 않으면이 변수가 적용되지 않습니다.
# 5.4.2.3 절.“시스템 로그에 오류 기록”을 참조하십시오.
# 
# 기본적으로 서버 식별자는 태그가없는 mysqld입니다.
# 태그의 태그 값이 지정되면, 앞에 하이픈이있는 서버 식별자에 추가되어 mysqld-tag의 식별자가됩니다.
# 
# Windows에서 아직 존재하지 않는 태그를 사용하려면 태그에 대한 레지스트리 항목을 작성할 수 있도록 관리자 권한이있는 계정에서 서버를 실행해야합니다.
# 태그가 이미 존재하면 높은 권한이 필요하지 않습니다.
#
# * Apply Option
# log_syslog_tag=tag_name
# 
# --------------------------------------------
# 
# @ lower_case_table_names :
# 
# Property : Value
# Command-Line Format : --lower-case-table-names[=#]
# System Variable : lower_case_table_names
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 2
# 
# 0으로 설정하면 테이블 이름이 지정된대로 저장되고 비교는 대소 문자를 구분합니다.
# 1로 설정하면 테이블 이름이 디스크에서 소문자로 저장되며 비교는 대소 문자를 구분하지 않습니다. 2로 설정하면 테이블 이름이 주어진대로 저장되지만 소문자로 비교됩니다.
# 이 옵션은 데이터베이스 이름 및 테이블 별명에도 적용됩니다. 자세한 내용은 9.2.3 절“식별자 대 / 소문자 구분”을 참조하십시오.
# 
# Windows에서 기본값은 1입니다. macOS에서 기본값은 2입니다. Linux에서 값 2는 지원되지 않습니다. 서버는 대신 값을 0으로 설정합니다.
# 
# 데이터 디렉토리가 대소 문자를 구분하지 않는 파일 시스템 (예 : Windows 또는 macOS)에있는 시스템에서 MySQL을 실행중인 경우 lower_case_table_names를 0으로 설정하지 않아야합니다.
# tbl_name 소문자가 잘못된 tbl_name 소문자로 INSERT INTO ... SELECT ... FROM tbl_name 작업을 실행할 때 정지 상태가 될 수있는 지원되지 않는 조합입니다.
# MyISAM을 사용하면 다른 소문자를 사용하여 테이블 이름에 액세스하면 인덱스가 손상 될 수 있습니다.
# 
# 대소 문자를 구분하지 않는 파일 시스템에서 --lower_case_table_names = 0으로 서버를 시작하려고하면 오류 메시지가 인쇄되고 서버가 종료됩니다.
# 
# InnoDB 테이블을 사용하는 경우 모든 플랫폼에서이 변수를 1로 설정하여 이름을 소문자로 강제 변환해야합니다.
# 
# 이 변수의 설정은 대소 문자 구분과 관련하여 복제 필터링 옵션의 동작에 영향을줍니다. 자세한 내용은 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
#
# * Apply Option
# lower_case_table_names=0
# 
# --------------------------------------------
# 
# @ max_allowed_packet :
# 
# Property : Value
# Command-Line Format : --max-allowed-packet=#
# System Variable : max_allowed_packet
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 4194304
# Minimum Value : 1024
# Maximum Value : 1073741824
# 하나의 패킷 또는 생성 / 중간 문자열 또는 mysql_stmt_send_long_data () C API 함수가 전송 한 매개 변수의 최대 크기입니다. 기본값은 4MB입니다.
# 
# 패킷 메시지 버퍼는 net_buffer_length 바이트로 초기화되지만 필요한 경우 max_allowed_packet 바이트까지 커질 수 있습니다. 큰 (아마도 잘못된) 패킷을 포착하기 위해이 값은 기본적으로 작습니다.
# 
# 큰 BLOB 열 또는 긴 문자열을 사용하는 경우이 값을 늘려야합니다. 사용하려는 최대 BLOB만큼 커야합니다.
# max_allowed_packet의 프로토콜 제한은 1GB입니다. 값은 1024의 배수 여야합니다. 비다 중은 가장 가까운 배수로 내림됩니다.
# 
# max_allowed_packet 변수의 값을 변경하여 메시지 버퍼 크기를 변경할 때 클라이언트 프로그램이 허용하는 경우 클라이언트 측의 버퍼 크기도 변경해야합니다.
# 클라이언트 라이브러리에 내장 된 기본 max_allowed_packet 값은 1GB이지만 개별 클라이언트 프로그램이이를 무시할 수 있습니다. 예를 들어, mysql 및 mysqldump의 기본값은 각각 16MB 및 24MB입니다.
# 또한 명령 행 또는 옵션 파일에서 max_allowed_packet을 설정하여 클라이언트 측 값을 변경할 수 있습니다.
# 
# 이 변수의 세션 값은 읽기 전용입니다. 클라이언트는 세션 값만큼 많은 바이트를 수신 할 수 있습니다. 그러나 서버는 현재 전역 max_allowed_packet 값보다 많은 바이트를 클라이언트에 보내지 않습니다.
# (클라이언트가 연결 한 후 전역 값이 변경되면 전역 값이 세션 값보다 작을 수 있습니다.)
#
# * Apply Option
# max_allowed_packet=4194304
# 
# --------------------------------------------
# 
# @ max_connect_errors :
# 
# Property : Value
# Command-Line Format : --max-connect-errors=#
# System Variable : max_connect_errors
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 100
# Minimum Value : 1
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# max_connect_errors 성공적인 연결없이 호스트의 연속 연결 요청이 중단 된 후 서버는 해당 호스트가 추가 연결을 차단합니다.
# 이전 연결이 중단 된 후 max_connect_errors 시도 미만으로 호스트의 연결이 성공적으로 설정되면 호스트의 오류 수가 0으로 지워집니다.
# 그러나 일단 호스트가 차단되면 호스트 캐시를 비우는 것이 호스트를 차단 해제하는 유일한 방법입니다. 호스트 캐시를 비우려면 FLUSH HOSTS 문,
# 성능 스키마 host_cache 테이블을 자르는 TRUNCATE TABLE 문 또는 mysqladmin flush-hosts 명령을 실행하십시오.
# 
# 호스트 캐시 작동 방법에 대한 자세한 내용은 8.12.5.2 절“DNS 조회 최적화 및 호스트 캐시”를 참조하십시오.
#
# * Apply Option
# max_connect_errors=100
# 
# --------------------------------------------
# 
# @ max_connections :
# 
# Property : Value
# Command-Line Format : --max-connections=#
# System Variable : max_connections
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 151
# Minimum Value : 1
# Maximum Value : 100000
# 허용되는 최대 동시 클라이언트 연결 수입니다. 자세한 내용은 8.12.5.1 절 "MySQL이 클라이언트 연결을 처리하는 방법" 을 참조하십시오.
#
# * Apply Option
# max_connections=151
# 
# --------------------------------------------
# 
# @ max_digest_length :
# 
# Property : Value
# Command-Line Format : --max-digest-length=#
# System Variable : max_digest_length
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 1024
# Minimum Value : 0
# Maximum Value : 1048576
# 정규화 된 명령문 요약 계산을 위해 세션 당 예약 된 최대 메모리 바이트 수입니다. 다이제스트 계산 중에 해당 공간이 사용되면 잘림이 발생합니다.
# 구문 분석 된 명령문의 더 이상 토큰이 수집되거나 다이제스트 값으로 계산되지 않습니다.
# 구문 분석 된 토큰의 많은 바이트 후에 만 ​​다른 명령문은 동일한 정규화 된 명령문 다이제스트를 생성하며 비교 또는 집계 통계에 대해 집계 된 경우 동일한 것으로 간주됩니다.
# 
# max_digest_length 값을 줄이면 메모리 사용이 줄어들지 만 더 많은 명령문의 다이제스트 값이 끝에서만 다를 경우 구별 할 수 없게됩니다.
# 값을 늘리면 더 긴 명령문을 구별 할 수 있지만 특히 동시 세션이 많은 워크로드 (서버가 세션 당 max_digest_length 바이트를 할당 함)의 경우 메모리 사용이 증가합니다.
# 
# 파서는이 시스템 변수를 계산하는 정규화 된 명령문 요약의 최대 길이에 대한 한계로 사용합니다. 명령문 스키마를 추적하는 경우 성능 스키마는
# performance_schema_max_digest_length를 사용하여 요약 값의 사본을 작성합니다.
# 저장하는 다이제스트의 최대 길이에 대한 제한으로 시스템 변수. 따라서 performance_schema_max_digest_length가 max_digest_length보다 작으면
# Performance Schema에 저장된 다이제스트 값이 원래 다이제스트 값에 비해 잘립니다.
# 
# 명령문 다이제스트에 대한 자세한 내용은 25.10 절“성능 스키마 구문 요약”을 참조하십시오.
#
# * Apply Option
# max_digest_length=1024
# 
# --------------------------------------------
# 
# @ max_error_count :
# 
# Property : Value
# Command-Line Format : --max-error-count=#
# System Variable : max_error_count
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 64
# Minimum Value : 0
# Maximum Value : 65535
# SHOW ERRORS 및 SHOW WARNINGS 문으로 표시하기 위해 저장할 최대 오류, 경고 및 정보 메시지 수. 이는 진단 영역의 조건 영역 수와 동일하므로 GET DIAGNOSTICS로 검사 할 수있는 조건 수와 동일합니다.
#
# * Apply Option
# max_error_count=64
# 
# --------------------------------------------
# 
# @ max_execution_time :
# 
# Property : Value
# Command-Line Format : --max-execution-time=#
# System Variable : max_execution_time
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# SELECT 문의 실행 시간 초과 (밀리 초) 값이 0이면 시간 초과가 활성화되지 않습니다.
# 
# max_execution_time은 다음과 같이 적용됩니다.
# 
# - 글로벌 max_execution_time 값은 새 연결의 세션 값에 대한 기본값을 제공합니다.
# 세션 값은 MAX_EXECUTION_TIME (N) 옵티 마이저 힌트가 없거나 N이 0인 세션 내에서 실행 된 SELECT 실행에 적용됩니다.
# - max_execution_time은 읽기 전용 SELECT 문에 적용됩니다. 읽기 전용이 아닌 명령문은 데이터를 부작용으로 수정하는 저장 함수를 호출하는 명령문입니다.
# - 저장된 프로그램의 SELECT 문에 대해 max_execution_time이 무시됩니다.
#
# * Apply Option
# join_buffemax_execution_timer_size=0
# 
# --------------------------------------------
# 
# @ max_length_for_sort_data :
# 
# Property : Value
# Command-Line Format : --max-length-for-sort-data=#
# System Variable : max_length_for_sort_data
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 1024
# Minimum Value : 4
# Maximum Value : 8388608
# 
# 사용할 파일 정렬 알고리즘을 결정하는 인덱스 값 크기의 컷오프입니다. 8.2.1.14 절“ORDER BY 최적화”를 참조하십시오.
#
# * Apply Option
# max_length_for_sort_data=1024
# 
# --------------------------------------------
# 
# @ max_prepared_stmt_count :
# 
# Property : Value
# Command-Line Format : --max-prepared-stmt-count=#
# System Variable : max_prepared_stmt_count
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 16382
# Minimum Value : 0
# Maximum Value : 1048576
# 이 변수는 서버에서 준비된 명령문의 총 수를 제한합니다. 서버는 많은 수의 명령문을 준비하여 메모리 부족 서버를 실행하여 서비스 거부 공격이 발생할 수있는 환경에서 사용할 수 있습니다.
# 값이 현재 준비된 명령문 수보다 낮게 설정되면 기존 명령문은 영향을받지 않고 사용할 수 있지만 현재 수가 한계 아래로 떨어질 때까지 새 명령문을 준비 할 수 없습니다.
# 값을 0으로 설정하면 준비된 명령문이 비활성화됩니다.
#
# * Apply Option
# max_prepared_stmt_count=16382
# 
# --------------------------------------------
# 
# @ max_sort_length :
# 
# Property : Value
# Command-Line Format : --max-sort-length=#
# System Variable : max_sort_length
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 1024
# Minimum Value : 4
# Maximum Value : 8388608
# 
# 데이터 값을 정렬 할 때 사용할 바이트 수입니다. 서버는 각 값의 첫 번째 max_sort_length 바이트 만 사용하고 나머지는 무시합니다.
# 결과적으로, 첫 번째 max_sort_length 바이트 이후에만 다른 값은 GROUP BY, ORDER BY 및 DISTINCT 조작에서 동일한 것으로 비교됩니다.
# 
# max_sort_length의 값을 늘리려면 sort_buffer_size의 값을 늘려야 할 수도 있습니다. 자세한 내용은 8.2.1.14 절“ORDER BY 최적화”를 참조하십시오.
#
# * Apply Option
# max_sort_length=1024
# 
# --------------------------------------------
# 
# @ max_user_connections :
# 
# Property : Value
# Command-Line Format : --max-user-connections=#
# System Variable : max_user_connections
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 4294967295
#
# 지정된 MySQL 사용자 계정에 허용되는 최대 동시 연결 수 값 0 (기본값)은 "제한 없음"을 의미합니다.
# 이 변수에는 서버 시작 또는 런타임시 설정할 수있는 전역 값이 있습니다. 또한 현재 세션과 연결된 계정에 적용되는 유효 동시 연결 제한을 나타내는 읽기 전용 세션 값이 있습니다.
# 세션 값은 다음과 같이 초기화됩니다.
# - 사용자 계정에 MAX_USER_CONNECTIONS 리소스 제한이 0이 아닌 경우 max_user_connections 세션 값이 해당 제한으로 설정됩니다.
# - 그렇지 않으면 세션 max_user_connections 값이 글로벌 값으로 설정됩니다.
# 계정 자원 한계는 CREATE USER 또는 ALTER USER 문을 사용하여 지정됩니다. 6.2.16 절“계정 자원 제한 설정”을 참조하십시오.
#
# * Apply Option
# max_user_connections=0
# 
# --------------------------------------------
# 
# @ net_buffer_length :
# 
# Property : Value
# Command-Line Format : --net-buffer-length=#
# System Variable : net_buffer_length
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 16384
# Minimum Value : 1024
# Maximum Value : 1048576
#
# 각 클라이언트 스레드는 연결 버퍼 및 결과 버퍼와 연결됩니다. 둘 다 net_buffer_length에 의해 주어진 크기로 시작하지만 필요에 따라 max_allowed_packet 바이트까지 동적으로 확장됩니다.
# 결과 버퍼는 각 SQL 문 후에 net_buffer_length로 축소됩니다.
# 이 변수는 일반적으로 변경되지 않아야하지만 메모리가 매우 적은 경우 클라이언트가 보낸 예상 명령문 길이로 설정할 수 있습니다. 명령문이이 길이를 초과하면 연결 버퍼가 자동으로 확대됩니다.
# net_buffer_length를 설정할 수있는 최대 값은 1MB입니다.
# 이 변수의 세션 값은 읽기 전용입니다.
#
# * Apply Option
# net_buffer_length=16384
# 
# --------------------------------------------
# 
# @ net_read_timeout :
# 
# Property : Value
# Command-Line Format : --net-read-timeout=#
# System Variable : net_read_timeout
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 30
# Minimum Value : 1
# 
# 읽기를 중단하기 전에 연결에서 더 많은 데이터를 기다리는 시간 (초)입니다. 서버가 클라이언트에서 읽을 때 net_read_timeout은 중단시기를 제어하는 ​​시간 초과 값입니다.
# 서버가 클라이언트에 쓸 때 net_write_timeout은 중단시기를 제어하는 ​​시간 초과 값입니다. slave_net_timeout도 참조하십시오.
#
# * Apply Option
# net_read_timeout=30
# 
# --------------------------------------------
# 
# @ net_retry_count :
# 
# Property : Value
# Command-Line Format : --net-retry-count=#
# System Variable : net_retry_count
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 10
# Minimum Value : 1
# Maximum Value : (64-bit platforms)- 18446744073709551615
# Maximum Value : (32-bit platforms)- 4294967295
# 통신 포트의 읽기 또는 쓰기가 중단 된 경우 포기하기 전에이 작업을 여러 번 다시 시도하십시오. 내부 인터럽트가 모든 스레드로 전송되므로이 값은 FreeBSD에서 상당히 높게 설정되어야합니다.
#
# * Apply Option
# net_retry_count=10
# 
# --------------------------------------------
# 
# @ net_write_timeout :
# 
# Property : Value
# Command-Line Format : --net-write-timeout=#
# System Variable : net_write_timeout
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 60
# Minimum Value : 1
# 쓰기를 중단하기 전에 블록이 연결에 쓰여질 때까지 대기하는 시간 (초)입니다. net_read_timeout도 참조하십시오.
#
# * Apply Option
# net_write_timeout=60
# 
# --------------------------------------------
# 
# @ offline_mode :
# 
# Property : Value
# Command-Line Format : --offline-mode[={OFF|ON}]
# System Variable : offline_mode
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
#
# 서버가 "오프라인 모드"에 있는지 여부는 다음과 같은 특징이 있습니다.
# - SUPER 권한이없는 연결된 클라이언트 사용자는 다음 오류시 연결이 끊어지며 적절한 오류가 발생합니다. 연결 해제에는 실행 명령문 종료 및 잠금 해제가 포함됩니다.
# 이러한 클라이언트는 새 연결을 시작할 수 없으며 적절한 오류를 수신합니다.
# - SUPER 권한이있는 연결된 클라이언트 사용자는 연결이 끊어지지 않으며 새 연결을 시작하여 서버를 관리 할 수 ​​있습니다.
# - 복제 슬레이브 스레드는 서버에 데이터를 계속 적용 할 수 있습니다.
# 
# SUPER 권한이있는 사용자 만 오프라인 모드를 제어 할 수 있습니다. 서버를 오프라인 모드로 설정하려면 offline_mode 시스템 변수의 값을 OFF에서 ON으로 변경하십시오.
# 정상 작동을 재개하려면 offline_mode를 ON에서 OFF로 변경하십시오. 오프라인 모드에서 액세스가 거부 된 클라이언트는 ER_SERVER_OFFLINE_MODE 오류를 수신합니다.
#
# * Apply Option
# offline_mode=OFF
# 
# --------------------------------------------
# 
# @ open_files_limit :
# 
# Property : Value
# Command-Line Format : --open-files-limit=#
# System Variable : open_files_limit
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 5000, with possible adjustment
# Minimum Value : 0
# Maximum Value : platform dependent
#
# 운영 체제에서 mysqld에 사용 가능한 파일 디스크립터 수 mysqld는이 변수를 직접 설정하거나 --open-files-limit 옵션을 mysqld_safe로 설정하여
# 시작시 요청 된 값을 사용하여 setrlimit ()를 사용하여 설명자를 예약합니다.
# mysqld에서 Too many open files 오류가 발생하면 open_files_limit 값을 늘리십시오. 내부적으로이 변수의 최대 값은 부호없는 최대 정수 값이지만 실제 최대 값은 플랫폼에 따라 다릅니다.
# 
# 런타임시 open_files_limit 값은 운영 체제에서 mysqld에 실제로 허용 된 파일 디스크립터 수를 나타내며 시작시 요청 된 값과 다를 수 있습니다.
# 시작하는 동안 요청 된 파일 디스크립터 수를 할당 할 수없는 경우 mysqld는 오류 로그에 경고를 씁니다.
# 
# 유효한 open_files_limit 값은 다음 공식을 사용하여 시스템 시작시 지정된 값 (있는 경우)과 max_connections 및 table_open_cache의 값을 기반으로합니다.
# - 10 + max_connections + (table_open_cache * 2)
# - max_connections * 5
# - 한계가 양수이지만 무한대가 아닌 경우 운영 체제 한계
# - 운영 체제 한계가 무한대 인 경우 : 시작시 지정된 경우 open_files_limit 값, 그렇지 않은 경우 5000
# 
# 서버는 최대 값을 사용하여 파일 디스크립터 수를 얻으려고 시도합니다. 해당 디스크립터를 확보 할 수없는 경우, 서버는 시스템이 허용하는 수만큼을 확보하려고 시도합니다.
# 
# MySQL이 열린 파일 수를 변경할 수 없는 시스템에서는 유효 값이 0입니다.
# 
# Unix에서는 값을 ulimit -n보다 크게 설정할 수 없습니다.
#
# * Apply Option
# open_files_limit=5000
# 
# --------------------------------------------
# 
# @ plugin_dir :
# 
# Property : Value
# Command-Line Format : --plugin-dir=dir_name
# System Variable : plugin_dir
# Scope : Global
# Dynamic : No
# Type : Directory name
# Default Value : BASEDIR/lib/plugin
# 플러그인 디렉토리의 경로 이름입니다.
# 
# 플러그인 디렉토리가 서버에 의해 쓰기 가능한 경우, 사용자는 SELECT ... INTO DUMPFILE을 사용하여 디렉토리의 파일에 실행 가능 코드를 쓸 수 있습니다.
# 이는 plugin_dir을 서버로만 읽도록하거나 secure_file_priv를 SELECT 쓰기가 안전하게 수행 될 수있는 디렉토리로 설정하여 방지 할 수 있습니다.
#
# * Apply Option
# plugin_dir=BASEDIR/lib/plugin
# 
# --------------------------------------------
# 
# @ preload_buffer_size :
# 
# Property : Value
# Command-Line Format : --preload-buffer-size=#
# System Variable : preload_buffer_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 32768
# Minimum Value : 1024
# Maximum Value : 1073741824
# 
# 인덱스를 사전로드 할 때 할당되는 버퍼의 크기입니다.
#
# * Apply Option
# preload_buffer_size=32768
# 
# --------------------------------------------
# 
# @ range_alloc_block_size :
# 
# Property : Value
# Command-Line Format : --range-alloc-block-size=#
# System Variable : range_alloc_block_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 4096
# Minimum Value : 4096
# Maximum Value : (64-bit platforms) - 18446744073709547520
# Maximum Value : 4294967295
# Block Size	1024
# 
# 범위 최적화를 수행 할 때 할당되는 블록의 크기입니다.
#
# * Apply Option
# range_alloc_block_size=4096
# 
# --------------------------------------------
# 
# @ range_optimizer_max_mem_size :
# 
# Property : Value
# Command-Line Format : --range-optimizer-max-mem-size=#
# System Variable : range_optimizer_max_mem_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : (≥ 5.7.12) - 8388608
# Default Value : (≤ 5.7.11) - 1536000
# Minimum Value : 0
# Maximum Value : 18446744073709551615
# 
# 범위 최적화 프로그램의 메모리 소비 한도. 값이 0이면 "제한 없음"을 의미합니다.
# 옵티마이 저가 고려한 실행 계획이 범위 액세스 방법을 사용하지만 옵티마이 저는이 방법에 필요한 메모리 양이 한계를 초과 할 것으로 예상하면 계획을 포기하고 다른 계획을 고려합니다.
# 자세한 내용은 범위 최적화를위한 메모리 사용 제한을 참조하십시오.
#
# * Apply Option
# range_optimizer_max_mem_size=1536000
# 
# --------------------------------------------
# 
# @ rbr_exec_mode :
# 
# Property : Value
# System Variable : rbr_exec_mode
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : STRICT
# Valid Values  : IDEMPOTENT, STRICT
# 
# mysqlbinlog에 의한 내부 용. 이 변수는 서버를 IDEMPOTENT 모드와 STRICT 모드 사이에서 전환합니다.
# IDEMPOTENT 모드는 mysqlbinlog에 의해 생성 된 BINLOG 문에서 중복 키 및 키가없는 오류를 억제합니다.
# 이 모드는 기존 데이터와 충돌을 일으키는 서버에서 행 기반 이진 로그를 재생할 때 유용합니다. mysqlbinlog는 다음을 출력에 써서 --idempotent 옵션을 지정할 때이 모드를 설정합니다.
# 
# SET SESSION RBR_EXEC_MODE=IDEMPOTENT;
#
# * Apply Option
# rbr_exec_mode=STRICT
# 
# --------------------------------------------
# 
# read_buffer_size
# 
# Command-Line Format	--read-buffer-size=#
# System Variable	read_buffer_size
# Scope	Global, Session
# Dynamic	Yes
# Type	Integer
# Default Value	131072
# Minimum Value	8192
# Maximum Value	2147479552
# 
# MyISAM 테이블에 대한 순차 스캔을 수행하는 각 스레드는 스캔하는 각 테이블에 대해이 크기 (바이트)의 버퍼를 할당합니다. 순차 스캔을 여러 번 수행하는 경우이 값을 늘릴 수 있습니다.
# 기본값은 131072입니다. 이 변수의 값은 4KB의 배수여야 합니다. 4KB의 배수가 아닌 값으로 설정된 경우 해당 값은 가장 가까운 4KB의 배수로 내림됩니다.
# 
# 이 옵션은 모든 스토리지 엔진에 대해 다음 컨텍스트에서도 사용됩니다.
# * ORDER BY에 대한 행을 정렬 할 때 임시 파일 (임시 테이블이 아님)에 인덱스를 캐싱합니다.
# * 파티션에 대량 삽입하는 경우.
# * 중첩 된 쿼리 결과를 캐싱합니다.
# 
# read_buffer_size는 MEMORY 테이블의 메모리 블록 크기를 결정하는 다른 스토리지 엔진별 방법으로도 사용됩니다.
# 
# 다른 작업 중 메모리 사용에 대한 자세한 내용은 8.12.4.1 절.“MySQL이 메모리를 사용하는 방법”을 참조하십시오.
# 
# --------------------------------------------
# 
# @ read_rnd_buffer_size :
# 
# Property : Value
# Command-Line Format : --read-rnd-buffer-size=#
# System Variable : read_rnd_buffer_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 262144
# Minimum Value : 1
# Maximum Value : 2147483647
#
# 이 변수는 MyISAM 테이블에서 읽기 및 모든 스토리지 엔진에서 다중 범위 읽기 최적화에 사용됩니다.
# 
# 키 정렬 작업 후에 MyISAM 테이블에서 행을 정렬 된 순서로 읽을 때 디스크 검색을 피하기 위해이 버퍼를 통해 행을 읽습니다. 8.2.1.14 절“ORDER BY 최적화”를 참조하십시오.
# 변수를 큰 값으로 설정하면 ORDER BY 성능을 크게 향상시킬 수 있습니다. 그러나 이것은 각 클라이언트에 할당 된 버퍼이므로 전역 변수를 큰 값으로 설정해서는 안됩니다.
# 대신 큰 쿼리를 실행해야하는 클라이언트 내에서만 세션 변수를 변경하십시오.
# 
# 다른 작업 중 메모리 사용에 대한 자세한 내용은 8.12.4.1 절“MySQL에서 메모리를 사용하는 방법”을 참조하십시오.
# 다중 범위 읽기 최적화에 대한 자세한 내용은 8.2.1.10 절.“다중 범위 읽기 최적화”를 참조하십시오.
#
# * Apply Option
# read_rnd_buffer_size=262144
# 
# --------------------------------------------
# 
# @ require_secure_transport :
# 
# Property : Value
# Command-Line Format : --require-secure-transport[={OFF|ON}]
# System Variable : require_secure_transport
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 서버에 대한 클라이언트 연결이 특정 형태의 보안 전송을 사용해야하는지 여부 이 변수를 사용하면 서버는 SSL을 사용하는 TCP/IP 연결 또는 소켓 파일(Unix)
# 또는 공유 메모리 (Windows)를 사용하는 연결 만 허용합니다.
# 서버는 비보안 연결 시도를 거부하며 ER_SECURE_TRANSPORT_REQUIRED 오류로 실패합니다.
# 
# 이 기능은 계정 별 SSL 요구 사항을 보완하며 우선 순위가 높습니다.
# 예를 들어, 계정이 REQUIRE SSL로 정의 된 경우 require_secure_transport를 활성화해도 계정을 사용하여 Unix 소켓 파일을 사용하여 연결할 수 없습니다.
# 
# 서버에 사용 가능한 보안 전송이 없을 수 있습니다. 예를 들어, Windows의 서버는 SSL 인증서 또는 키 파일을 지정하지 않고
# shared_memory 시스템 변수를 사용하지 않고 시작한 경우 보안 전송을 지원하지 않습니다.
# 이러한 조건에서 시작시 require_secure_transport를 사용 가능하게하면 서버가 오류 로그에 메시지를 작성하고 종료합니다.
# 런타임시 변수를 활성화하려고하면 ER_NO_SECURE_TRANSPORTS_CONFIGURED 오류와 함께 실패합니다.
# 
# 암호화 된 연결을 필수로 하는 구성을 참조하십시오.
#
# * Apply Option
# require_secure_transport=OFF
# 
# --------------------------------------------
# 
# @ secure_file_priv :
# 
# Property : Value
# Command-Line Format : --secure-file-priv=dir_name
# System Variable : secure_file_priv
# Scope : Global
# Dynamic : No
# Type : String
# Default Value : platform specific
# Valid Values  : empty string, dirname, NULL
# 
# 이 변수는 LOAD DATA 및 SELECT ... INTO OUTFILE 문 및 LOAD_FILE () 함수에 의해 수행되는 것과 같은 데이터 가져 오기 및 내보내기 조작의 영향을 제한하는 데 사용됩니다.
# 이 작업은 FILE 권한이있는 사용자에게만 허용됩니다.
# 
# secure_file_priv는 다음과 같이 설정 될 수 있습니다.
# 
# - 비어 있으면 변수가 적용되지 않습니다. 이것은 안전한 설정이 아닙니다.
# - 디렉토리 이름으로 설정된 경우, 서버는 가져 오기 및 내보내기 조작이 해당 디렉토리의 파일에 대해서만 작동하도록 제한합니다. 디렉토리가 존재해야합니다. 서버는 서버를 만들지 않습니다.
# - NULL로 설정하면 서버가 가져 오기 및 내보내기 작업을 비활성화합니다.
#
# * Apply Option
# secure_file_priv=platform specific
# 
# --------------------------------------------
# 
# @ show_create_table_verbosity :
# 
# Property : Value
# Command-Line Format : --show-create-table-verbosity[={OFF|ON}]
# Introduced	5.7.22
# System Variable : show_create_table_verbosity
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 행 형식이 기본 형식인 경우 SHOW CREATE TABLE은 일반적으로 ROW_FORMAT 테이블 옵션을 표시하지 않습니다. 이 변수를 활성화하면 기본 형식인지 여부에 관계없이 SHOW CREATE TABLE에 ROW_FORMAT이 표시됩니다.
#
# * Apply Option
# show_create_table_verbosity=OFF
# 
# --------------------------------------------
# 
# @ skip_name_resolve :
# 
# Property : Value
# Command-Line Format : --skip-name-resolve[={OFF|ON}]
# System Variable : skip_name_resolve
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : OFF
# 
# 클라이언트 연결을 확인할 때 호스트 이름을 확인할지 여부입니다. 이 변수가 OFF이면 클라이언트 연결을 확인할 때 mysqld가 호스트 이름을 확인합니다. ON이면 mysqld는 IP 번호 만 사용합니다.
# 이 경우 권한 부여 테이블의 모든 호스트 열 값은 IP 주소 여야합니다. 8.12.5.2 절“DNS 조회 최적화 및 호스트 캐시”를 참조하십시오.
# 
# 시스템의 네트워크 구성 및 계정의 호스트 값에 따라 --host = 127.0.0.1 또는 --host = :: 1과 같은 명시적인 --host 옵션을 사용하여 클라이언트를 연결해야 할 수도 있습니다.
# 
# 호스트 127.0.0.1에 대한 연결 시도는 일반적으로 localhost 계정으로 해결됩니다. 그러나 skip_name_resolve를 사용하여 서버를 실행하면 실패합니다.
# 그렇게 하려면 연결을 수락 할 수있는 계정이 있는지 확인하십시오. 예를 들어 --host = 127.0.0.1 또는 --host = :: 1을 사용하여 루트로 연결하려면 다음 계정을 만드십시오.
# CREATE USER 'root'@'127.0.0.1' IDENTIFIED BY 'root-password';
# CREATE USER 'root'@'::1' IDENTIFIED BY 'root-password';
#
# * Apply Option
# skip_name_resolve=OFF
# 
# --------------------------------------------
# 
# @ skip_networking :
# 
# Property : Value
# Command-Line Format : --skip-networking[={OFF|ON}]
# System Variable : skip_networking
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : OFF
# 
# 이 변수는 서버가 TCP / IP 연결을 허용하는지 여부를 제어합니다. 기본적으로 비활성화되어 있습니다 (TCP 연결 허용).
# 활성화 된 경우 서버는 로컬 (TCP / IP가 아닌) 연결 만 허용하며 mysqld와의 모든 상호 작용은 명명 된 파이프 또는 공유 메모리 (Windows) 또는 Unix 소켓 파일 (Unix)을 사용하여 이루어져야합니다.
# 이 옵션은 로컬 클라이언트 만 허용되는 시스템에 권장됩니다. 8.12.5.2 절“DNS 조회 최적화 및 호스트 캐시”를 참조하십시오.
#
# * Apply Option
# skip_networking=OFF
# 
# --------------------------------------------
# 
# @ skip_show_database :
# 
# Property : Value
# Command-Line Format : --skip-show-database
# System Variable : skip_show_database
# Scope : Global
# Dynamic : No
# 
# 이것은 사람들이 SHOW DATABASES 권한이 없는 경우 SHOW DATABASES 문을 사용하지 못하게합니다. 사용자가 다른 사용자에게 속한 데이터베이스를 볼 수 있다는 우려가있는 경우 보안을 향상시킬 수 있습니다.
# 그 효과는 SHOW DATABASES 권한에 따라 다릅니다. 변수 값이 ON이면 SHOW DATABASES 권한이있는 사용자에게만 SHOW DATABASES 문이 허용되며 명령문은 모든 데이터베이스 이름을 표시합니다.
# 값이 OFF이면 SHOW DATABASES가 모든 사용자에게 허용되지만 SHOW DATABASES 또는 기타 권한이있는 데이터베이스의 이름만 표시합니다.
#
# * Apply Option
# skip_show_database=none
# 
# --------------------------------------------
# 
# @ sort_buffer_size :
# 
# Property : Value
# Command-Line Format : --sort-buffer-size=#
# System Variable : sort_buffer_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 262144
# Minimum Value : 32768
# Maximum Value : (Other, 64-bit platforms) - 18446744073709551615
# Maximum Value : (Other, 32-bit platforms) - 4294967295
# Maximum Value : (Windows) - 4294967295
# 
# 
# 정렬을 수행해야하는 각 세션은이 크기의 버퍼를 할당합니다. sort_buffer_size는 스토리지 엔진에만 국한되지 않으며 일반적인 최적화 방법으로 적용됩니다.
# 최소한 sort_buffer_size 값은 정렬 버퍼에서 15 개의 튜플을 수용 할 수있을만큼 커야합니다. 
# 또한 max_sort_length의 값을 늘리려면 sort_buffer_size의 값을 늘려야 할 수 있습니다. 자세한 내용은 8.2.1.14 절“ORDER BY 최적화”를 참조하십시오.
# 
# SHOW GLOBAL STATUS 출력에 초당 많은 Sort_merge_passes가 표시되면 sort_buffer_size 값을 늘려서 쿼리 최적화나 향상된 인덱싱으로 개선할 수 없는
# ORDER BY 또는 GROUP BY 작업의 속도를 높일 수 있습니다.
# 
# 옵티마이 저는 필요한 공간을 계산하려고 시도하지만 한계까지 더 많이 할당 할 수 있습니다. 전역 적으로 필요한 것보다 크게 설정하면 정렬하는 대부분의 쿼리 속도가 느려집니다.
# 세션 설정으로 늘리고 더 큰 크기가 필요한 세션에 대해서만 늘리는 것이 가장 좋습니다. Linux에는 256KB 및 2MB의 임계 값이 있으며,
# 이 값이 클수록 메모리 할당 속도가 크게 느려질 수 있으므로 해당 값 중 하나보다 낮게 유지해야합니다. 워크로드에 가장 적합한 가치를 찾기 위해 실험하십시오.
# B.4.3.5 절.“MySQL이 임시 파일을 저장하는 곳”을 참조하십시오.
# 
# sort_buffer_size의 최대 허용 설정은 4GB입니다. 64 비트 플랫폼에는 더 큰 값이 허용됩니다 (64 비트 Windows는 큰 값이 경고와 함께 4GB로 잘립니다).
#
# * Apply Option
# sort_buffer_size=262144
# 
# --------------------------------------------
# 
# @ sql_log_off :
# 
# Property : Value
# System Variable : sql_log_off
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# Valid Values	
# OFF (enable logging)
# ON (disable logging)
# 
# 이 변수는 현재 세션에서 일반 쿼리 로그에 대한 로깅을 비활성화할지 여부를 제어합니다 (일반 쿼리 로그 자체가 활성화되어 있다고 가정).
# 기본값은 OFF입니다 (즉, 로깅 사용). 현재 세션에 대한 일반 쿼리 로깅을 비활성화하거나 활성화하려면 session sql_log_off 변수를 ON 또는 OFF로 설정하십시오.
# 이 시스템 변수의 세션 값 설정은 제한된 조작입니다. 세션 사용자에게는 제한된 세션 변수를 설정하기에 충분한 권한이 있어야합니다. 5.1.8.1 절.“시스템 변수 권한”을 참조하십시오.
#
# * Apply Option
# sql_log_off=OFF
# 
# --------------------------------------------
# 
# @ sql_mode :
# 
# Property : Value
# Command-Line Format : --sql-mode=name
# System Variable : sql_mode
# Scope : Global, Session
# Dynamic : Yes
# Type : Set
# Default Value : | ONLY_FULL_GROUP_BY STRICT_TRANS_TABLES NO_ZERO_IN_DATE NO_ZERO_DATE ERROR_FOR_DIVISION_BY_ZERO NO_AUTO_CREATE_USER NO_ENGINE_SUBSTITUTION
# Valid Values
# ALLOW_INVALID_DATES
# ANSI_QUOTES
# ERROR_FOR_DIVISION_BY_ZERO
# HIGH_NOT_PRECEDENCE
# IGNORE_SPACE
# NO_AUTO_CREATE_USER
# NO_AUTO_VALUE_ON_ZERO
# NO_BACKSLASH_ESCAPES
# NO_DIR_IN_CREATE
# NO_ENGINE_SUBSTITUTION
# NO_FIELD_OPTIONS
# NO_KEY_OPTIONS
# NO_TABLE_OPTIONS
# NO_UNSIGNED_SUBTRACTION
# NO_ZERO_DATE
# NO_ZERO_IN_DATE
# ONLY_FULL_GROUP_BY
# PAD_CHAR_TO_FULL_LENGTH
# PIPES_AS_CONCAT
# REAL_AS_FLOAT
# STRICT_ALL_TABLES
# STRICT_TRANS_TABLES
# 
# The current server SQL mode, which can be set dynamically. For details, see Section 5.1.10, “Server SQL Modes”.
# https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html
#
# * Apply Option
# sql_mode=ONLY_FULL_GROUP_BY STRICT_TRANS_TABLES NO_ZERO_IN_DATE NO_ZERO_DATE ERROR_FOR_DIVISION_BY_ZERO NO_AUTO_CREATE_USER NO_ENGINE_SUBSTITUTION
# 
# --------------------------------------------
# 
# @ stored_program_cache :
# 
# Property : Value
# Command-Line Format : --stored-program-cache=#
# System Variable : stored_program_cache
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 256
# Minimum Value : 16
# Maximum Value : 524288
# 
# 연결 당 캐시 된 저장 루틴 수에 대한 소프트 상한을 설정합니다.
# 이 변수의 값은 각각 스토어드 프로 시저 및 스토어드 함수에 대해 MySQL 서버가 유지 보수하는 두 개의 캐시 각각에 보유 된 스토어드 루틴의 수로 지정됩니다.
# 
# 저장된 루틴이 실행될 때마다 루틴의 첫 번째 또는 최상위 레벨 명령문이 구문 분석되기 전에이 캐시 크기가 점검됩니다.
# 동일한 유형의 루틴 (저장 프로 시저 또는 실행중인 저장 함수)이이 변수에 의해 지정된 한계를 초과하면 해당 캐시가 플러시되고 캐시 된 오브젝트에 대해 이전에 할당 된 메모리가 해제됩니다.
# 이를 통해 저장된 루틴간에 종속성이있는 경우에도 캐시를 안전하게 플러시 할 수 있습니다.
#
# * Apply Option
# stored_program_cache=256
# 
# --------------------------------------------
# 
# @ table_definition_cache :
# 
# Property : Value
# Command-Line Format : --table-definition-cache=#
# System Variable : table_definition_cache
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : 400
# Maximum Value : 524288
# 
# 정의 캐시에 저장할 수있는 테이블 정의 (.frm 파일의) 수입니다. 많은 수의 테이블을 사용하는 경우 테이블을 빠르게 열 수 있도록 큰 테이블 정의 캐시를 작성할 수 있습니다.
# 테이블 정의 캐시는 일반 테이블 캐시와 달리 공간을 덜 차지하고 파일 디스크립터를 사용하지 않습니다. 최소값은 400입니다. 기본값은 다음 수식을 기반으로하며 한계는 2000입니다.
# 400 + (table_open_cache / 2)
# 
# InnoDB의 경우 table_definition_cache는 InnoDB 데이터 사전 캐시에서 열린 테이블 인스턴스 수에 대한 소프트 한계로 작동합니다.
# 열린 테이블 인스턴스 수가 table_definition_cache 설정을 초과하면 LRU 메커니즘은 테이블 인스턴스를 제거하도록 표시하고 결국 데이터 사전 캐시에서 제거합니다.
# 이 제한은 다음 서버가 다시 시작될 때까지 거의 사용되지 않는 테이블 인스턴스를 캐시하는 데 상당한 양의 메모리가 사용되는 상황을 해결하는 데 도움이됩니다.
# 캐시 된 메타 데이터가있는 테이블 인스턴스의 수는 InnoDB 시스템 테이블 인스턴스와 외래 키 관계가있는 부모 및 자식 테이블 인스턴스가 LRU 목록에 배치되지 않고 메모리에서 제거되지 않으므로
# table_definition_cache에 의해 정의 된 한계보다 클 수 있습니다.
# 
# 또한 table_definition_cache는 한 번에 열 수있는 InnoDB 테이블 당 테이블 스페이스 수에 대한 소프트 제한을 정의하며 innodb_open_files에 의해 제어됩니다.
# table_definition_cache 및 innodb_open_files가 모두 설정되면 가장 높은 설정이 사용됩니다. 변수를 설정하지 않으면 기본값이 더 높은 table_definition_cache가 사용됩니다.
# 열린 테이블 스페이스 파일 핸들 수가 table_definition_cache 또는 innodb_open_files에 의해 정의 된 한계를 초과하면 LRU 메커니즘은 테이블 스페이스 파일 LRU 목록에서
# 완전히 플러시되고 현재 확장되고 있지 않은 파일을 검색합니다.
# 이 프로세스는 새 테이블 스페이스가 열릴 때마다 수행됩니다. "비활성"테이블 스페이스가없는 경우 테이블 스페이스 파일이 닫히지 않습니다.
#
# * Apply Option
# table_definition_cache=-1
# 
# --------------------------------------------
# 
# @ table_open_cache :
# 
# Property : Value
# Command-Line Format : --table-open-cache=#
# System Variable : table_open_cache
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 2000
# Minimum Value : 1
# Maximum Value : 524288
#
# 모든 스레드에 대한 열린 테이블 수입니다. 이 값을 늘리면 mysqld에 필요한 파일 디스크립터 수가 증가합니다. Opened_tables 상태 변수를 확인하여 테이블 캐시를 늘려야하는지 여부를 확인할 수 있습니다.
# 5.1.9 절.“서버 상태 변수”를 참조하십시오. Opened_tables의 값이 크고 FLUSH TABLES를 자주 사용하지 않는 경우 (모든 테이블을 닫았다가 다시 열어야 함) table_open_cache 변수의 값을 늘려야합니다.
# 테이블 캐시에 대한 자세한 내용은 8.4.3.1 절“MySQL에서 테이블을 열고 닫는 방법”을 참조하십시오.
#
# * Apply Option
# table_open_cache=2000
# 
# --------------------------------------------
# 
# @ table_open_cache_instances :
# 
# Property : Value
# Command-Line Format : --table-open-cache-instances=#
# System Variable : table_open_cache_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 16
# Minimum Value : 1
# Maximum Value : 64
#
# 열린 테이블 캐시 인스턴스 수입니다. 세션 간 경합을 줄임으로써 확장 성을 향상시키기 위해 열린 테이블 캐시를 table_open_cache/table_open_cache_instances 크기의
# 여러 작은 캐시 인스턴스로 분할할 수 있습니다.
# 세션은 DML 문에 액세스하기 위해 하나의 인스턴스 만 잠그면됩니다. 이는 인스턴스간에 캐시 액세스를 세그먼트 화하여 테이블에 액세스하는 세션이 많은 경우 캐시를 사용하는 조작의 성능을 향상시킵니다.
# (DDL 문은 여전히 ​​전체 캐시에 대한 잠금이 필요하지만 이러한 문은 DML 문보다 훨씬 덜 빈번합니다.)
# 
# 16 개 이상의 코어를 일상적으로 사용하는 시스템에서는 8 또는 16의 값이 권장됩니다.
#
# * Apply Option
# table_open_cache_instances=16
# 
# --------------------------------------------
# 
# @ thread_cache_size :
# 
# Property : Value
# Command-Line Format : --thread-cache-size=#
# System Variable : thread_cache_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : 0
# Maximum Value : 16384
#
# 재사용을 위해 서버가 캐시해야하는 스레드 수 클라이언트가 연결을 끊을 때 thread_cache_size 스레드보다 적은 수의 클라이언트 스레드가 있으면 캐시에 저장됩니다.
# 가능한 경우 캐시에서 가져온 스레드를 재사용하여 스레드 요청이 충족되며 캐시가 비어있는 경우에만 새 스레드가 작성됩니다. 새로운 연결이 많은 경우 성능을 향상시키기 위해이 변수를 늘릴 수 있습니다.
# 일반적으로 스레드 구현이 양호하면 성능이 크게 향상되지 않습니다. 그러나 서버에 초당 수백 개의 연결이 표시되는 경우 일반적으로 대부분의 새 연결이 캐시 된 스레드를 사용하도록 thread_cache_size를 충분히 높게 설정해야합니다.
# Connections 및 Threads_created 상태 변수의 차이점을 검사하여 스레드 캐시의 효율성을 확인할 수 있습니다. 자세한 내용은 5.1.9 절.“서버 상태 변수”를 참조하십시오.
# 
# 기본값은 다음 수식을 기반으로하며 100으로 제한됩니다.
# 8 + (최대 연결 수 / 100)
# 
# 이 변수는 내장 서버 (libmysqld)에 영향을 미치지 않으며 MySQL 5.7.2부터 내장 서버에서 더 이상 볼 수 없습니다.
#
# * Apply Option
# thread_cache_size=-1
# 
# --------------------------------------------
# 
# @ thread_pool_size :
# 
# Property : Value
# Command-Line Format : --thread-pool-size=#
# System Variable : thread_pool_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 16
# Minimum Value : 1
# Maximum Value : 64
# 
# 스레드 풀의 스레드 그룹 수 스레드 풀 성능을 제어하는 ​​가장 중요한 매개 변수입니다. 동시에 실행할 수있는 명령문 수에 영향을줍니다.
# 기본값은 16이며 허용 가능한 값의 범위는 1-64입니다. 이 범위를 벗어난 값을 지정하면 스레드 풀 플러그인이로드되지 않고 서버가 오류 로그에 메시지를 씁니다.
# 
# 이 변수는 스레드 풀 플러그인이 사용 가능한 경우에만 사용 가능합니다. 5.5.3 절“MySQL Enterprise 스레드 풀”을 참조하십시오.
#
# * Apply Option
# thread_pool_size=16
# 
# --------------------------------------------
# 
# @ thread_stack :
# 
# Property : Value
# Command-Line Format : --thread-stack=#
# System Variable : thread_stack
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : (64-bit platforms)- 262144
# Default Value : (32-bit platforms) - 196608
# Minimum Value : 131072
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# Block Size	1024
# 
# 각 스레드의 스택 크기입니다. 기본값은 정상 작동에 충분한 크기입니다. 스레드 스택 크기가 너무 작 으면 서버가 처리 할 수있는 SQL 문의 복잡성, 저장 프로 시저의 재귀 깊이 및 기타 메모리 소비 작업이 제한됩니다.
#
# * Apply Option
# thread_stack=262144
# 
# --------------------------------------------
# 
# @ tmp_table_size :
# 
# Property : Value
# Command-Line Format : --tmp-table-size=#
# System Variable : tmp_table_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 16777216
# Minimum Value : 1024
# Maximum Value : 18446744073709551615
# 
# 내부 메모리 내 임시 테이블의 최대 크기입니다. 이 변수는 사용자가 만든 MEMORY 테이블에는 적용되지 않습니다.
# 
# 실제 한계는 tmp_table_size 및 max_heap_table_size 값 중 작은 값으로 결정됩니다. 메모리 내 임시 테이블이 한도를 초과하면 MySQL은 자동으로 디스크상의 임시 테이블로 변환합니다.
# internal_tmp_disk_storage_engine 옵션은 온 디스크 임시 테이블에 사용되는 스토리지 엔진을 정의합니다.
# 
# 고급 GROUP BY 쿼리를 많이 수행하고 메모리가 많은 경우 tmp_table_size (필요한 경우 max_heap_table_size)의 값을 늘리십시오.
# 
# Created_tmp_disk_tables 및 Created_tmp_tables 변수의 값을 비교하여 작성된 내부 온 디스크 임시 테이블 수와 작성된 총 내부 임시 테이블 수를 비교할 수 있습니다.
#
# * Apply Option
# tmp_table_size=16777216
# 
# --------------------------------------------
# 
# @ max_heap_table_size
# 
# Command-Line Format	--max-heap-table-size=#
# System Variable	max_heap_table_size
# Scope	Global, Session
# Dynamic	Yes
# Type	Integer
# Default Value	16777216
# Minimum Value	16384
# Maximum Value (64-bit platforms)	1844674407370954752
# Maximum Value (32-bit platforms)	4294967295
#
# 이 변수는 사용자가 생성한 MEMORY 테이블이 사용할 수 있는 최대 크기를 설정합니다. 변수 값은 MEMORY 테이블 MAX_ROWS 값을 계산하는 데 사용됩니다.
# 이 변수를 설정해도 테이블이 CREATE TABLE과 같은 명령문으로 다시 작성되거나 ALTER TABLE 또는 TRUNCATE TABLE로 변경되지 않는 한 기존 MEMORY 테이블에 영향을 미치지 않습니다.
# 서버를 다시 시작하면 기존 MEMORY 테이블의 최대 크기도 전역 max_heap_table_size 값으로 설정됩니다.
#
# 이 변수는 내부 메모리 테이블의 크기를 제한하기 위해 tmp_table_size와 함께 사용됩니다. 8.4.4 절.“MySQL에서 내부 임시 테이블 사용”을 참조하십시오.
#
# max_heap_table_size는 복제되지 않습니다. 자세한 내용은 Section 16.4.1.20,“Replication and MEMORY Tables”및 Section 16.4.1.37,“Replication and Variables”를 참조하십시오.
# 
# * Apply Option
# max_heap_table_size=16777216
#
# # --------------------------------------------
# 
# @ tmpdir :
# 
# Property : Value
# Command-Line Format : --tmpdir=dir_name
# System Variable : tmpdir
# Scope : Global
# Dynamic : No
# Type : Directory name
# 
# 임시 파일 작성에 사용할 디렉토리의 경로입니다. 기본 / tmp 디렉토리가 임시 테이블을 보유하기에는 너무 작은 파티션에있는 경우 유용 할 수 있습니다.
# 이 변수는 라운드 로빈 방식으로 사용되는 여러 경로 목록으로 설정할 수 있습니다. 경로는 Unix에서는 콜론 문자 (:)로, Windows에서는 세미콜론 문자 (;)로 구분해야합니다.
# 
# tmpdir은 메모리 기반 파일 시스템의 디렉토리 또는 서버 호스트가 다시 시작될 때 지워지는 디렉토리와 같은 비 영구적 위치 일 수 있습니다.
# MySQL 서버가 복제 슬레이브로 작동하고 tmpdir에 비 영구적 위치를 사용하는 경우 slave_load_tmpdir 변수를 사용하여 슬레이브에 대해 다른 임시 디렉토리를 설정하십시오.
# 복제 슬레이브의 경우 LOAD DATA 문을 복제하는 데 사용 된 임시 파일이이 디렉토리에 저장되므로 영구 위치를 사용하면 임시 파일이 제거 된 경우 다시 시작한 후에도 복제를 계속할 수 있지만 영구적 인 위치에서 머신을 다시 시작해도 살아남을 수 있습니다.
# 
# 임시 파일의 저장 위치에 대한 자세한 내용은 B.4.3.5 절“MySQL이 임시 파일을 저장하는 위치”를 참조하십시오.
#
# * Apply Option
# tmpdir=directory name
# 
# --------------------------------------------
# 
# @ transaction_isolation :
# 
# Property : Value
# Command-Line Format : --transaction-isolation=name
# System Variable (≥ 5.7.20)	transaction_isolation
# Scope (≥ 5.7.20)	Global, Session
# Dynamic (≥ 5.7.20)	Yes
# Type : Enumeration
# Default Value : REPEATABLE-READ
# Valid Values  : READ-UNCOMMITTED , READ-COMMITTED , REPEATABLE-READ , SERIALIZABLE
# 
# 트랜잭션 격리 수준 기본값은 REPEATABLE-READ입니다.
# 트랜잭션 격리 수준에는 전역, 세션 및 다음 트랜잭션의 세 가지 범위가 있습니다. 이 3 가지 범위의 구현은 후술하는 바와 같이 일부 비표준 격리 레벨 할당 의미론으로 이어진다.
# 
# + 시작시 전역 트랜잭션 격리 수준을 설정하려면 --transaction-isolation server 옵션을 사용하십시오.
# 
# 런타임시, 격리 레벨은 SET 문을 사용하여 직접 설정하여 transaction_isolation 시스템 변수에 값을 지정하거나 간접적으로 SET TRANSACTION 문을 사용하여 설정할 수 있습니다.
# transaction_isolation을 공백이 포함 된 격리 수준 이름으로 직접 설정 한 경우 이름은 따옴표로 묶어야하며 공백은 대시로 대체해야합니다. 예를 들어이 SET 문을 사용하여 전역 값을 설정하십시오.
# 
# SET GLOBAL transaction_isolation = 'READ-COMMITTED';
# global transaction_isolation 값을 설정하면 모든 후속 세션에 대한 격리 수준이 설정됩니다. 기존 세션은 영향을받지 않습니다.
# 
# 세션 또는 다음 레벨 transaction_isolation 값을 설정하려면 SET 문을 사용하십시오. 대부분의 세션 시스템 변수에서이 명령문은 값을 설정하는 동등한 방법입니다.
# SET @@SESSION.var_name = value;
# SET SESSION var_name = value;
# SET var_name = value;
# SET @@var_name = value;
# 앞에서 언급했듯이 트랜잭션 격리 수준에는 전역 및 세션 범위 외에 다음 트랜잭션 범위가 있습니다. 다음 트랜잭션 범위를 설정하려면 세션 시스템 변수 값을 지정하기위한 SET 구문에 transaction_isolation에 대한 비표준 의미가 있습니다.
# 
# + 세션 격리 수준을 설정하려면 다음 구문 중 하나를 사용하십시오.
# SET @@SESSION.transaction_isolation = value;
# SET SESSION transaction_isolation = value;
# SET transaction_isolation = value;
# For each of those syntaxes, these semantics apply:
# 
# - 세션 내에서 수행 된 모든 후속 트랜잭션에 대한 격리 수준을 설정합니다.
# - 거래 내에서 허용되지만 현재 진행중인 거래에는 영향을 미치지 않습니다.
# - 트랜잭션 사이에서 실행되면 다음 트랜잭션 격리 레벨을 설정하는 이전 명령문을 대체합니다.
# - SET SESSION TRANSACTION ISOLATION LEVEL (SESSION 키워드 사용)에 해당합니다.
# 
# + 다음 트랜잭션 격리 레벨을 설정하려면 다음 구문을 사용하십시오.
# SET @@transaction_isolation = value;
# 
# 이 구문에는 다음과 같은 의미가 적용됩니다.
# - 세션 내에서 수행 된 다음 단일 트랜잭션에 대해서만 격리 수준을 설정합니다.
# - 후속 트랜잭션은 세션 격리 수준으로 돌아갑니다.
# - 거래 내에서 허용되지 않습니다.
# - SET TRANSACTION ISOLATION LEVEL (SESSION 키워드없이)에 해당합니다.
# 
# SET TRANSACTION 및 transaction_isolation 시스템 변수와의 관계에 대한 자세한 내용은 13.3.6 절“SET TRANSACTION 문”을 참조하십시오.
# 
# 노트
# transaction_isolation은 MySQL 5.7.20에서 tx_isolation의 별칭으로 추가되었으며, 이제 더 이상 사용되지 않으며 MySQL 8.0에서 제거됩니다. tx_isolation보다 transaction_isolation을 사용하도록 응용 프로그램을 조정해야합니다.
#
# * Apply Option
# transaction_isolation=REPEATABLE-READ
# 
# --------------------------------------------
# 
# @ transaction_read_only :
# 
# Property : Value
# Command-Line Format : --transaction-read-only[={OFF|ON}]
# System Variable (≥ 5.7.20)	transaction_read_only
# Scope (≥ 5.7.20)	Global, Session
# Dynamic (≥ 5.7.20)	Yes
# Type : Boolean
# Default Value : OFF
#
# 트랜잭션 액세스 모드 값은 OFF (읽기 / 쓰기; 기본값) 또는 ON (읽기 전용) 일 수 있습니다.
# 트랜잭션 액세스 모드에는 전역, 세션 및 다음 트랜잭션의 세 가지 범위가 있습니다. 이 3 가지 범위의 구현은 후술하는 바와 같이 일부 비표준 액세스 모드 할당 시맨틱으로 이어진다.
# 시작시 전역 트랜잭션 액세스 모드를 설정하려면 --transaction-read-only server 옵션을 사용하십시오.
# 
# 런타임시, 액세스 모드는 SET 문을 사용하여 직접 설정하여 transaction_read_only 시스템 변수에 값을 지정하거나 간접적으로 SET TRANSACTION 문을 사용하여 설정할 수 있습니다. 예를 들어이 SET 문을 사용하여 전역 값을 설정하십시오.
# 
# SET GLOBAL transaction_read_only = ON;
# 전역 transaction_read_only 값을 설정하면 모든 후속 세션에 대한 액세스 모드가 설정됩니다. 기존 세션은 영향을받지 않습니다.
# 
# 세션 또는 다음 레벨 transaction_read_only 값을 설정하려면 SET 문을 사용하십시오. 대부분의 세션 시스템 변수에서이 명령문은 값을 설정하는 동등한 방법입니다.
# 
# SET @@SESSION.var_name = value;
# SET SESSION var_name = value;
# SET var_name = value;
# SET @@var_name = value;
# 앞에서 언급했듯이 트랜잭션 액세스 모드에는 전역 및 세션 범위 외에 다음 트랜잭션 범위가 있습니다. 다음 트랜잭션 범위를 설정하려면 세션 시스템 변수 값을 지정하기위한 SET 구문에 transaction_read_only에 대한 비표준 의미가 있습니다.
# 
# + 세션 액세스 모드를 설정하려면 다음 구문 중 하나를 사용하십시오.
# SET @@SESSION.transaction_read_only = value;
# SET SESSION transaction_read_only = value;
# SET transaction_read_only = value;
# For each of those syntaxes, these semantics apply:
# 
# - Sets the access mode for all subsequent transactions performed within the session.
# - Permitted within transactions, but does not affect the current ongoing transaction.
# - If executed between transactions, overrides any preceding statement that sets the next-transaction access mode.
# - Corresponds to SET SESSION TRANSACTION {READ WRITE | READ ONLY} (with the SESSION keyword).
# 
# 다음 트랜잭션 액세스 모드를 설정하려면 다음 구문을 사용하십시오.
# SET @@transaction_read_only = value;
# 
# 이 구문에는 다음과 같은 의미가 적용됩니다.
# -세션 내에서 수행 된 다음 단일 트랜잭션에 대해서만 액세스 모드를 설정합니다.
# -후속 트랜잭션은 세션 액세스 모드로 돌아갑니다.
# -거래 내에서 허용되지 않습니다.
# -SET TRANSACTION {READ WRITE | READ ONLY} (SESSION 키워드없이).
# 
# SET TRANSACTION 및 transaction_read_only 시스템 변수와의 관계에 대한 자세한 내용은 13.3.6 절“SET TRANSACTION 문”을 참조하십시오.
# 
# 노트
# transaction_read_only는 MySQL 5.7.20에서 tx_read_only의 별칭으로 추가되었으며, 이제 더 이상 사용되지 않으며 MySQL 8.0에서 제거됩니다. tx_read_only보다 transaction_read_only를 사용하도록 애플리케이션을 조정해야합니다.
#
# * Apply Option
# transaction_read_only=OFF
# 
# --------------------------------------------
# 
# @ unique_checks :
# 
# Property : Value
# System Variable : unique_checks
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 1 (기본값)로 설정하면 InnoDB 테이블에서 보조 인덱스에 대한 고유성 검사가 수행됩니다. 0으로 설정하면 스토리지 엔진은 입력 데이터에 중복 키가 없다고 가정 할 수 있습니다.
# 데이터에 고유성 위반이 포함되어 있지 않다는 것을 알고 있다면이 테이블을 0으로 설정하여 큰 테이블 가져 오기를 InnoDB로 가속화 할 수 있습니다.
# 
# 이 변수를 0으로 설정하면 스토리지 엔진이 중복 키를 무시하지 않아도됩니다. 엔진은 여전히 ​​엔진을 점검하고 감지되면 중복 키 오류를 발행 할 수 있습니다.
#
# * Apply Option
# unique_checks=ON
# 
# --------------------------------------------
# 
# @ wait_timeout :
# 
# Property : Value
# Command-Line Format : --wait-timeout=#
# System Variable : wait_timeout
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 28800
# Minimum Value : 1
# Maximum Value : (Other)	31536000
# Maximum Value : (Windows) - 2147483
# 
# 비 대화식 연결에서 서버가 활동을 닫기 전에 서버가 대기하는 시간 (초)입니다.
# 
# 스레드 시작시 세션 유형 wait_timeout 값은 클라이언트 유형에 따라 전역 wait_timeout 값 또는 전역 interactive_timeout 값에서 초기화됩니다(CLIENT_INTERACTIVE 연결 옵션으로 mysql_real_connect()에 정의 됨).
# interactive_timeout도 참조하십시오.
#
# * Apply Option
# wait_timeout=28800
# 
# --------------------------------------------
# 
# @ pid_file
# 
# Command-Line Format : --pid-file=file_name
# System Variable : pid_file
# Scope	: Global
# Dynamic : No
# Type : File name
# 
# 서버가 프로세스 ID를 쓰는 파일의 경로 이름입니다. 다른 디렉토리를 지정하기 위해 절대 경로 이름이 제공되지 않는 한 서버는 데이터 디렉토리에 파일을 작성합니다.
# 이 변수를 지정하는 경우 값을 지정해야합니다. 이 변수를 지정하지 않으면 MySQL은 host_name.pid의 기본값을 사용합니다. 여기서 host_name은 호스트 시스템의 이름입니다.
# 
# 
# 프로세스 ID 파일은 mysqld_safe와 같은 다른 프로그램에서 서버의 프로세스 ID를 결정하는 데 사용됩니다.
# Windows에서이 변수는 기본 오류 로그 파일 이름에도 영향을줍니다. 5.4.2 절.“오류 로그”를 참조하십시오.
#
# * Apply Option
# pid_file=경로/filename.pid
#
# ----------------------------------------------------
# -------------character set 관련 변수들.----------
# ----------------------------------------------------
# 
# @ character_set_client
# 
# System Variable : character_set_client
# Scope L Global, Session
# Dynamic : Yes
# Type : String
# Default Value : utf8
# 
# 클라이언트에서 도착하는 문에 대한 문자 집합입니다. 이 변수의 세션 값은 클라이언트가 서버에 연결할 때 클라이언트가 요청한 문자 집합을 사용하여 설정됩니다.
# (많은 클라이언트가 --default-character-set 옵션을 지원하여이 문자 집합이 명시 적으로 지정되도록합니다. 10.4 절.“연결 문자 집합 및 데이터 정렬”도 참조하십시오.)
# 변수의 전역 값은 세션 값을 설정하는 데 사용됩니다. 클라이언트 요청 값을 알 수 없거나 사용할 수 없거나 서버가 클라이언트 요청을 무시하도록 구성된 경우 :
#  -클라이언트가 서버에 알려지지 않은 문자 집합을 요청합니다. 예를 들어, 일본어 사용 가능 클라이언트는 sjis 지원으로 구성되지 않은 서버에 연결할 때 sji를 요청합니다.
#  -클라이언트는 MySQL 4.1 이전 버전의 MySQL이므로 문자 집합을 요청하지 않습니다.
#  -mysqld는 --skip-character-set-client-handshake 옵션으로 시작되어 클라이언트 문자 세트 구성을 무시합니다.
#   이는 MySQL 4.0 동작을 재현하며 모든 클라이언트를 업그레이드하지 않고 서버를 업그레이드하려는 경우 유용합니다.
# 
# 일부 문자 집합은 클라이언트 문자 집합으로 사용할 수 없습니다. character_set_client 값으로 사용하려고하면 오류가 발생합니다. 허용되지 않는 클라이언트 문자 집합을 참조하십시오.
# 
# * Apply Option
# character_set_client=utf8
# 
# # --------------------------------------------
# 
# @ character_set_connection
# 
# System Variable : character_set_connection
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# Default Value : utf8
# 
# 문자 세트 소개없이 지정된 리터럴 및 숫자-문자열 변환에 사용되는 문자 세트입니다. 소개 자에 대한 정보는 10.3.8 절.“문자 집합 소개 자”를 참조하십시오.
#
# * Apply Option
# character_set_connection=utf8
#
# # --------------------------------------------
# 
# @ character_set_database
# 
# System Variable : character_set_database
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# Default Value : latin1
# Footnote : 이 옵션은 동적이지만 서버에서만 설정해야합니다. 이 변수를 수동으로 설정하면 안됩니다.
# 
# 기본 데이터베이스에서 사용하는 문자 집합입니다. 서버는 기본 데이터베이스가 변경 될 때마다이 변수를 설정합니다. 기본 데이터베이스가없는 경우 변수는 character_set_server와 동일한 값을 갖습니다.
# 전역 character_set_database 및 collation_database 시스템 변수는 MySQL 5.7에서 더 이상 사용되지 않습니다. 향후 버전의 MySQL에서 제거 될 것으로 예상됩니다.
# 세션 character_set_database 및 collation_database 시스템 변수에 값을 할당하는 것은 MySQL 5.7에서 더 이상 사용되지 않으며 할당시 경고가 생성됩니다.
# 세션 변수는 MySQL의 차기 버전에서 읽기 전용이되고 할당은 오류를 생성하는 반면 세션 변수에 액세스하여 기본 데이터베이스에 대한 데이터베이스 문자 집합과 데이터 정렬을 결정할 수 있도록해야합니다.
# 
# * Apply Option
# character_set_database=latin1
#
# --------------------------------------------
# 
# @ character_set_filesystem
# 
# Command-Line Format	--character-set-filesystem=name
# System Variable	character_set_filesystem
# Scope	Global, Session
# Dynamic	Yes
# Type	String
# Default Value	binary
# 
# 
# 파일 시스템 문자 세트. 이 변수는 LOAD DATA 및 SELECT ... INTO OUTFILE 문 및 LOAD_FILE () 함수와 같이 파일 이름을 참조하는 문자열 리터럴을 해석하는 데 사용됩니다.
# 이러한 파일 이름은 파일 열기 시도가 발생하기 전에 character_set_client에서 character_set_filesystem으로 변환됩니다. 기본값은 2 진이며 변환이 발생하지 않음을 의미합니다.
# 멀티 바이트 파일 이름이 허용되는 시스템의 경우 다른 값이 더 적절할 수 있습니다. 예를 들어 시스템이 UTF-8을 사용하여 파일 이름을 나타내는 경우 character_set_filesystem을 'utf8mb4'로 설정합니다.
# 
# * Apply Option
# character_set_database=binary
#
# --------------------------------------------
# 
# @ character_set_results
# 
# System Variable	character_set_results
# Scope	Global, Session
# Dynamic	Yes
# Type	String
# Default Value	utf8
# 
# 클라이언트에 쿼리 결과를 반환하는 데 사용되는 문자 집합입니다. 여기에는 열 값과 같은 결과 데이터, 열 이름과 같은 결과 메타 데이터 및 오류 메시지가 포함됩니다.
# 
#
# * Apply Option
# character_set_results=utf8
#
# --------------------------------------------
# 
# @ character_set_server
# 
# Command-Line Format	--character-set-server=name
# System Variable	character_set_server
# Scope	Global, Session
# Dynamic	Yes
# Type	String
# Default Value	latin1
# 
# 서버 기본 문자 집합입니다. 10.15 절.“문자 집합 구성”을 참조하십시오. 이 변수를 설정하는 경우 문자 집합에 대한 데이터 정렬을 지정하려면 collation_server도 설정해야합니다.
# 
# * Apply Option
# character_set_server=latin1
#
# # --------------------------------------------
# 
# @ character_set_system
# 
# System Variable : character_set_system
# Scope : Global
# Dynamic : No
# Type : String
# Default Value : utf8
# 
# 식별자를 저장하기 위해 서버에서 사용하는 문자 집합입니다. 값은 항상 utf8입니다.
# 
# * Apply Option
# character_set_system=utf8
#
# # --------------------------------------------
# 
# @ character_sets_dir
# 
# Command-Line Format : --character-sets-dir=dir_name
# System Variable : character_sets_dir
# Scope : Global
# Dynamic : No
# Type : Directory name
# 
# 문자 세트가 설치된 디렉토리입니다. 10.15 절.“문자 집합 구성”을 참조하십시오.
#
# * Apply Option
# character_sets_dir=Directory name
# 
# ----------------------------------------------------
# -------------Slow Query, Index 관련 변수들.----------
# ----------------------------------------------------
# @ slow_query_log
# 
# Property : Value
# Command-Line Format : --slow-query-log[={OFF|ON}]
# System Variable : slow_query_log
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
#
# Slow Query 로그 사용 여부입니다. 로그를 비활성화하려면 값을 0 (또는 OFF)으로 설정하고, 로그를 활성화하려면 1 (또는 ON) 값을 지정할 수 있습니다.
# 로그 출력 대상은 log_output 시스템 변수에 의해 제어됩니다. 해당 값이 NONE이면 로그가 사용 가능하더라도 로그 항목이 기록되지 않습니다.
# 
# "느린"은 long_query_time 변수의 값에 의해 결정됩니다. 5.4.5 절.“느린 쿼리 로그”를 참조하십시오.
#
# * Apply Option
# slow_query_log=OFF
# 
# --------------------------------------------
# 
# @ slow_query_log_file
# 
# Property : Value
# Command-Line Format : --slow-query-log-file=file_name
# System Variable : slow_query_log_file
# Scope : Global
# Dynamic : Yes
# Type : File name
# Default Value : host_name-slow.log
# 
# Slow Query 로그 파일의 이름입니다. 기본값은 host_name-slow.log이지만 초기 값은 --slow_query_log_file 옵션을 사용하여 변경할 수 있습니다.
#
# * Apply Option
# slow_query_log_file=host_name-slow.log
# 
# --------------------------------------------
# 
# @ long_query_time
# 
# Property : Value
# Command-Line Format : --long-query-time=#
# System Variable : long_query_time
# Scope : Global, Session
# Dynamic : Yes
# Type : Numeric
# Default Value : 10
# Minimum Value : 0
#
# 쿼리가 설정된 시간(초단위)보다 오래 걸리면 서버는 Slow_queries 상태 변수를 증가시킵니다. 느린 쿼리 로그가 활성화되면 쿼리가 Slow Query Log 파일에 기록됩니다.
# 이 값은 CPU 시간이 아닌 실시간으로 측정되므로로드가 적은 시스템에서 임계 값 미만인 쿼리는로드가 많은 시스템의 임계 값보다 높을 수 있습니다.
# long_query_time의 최소값과 기본값은 각각 0과 10입니다. 이 값은 마이크로 초의 해상도로 지정할 수 있습니다. 5.4.5 절.“느린 쿼리 로그”를 참조하십시오.
#
# * Apply Option
# long_query_time=10
# 
# --------------------------------------------
# 
# @ log_throttle_queries_not_using_indexes
# 
# Property : Value
# Command-Line Format : --log-throttle-queries-not-using-indexes=#
# System Variable : log_throttle_queries_not_using_indexes
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
#
# log_queries_not_using_indexes가 사용 가능한 경우 log_throttle_queries_not_using_indexes 변수는 분당 느린 쿼리 로그에 쓸 수있는 분당 쿼리 수를 제한합니다.
# 값 0 (기본값)은 "제한 없음"을 의미합니다. 자세한 내용은 5.4.5 절“느린 쿼리 로그”를 참조하십시오.
#
# * Apply Option
# log_throttle_queries_not_using_indexes=0
# 
# --------------------------------------------
# 
# @ log_slow_admin_statements
# 
# Property : Value
# Command-Line Format : --log-slow-admin-statements[={OFF|ON}]
# System Variable : log_slow_admin_statements
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 느린 쿼리 로그에 작성된 명령문에 느린 관리 명령문을 포함하십시오. 관리 문에는 ALTER TABLE, ANALYZE TABLE, CHECK TABLE, CREATE INDEX, DROP INDEX, OPTIMIZE TABLE 및 REPAIR TABLE이 포함됩니다.
#
# * Apply Option
# log_slow_admin_statements=2621OFF44
# 
# --------------------------------------------
# 
# @ log_queries_not_using_indexes
# 
# Property : Value
# Command-Line Format : --log-queries-not-using-indexes[={OFF|ON}]
# System Variable : log_queries_not_using_indexes
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 느린 쿼리 로그가 활성화 된 상태에서이 변수를 활성화하면 모든 행을 검색 할 것으로 예상되는 쿼리가 기록됩니다. 5.4.5 절.“느린 쿼리 로그”를 참조하십시오.
# 이 옵션이 반드시 인덱스가 사용되지 않음을 의미하지는 않습니다. 예를 들어 전체 인덱스 스캔을 사용하는 쿼리는 인덱스를 사용하지만 인덱스가 행 수를 제한하지 않기 때문에 기록됩니다.
#
# * Apply Option
# log_queries_not_using_indexes=OFF 
# 
# ----------------------------------------------------
# -------------Optimizer 관련 변수들.------------------
# ----------------------------------------------------
# 
# @ optimizer_prune_level
# 
# Property : Value
# Command-Line Format : --optimizer-prune-level=#
# System Variable : optimizer_prune_level
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 1
# Minimum Value : 0
# Maximum Value : 1
#
# 쿼리 최적화 중에 적용된 휴리스틱을 제어하여 옵티 마이저 검색 공간에서 덜 유망한 부분 계획을 제거합니다. 값이 0이면 휴리스틱이 비활성화되어 옵티마이 저가 철저한 검색을 수행합니다.
# 값이 1이면 최적화 프로그램이 중간 계획에서 검색 한 행 수를 기반으로 계획을 정리합니다.
#
# * Apply Option
# optimizer_prune_level=1
# 
# --------------------------------------------
# 
# @ optimizer_search_depth
# 
# Property : Value
# Command-Line Format : --optimizer-search-depth=#
# System Variable : optimizer_search_depth
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 62
# Minimum Value : 0
# Maximum Value : 62
#
# 쿼리 최적화 프로그램이 수행하는 최대 검색 깊이입니다. 쿼리의 관계 수보다 큰 값을 사용하면 쿼리 계획이 향상되지만 쿼리에 대한 실행 계획을 생성하는 데 시간이 더 걸립니다.
# 쿼리의 관계 수보다 작은 값은 실행 계획을 더 빨리 반환하지만 결과 계획은 최적이 아닙니다. 0으로 설정하면 시스템이 자동으로 합리적인 값을 선택합니다.
#
# * Apply Option
# optimizer_search_depth=62
# 
# --------------------------------------------
# 
# @ optimizer_switch
# 
# Property : Value
# Command-Line Format : --optimizer-switch=value
# System Variable : optimizer_switch
# Scope : Global, Session
# Dynamic : Yes
# Type : Set
# Valid Values	
# batched_key_access={on|off}
# block_nested_loop={on|off}
# condition_fanout_filter={on|off}
# derived_merge={on|off}
# duplicateweedout={on|off}
# engine_condition_pushdown={on|off}
# firstmatch={on|off}
# index_condition_pushdown={on|off}
# index_merge={on|off}
# index_merge_intersection={on|off}
# index_merge_sort_union={on|off}
# index_merge_union={on|off}
# loosescan={on|off}
# materialization={on|off}
# mrr={on|off}
# mrr_cost_based={on|off}
# semijoin={on|off}
# subquery_materialization_cost_based={on|off}
# use_index_extensions={on|off}
# 
# optimizer_switch 시스템 변수를 사용하면 옵티 마이저 동작을 제어 할 수 있습니다. 이 변수의 값은 플래그 세트이며, 각 플래그는 해당 옵티 마이저 동작이 사용 가능한지 여부를 표시하기 위해 on 또는 off 값을 갖습니다.
# 이 변수는 글로벌 및 세션 값을 가지며 런타임시 변경 될 수 있습니다. 서버 시작시 전역 기본값을 설정할 수 있습니다.
# 
# 현재 옵티 마이저 플래그 세트를 보려면 변수 값을 선택하십시오.
# mysql> SELECT @@optimizer_switch\G
# *************************** 1. row ***************************
# @@optimizer_switch: index_merge=on,index_merge_union=on,
#                     index_merge_sort_union=on,
#                     index_merge_intersection=on,
#                     engine_condition_pushdown=on,
#                     index_condition_pushdown=on,
#                     mrr=on,mrr_cost_based=on,
#                     block_nested_loop=on,batched_key_access=off,
#                     materialization=on,semijoin=on,loosescan=on,
#                     firstmatch=on,duplicateweedout=on,
#                     subquery_materialization_cost_based=on,
#                     use_index_extensions=on,
#                     condition_fanout_filter=on,derived_merge=on
# 
# 이 변수의 구문과 변수가 제어하는 ​​옵티 마이저 동작에 대한 자세한 내용은 8.9.2 절.“전환 가능한 최적화”를 참조하십시오.
#
# * Apply Option
# optimizer_switch=none
# 
# --------------------------------------------
# 
# @ optimizer_trace
# 
# Property : Value
# Command-Line Format : --optimizer-trace=value
# System Variable : optimizer_trace
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# 이 변수는 옵티 마이저 추적을 제어합니다. 자세한 내용은 MySQL 내부 : 최적화 프로그램 추적을 참조하십시오.
#
# * Apply Option
# optimizer_trace=none
# 
# --------------------------------------------
# 
# @ optimizer_trace_features
# 
# Property : Value
# Command-Line Format : --optimizer-trace-features=value
# System Variable : optimizer_trace_features
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# 
# 이 변수는 선택된 최적화 프로그램 추적 기능을 활성화 또는 비활성화합니다. 자세한 내용은 MySQL 내부 : 최적화 프로그램 추적을 참조하십시오.
#
# * Apply Option
# optimizer_trace_features=none
# 
# --------------------------------------------
# 
# @ optimizer_trace_limit
# 
# Property : Value
# Command-Line Format : --optimizer-trace-limit=#
# System Variable : optimizer_trace_limit
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 1
# 표시 할 최대 옵티 마이저 추적 수입니다. 자세한 내용은 MySQL 내부 : 최적화 프로그램 추적을 참조하십시오.
#
# * Apply Option
# optimizer_trace_limit=1
# 
# --------------------------------------------
# 
# @ optimizer_trace_max_mem_size
# 
# Property : Value
# Command-Line Format : --optimizer-trace-max-mem-size=#
# System Variable : optimizer_trace_max_mem_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 16384
# 저장된 옵티 마이저 추적의 최대 누적 크기입니다. 자세한 내용은 MySQL 내부 : 최적화 프로그램 추적을 참조하십시오.
#
# * Apply Option
# optimizer_trace_max_mem_size=16384
# 
# --------------------------------------------
# 
# @ optimizer_trace_offset
# 
# Property : Value
# Command-Line Format : --optimizer-trace-offset=#
# System Variable : optimizer_trace_offset
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : -1
# 표시 할 옵티 마이저 추적의 오프셋입니다. 자세한 내용은 MySQL 내부 : 최적화 프로그램 추적을 참조하십시오.
#
# * Apply Option
# optimizer_trace_offset=none
# 
# 
# ===================================================================================
# ================== Performance Schema System Variables 관련 옵션들  ==================
# ===================================================================================
#
# @ performance_schema
# 
# Property : Value
# Command-Line Format : --performance-schema[={OFF|ON}]
# System Variable : performance_schema
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : ON
# 이 변수의 값은 ON 또는 OFF이며 성능 스키마가 사용 가능한지 여부를 나타냅니다. 기본적으로 값은 ON입니다. 서버 시작시이 변수를 값이나 ON 또는 1로 설정하여 사용 가능하게하거나 OFF 또는 0으로 설정하여 사용 불가능하게 할 수 있습니다.
# 
# 성능 스키마가 비활성화 된 경우에도 global_variables, session_variables, global_status 및 session_status 테이블을 계속 채 웁니다.
# show_compatibiliy_56 시스템 변수의 설정에 따라 SHOW VARIABLES 및 SHOW STATUS 문에 대한 결과를 해당 테이블에서 가져올 수 있도록 필요한 경우에 발생합니다.
#
# * Apply Option
# performance_schema=ON
# 
# --------------------------------------------
# 
# @ performance_schema_accounts_size
# 
# Property : Value
# Command-Line Format : --performance-schema-accounts-size=#
# System Variable : performance_schema_accounts_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# Minimum Value : -1 (signifies autoscaling; do not assign this literal value)
# Maximum Value : 1048576
#
# 계정 테이블의 행 수입니다. 이 변수가 0이면 성능 스키마는 accounts 테이블의 연결 통계 또는 status_by_account 테이블의 상태 변수 정보를 유지하지 않습니다.
#
# * Apply Option
# performance_schema_accounts_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_digests_size
# 
# Property : Value
# Command-Line Format : --performance-schema-digests-size=#
# System Variable : performance_schema_digests_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : -1
# Maximum Value : 1048576
# events_statements_summary_by_digest 테이블의 최대 행 수입니다. 이 최대 값을 초과하여 다이제스트를 계측 할 수없는 경우 성능 스키마는 Performance_schema_digest_lost 상태 변수를 증가시킵니다.
# 
# 명령문 다이제스트에 대한 자세한 내용은 25.10 절“성능 스키마 구문 요약”을 참조하십시오.
#
# * Apply Option
# performance_schema_digests_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_stages_history_long_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-stages-history-long-size=#
# System Variable : performance_schema_events_stages_history_long_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_stages_history_long 테이블의 행 수입니다.
#
# * Apply Option
# performance_schema_events_stages_history_long_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_stages_history_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-stages-history-size=#
# System Variable : performance_schema_events_stages_history_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_stages_history 테이블에서 스레드 당 행 수입니다.
#
# * Apply Option
# performance_schema_events_stages_history_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_statements_history_long_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-statements-history-long-size=#
# System Variable : performance_schema_events_statements_history_long_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_statements_history_long 테이블의 행 수입니다.
#
# * Apply Option
# performance_schema_events_statements_history_long_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_statements_history_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-statements-history-size=#
# System Variable : performance_schema_events_statements_history_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_statements_history 테이블의 스레드 당 행 수입니다.
#
# * Apply Option
# performance_schema_events_statements_history_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_transactions_history_long_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-transactions-history-long-size=#
# System Variable : performance_schema_events_transactions_history_long_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
#
# events_transactions_history_long 테이블의 행 수입니다.
# 
# * Apply Option
# performance_schema_events_transactions_history_long_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_transactions_history_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-transactions-history-size=#
# System Variable : performance_schema_events_transactions_history_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_transactions_history 테이블에서 스레드 당 행 수입니다.
#
# * Apply Option
# performance_schema_events_transactions_history_size=-1 
# 
# --------------------------------------------
# 
# @ performance_schema_events_waits_history_long_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-waits-history-long-size=#
# System Variable : performance_schema_events_waits_history_long_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_waits_history_long 테이블의 행 수입니다.
#
# * Apply Option
# performance_schema_events_waits_history_long_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_waits_history_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-waits-history-size=#
# System Variable : performance_schema_events_waits_history_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
#
# events_waits_history 테이블에서 스레드 당 행 수입니다.
#
# * Apply Option
# performance_schema_events_waits_history_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_hosts_size
# 
# Property : Value
# Command-Line Format : --performance-schema-hosts-size=#
# System Variable : performance_schema_hosts_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# Minimum Value : -1 (signifies autoscaling; do not assign this literal value)
# Maximum Value : 1048576
# 
# hosts 테이블의 행 수입니다. 이 변수가 0 인 경우 성능 스키마는 hosts 테이블의 연결 통계 또는 status_by_host 테이블의 상태 변수 정보를 유지하지 않습니다.
#
# * Apply Option
# performance_schema_hosts_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_cond_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-cond-classes=#
# System Variable : performance_schema_max_cond_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 80
# Minimum Value : 0
# Maximum Value : 256
#
# 최대 조건 계측기 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_cond_classes=80
# 
# --------------------------------------------
# 
# @ performance_schema_max_cond_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-cond-instances=#
# System Variable : performance_schema_max_cond_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# 계측 된 조건 개체의 최대 개수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_cond_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_digest_length
# 
# Property : Value
# Command-Line Format : --performance-schema-max-digest-length=#
# System Variable : performance_schema_max_digest_length
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 1024
# Minimum Value : 0
# Maximum Value : 1048576
#
# 성능 스키마에서 정규화 된 명령문 다이제스트 값을 계산하기 위해 명령문 당 예약 된 최대 메모리 바이트 수입니다. 이 변수는 max_digest_length와 관련이 있습니다. 5.1.7 절“서버 시스템 변수”에서 해당 변수에 대한 설명을 참조하십시오.
# 
# 메모리 사용에 대한 고려 사항을 포함하여 명령문 다이제스트에 대한 자세한 내용은 25.10 절“성능 스키마 구문 요약”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_digest_length=1024
# 
# --------------------------------------------
# 
# @ performance_schema_max_file_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-file-classes=#
# System Variable : performance_schema_max_file_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 80
# Minimum Value : 0
# Maximum Value : 256
# 
# 최대 파일 악기 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_file_classes=80
# 
# --------------------------------------------
# 
# @ performance_schema_max_file_handles
# 
# Property : Value
# Command-Line Format : --performance-schema-max-file-handles=#
# System Variable : performance_schema_max_file_handles
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 32768
# 열린 파일 객체의 최대 개수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
# 
# performance_schema_max_file_handles의 값은 open_files_limit의 값보다 커야합니다.
# open_files_limit는 서버가 지원할 수있는 열린 파일 핸들의 최대 수에 영향을 미치고 performance_schema_max_file_handles는 계측 할 수있는 파일 핸들 수에 영향을줍니다.
#
# * Apply Option
# performance_schema_max_file_handles=32768
# 
# --------------------------------------------
# 
# @ performance_schema_max_file_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-file-instances=#
# System Variable : performance_schema_max_file_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# 인스트루먼트 된 파일 오브젝트의 최대 수. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_file_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_index_stat
# 
# Property : Value
# Command-Line Format : --performance-schema-max-index-stat=#
# System Variable : performance_schema_max_index_stat
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# 성능 스키마가 통계를 유지하는 최대 인덱스 수입니다. 이 최대 값을 초과하여 인덱스 통계가 유실되면 Performance Schema는 Performance_schema_index_stat_lost 상태 변수를 증가시킵니다.
# 기본값은 performance_schema_max_table_instances 값을 사용하여 자동 크기 조정됩니다.
#
# * Apply Option
# performance_schema_max_index_stat=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_memory_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-memory-classes=#
# System Variable : performance_schema_max_memory_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 320
#
# 최대 메모리 장치 수 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_memory_classes=320
# 
# --------------------------------------------
# 
# @ performance_schema_max_metadata_locks
# 
# Property : Value
# Command-Line Format : --performance-schema-max-metadata-locks=#
# System Variable : performance_schema_max_metadata_locks
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
#
# 메타 데이터 잠금 장치의 최대 수입니다. 이 값은 metadata_locks 테이블의 크기를 제어합니다. 메타 데이터 잠금을 계측 할 수 없도록이 최대 값을 초과하면 성능 스키마가 Performance_schema_metadata_lock_lost 상태 변수를 증가시킵니다.
#
# * Apply Option
# performance_schema_max_metadata_locks=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_mutex_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-mutex-classes=#
# System Variable : performance_schema_max_mutex_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 200
# Minimum Value : 0
# Maximum Value : 256
#
# 최대 뮤텍스 기기 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_mutex_classes=200
# 
# --------------------------------------------
# 
# @ performance_schema_max_mutex_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-mutex-instances=#
# System Variable : performance_schema_max_mutex_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
#
# 계측 된 뮤텍스 객체의 최대 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 내용은 25.7 절“성능 스키마 상태”를 참조하십시오.
#
# * Apply Option
# performance_schema_max_mutex_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_prepared_statements_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-prepared-statements-instances=#
# System Variable : performance_schema_max_prepared_statements_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
#
# ready_statements_instances 테이블의 최대 행 수입니다.
# 이 최대 값을 초과하여 준비된 명령문을 계측 할 수없는 경우 성능 스키마는 Performance_schema_prepared_statements_lost 상태 변수를 증가시킵니다.
# 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
# 
# 이 변수의 기본값은 max_prepared_stmt_count 시스템 변수의 값을 기반으로 자동 크기 조정됩니다.
#
# * Apply Option
# performance_schema_max_prepared_statements_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_rwlock_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-rwlock-classes=#
# System Variable : performance_schema_max_rwlock_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 40
# Minimum Value : 0
# Maximum Value : 256
#
# 최대 rwlock 기기 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_rwlock_classes=40
# 
# --------------------------------------------
# 
# @ performance_schema_max_program_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-program-instances=#
# System Variable : performance_schema_max_program_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
#
# 성능 스키마가 통계를 유지하는 최대 저장된 프로그램 수입니다. 이 최대 값을 초과하면 성능 스키마가 Performance_schema_program_lost 상태 변수를 증가시킵니다.
# 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_program_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_rwlock_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-rwlock-instances=#
# System Variable : performance_schema_max_rwlock_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# 계측 된 rwlock 객체의 최대 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_rwlock_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_socket_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-socket-classes=#
# System Variable : performance_schema_max_socket_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 10
# Minimum Value : 0
# Maximum Value : 256
# 
# 최대 소켓 계측기 수 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_socket_classes=10
# 
# --------------------------------------------
# 
# @ performance_schema_max_socket_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-socket-instances=#
# System Variable : performance_schema_max_socket_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 계측 된 소켓 개체의 최대 수 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_socket_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_sql_text_length
# 
# Property : Value
# Command-Line Format : --performance-schema-max-sql-text-length=#
# System Variable : performance_schema_max_sql_text_length
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 1024
# Minimum Value : 0
# Maximum Value : 1048576
# events_statements_current, events_statements_history 및 events_statements_history_long 명령문 이벤트 테이블의 SQL_TEXT 컬럼에 SQL 문을 저장하는 데 사용되는 최대 바이트 수입니다.
# performance_schema_max_sql_text_length를 초과하는 바이트는 버려지고 SQL_TEXT 열에 나타나지 않습니다. 이 열에서 많은 초기 바이트를 구분할 수없는 명령문은 구별 할 수 없습니다.
# 
# performance_schema_max_sql_text_length 값을 줄이면 메모리 사용이 줄어들지 만 더 많은 명령문이 끝에서만 다를 경우 구분할 수 없게됩니다. 값을 늘리면 메모리 사용이 증가하지만 더 긴 명령문을 구별 할 수 있습니다.
#
# * Apply Option
# performance_schema_max_sql_text_length=1024
# 
# --------------------------------------------
# 
# @ performance_schema_max_stage_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-stage-classes=#
# System Variable : performance_schema_max_stage_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 150
# Minimum Value : 0
# Maximum Value : 256
#
# 최대 스테이지 악기 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_stage_classes=150
# 
# --------------------------------------------
# 
# @ performance_schema_max_statement_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-statement-classes=#
# System Variable : performance_schema_max_statement_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
#
# 최대 명령문 도구 수 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
# 
# 기본값은 클라이언트 / 서버 프로토콜의 명령 수와 서버가 지원하는 SQL 문 유형 수를 기반으로 서버 빌드시 계산됩니다.
# 
# 모든 명령문 인스 트루먼 테이션을 사용하지 않고 연관된 모든 메모리를 저장하기 위해이 변수를 0으로 설정하지 않으면이 변수를 변경해서는 안됩니다.
# 변수를 기본값 이외의 0이 아닌 값으로 설정하면 아무런 이점이 없습니다. 특히, 기본값보다 큰 값은 더 많은 메모리를 할당해야합니다.
#
# * Apply Option
# performance_schema_max_statement_classes=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_statement_stack
# 
# Property : Value
# Command-Line Format : --performance-schema-max-statement-stack=#
# System Variable : performance_schema_max_statement_stack
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 10
# 성능 스키마가 통계를 유지 보수하는 중첩 된 저장 프로그램 호출의 최대 깊이. 이 최대 값을 초과하면 성능 스키마는 실행 된 각 저장된 프로그램 명령문에 대해 Performance_schema_nested_statement_lost 상태 변수를 증가시킵니다.
#
# * Apply Option
# performance_schema_max_statement_stack=10
# 
# --------------------------------------------
# 
# @ performance_schema_max_table_handles
# 
# Property : Value
# Command-Line Format : --performance-schema-max-table-handles=#
# System Variable : performance_schema_max_table_handles
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (자동 확장을 나타냅니다.이 리터럴 값을 할당하지 마십시오)
# 
# 열린 테이블 개체의 최대 개수입니다. 이 값은 table_handles 테이블의 크기를 제어합니다.
# 이 최대 값을 초과하여 테이블 핸들을 계측 할 수없는 경우 성능 스키마는 Performance_schema_table_handles_lost 상태 변수를 증가시킵니다.
# 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_table_handles=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_table_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-table-instances=#
# System Variable : performance_schema_max_table_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
#
# 인스트루먼트 된 테이블 오브젝트의 최대 수. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_table_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_table_lock_stat
# 
# Property : Value
# Command-Line Format : --performance-schema-max-table-lock-stat=#
# System Variable : performance_schema_max_table_lock_stat
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
#
# 성능 스키마가 잠금 통계를 유지하는 최대 테이블 수입니다. 이 최대 값을 초과하여 테이블 잠금 통계가 유실되면 성능 스키마는 Performance_schema_table_lock_stat_lost 상태 변수를 증가시킵니다.
#
# * Apply Option
# performance_schema_max_table_lock_stat=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_thread_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-thread-classes=#
# System Variable : performance_schema_max_thread_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 50
# Minimum Value : 0
# Maximum Value : 256
#
# 최대 스레드 악기 수 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_thread_classes=50
# 
# --------------------------------------------
# 
# @ performance_schema_max_thread_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-thread-instances=#
# System Variable : performance_schema_max_thread_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# 계측 된 스레드 객체의 최대 수입니다. 이 값은 스레드 테이블의 크기를 제어합니다. 이 최대 값을 초과하여 스레드를 계측 할 수없는 경우 성능 스키마는 Performance_schema_thread_instances_lost 상태 변수를 증가시킵니다.
# 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
# 
# max_connections 시스템 변수는 서버에서 실행할 수있는 스레드 수에 영향을줍니다. performance_schema_max_thread_instances는 계측 할 수있는 실행중인 스레드 수에 영향을줍니다.
# 
# variables_by_thread 및 status_by_thread 테이블에는 포 그라운드 스레드에 대한 시스템 및 상태 변수 정보 만 포함됩니다. 모든 스레드가 성능 스키마에 의해 계측되지 않으면이 테이블에서 일부 행이 누락됩니다.
# 이 경우 Performance_schema_thread_instances_lost 상태 변수는 0보다 큽니다.
#
# * Apply Option
# performance_schema_max_thread_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_session_connect_attrs_size
# 
# Property : Value
# Command-Line Format : --performance-schema-session-connect-attrs-size=#
# System Variable : performance_schema_session_connect_attrs_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : -1
# Maximum Value : 1048576
#
# 연결 속성 키-값 쌍을 보유하도록 예약 된 스레드 당 사전 할당 된 메모리의 양입니다.
# 클라이언트가 전송 한 연결 속성 데이터의 총 크기가이 양보다 큰 경우 성능 스키마는 속성 데이터를 자르고 Performance_schema_session_connect_attrs_lost 상태 변수를 증가시키고 log_error_verbosity 시스템 변수 값인 경우
# 잘림이 발생했음을 나타내는 메시지를 오류 로그에 기록합니다. 1보다 큽니다.
# 
# performance_schema_session_connect_attrs_size의 기본값은 서버 시작시 자동 크기 조정됩니다. 이 값은 작을 수 있으므로 잘림이 발생하면 (Performance_schema_session_connect_attrs_lost가 0이 아닌 경우)
# performance_schema_session_connect_attrs_size를 명시 적으로 더 큰 값으로 설정할 수 있습니다.
# 
# 허용되는 최대 performance_schema_session_connect_attrs_size 값은 1MB이지만 서버는 허용 할 연결 속성 데이터의 총 크기에 64KB를 제한하므로 유효 최대 값은 64KB입니다.
# 클라이언트가 64KB 이상의 속성 데이터를 보내려고하면 서버가 연결을 거부합니다. 자세한 내용은 25.12.9 절.“성능 스키마 연결 속성 테이블”을 참조하십시오.
#
# * Apply Option
# performance_schema_session_connect_attrs_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_setup_actors_size
# 
# Property : Value
# Command-Line Format : --performance-schema-setup-actors-size=#
# System Variable : performance_schema_setup_actors_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# setup_actors 테이블의 행 수입니다.
#
# * Apply Option
# performance_schema_setup_actors_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_setup_objects_size
# 
# Property : Value
# Command-Line Format : --performance-schema-setup-objects-size=#
# System Variable : performance_schema_setup_objects_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# setup_objects 테이블의 행 수입니다.
#
# * Apply Option
# performance_schema_setup_objects_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_users_size
# 
# Property : Value
# Command-Line Format : --performance-schema-users-size=#
# System Variable : performance_schema_users_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# Minimum Value : -1 (signifies autoscaling; do not assign this literal value)
# Maximum Value : 1048576
#
# users 테이블의 행 수입니다. 이 변수가 0이면 성능 스키마는 users 테이블의 연결 통계 또는 status_by_user 테이블의 상태 변수 정보를 유지하지 않습니다.
#
# * Apply Option
# performance_schema_users_size=-1



# ------------------------------------------------------------
# -------------Session & Client Track 관련 옵션들.-------------
# ------------------------------------------------------------
#
# @ session_track_gtids
# 
# Property : Value
# Command-Line Format : --session-track-gtids=value
# System Variable : session_track_gtids
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values  : OFF, OWN_GTID, ALL_GTIDS
# 
# 서버가 현재 세션 내에서 GTID를 추적하여 클라이언트에 반환할지 여부를 제어합니다. 변수 값에 따라 각 트랜잭션 실행이 끝날 때 서버 GTID가 추적 프로그램에 의해 캡처되어 클라이언트로 리턴됩니다. 다음 session_track_gtids 값이 허용됩니다.
# 
# -OFF : 트래커가 GTID를 수집하지 않습니다. 이것이 기본값입니다.
# -OWN_GTID : 추적기는 성공적으로 커밋 된 읽기 / 쓰기 트랜잭션에 의해 생성 된 GTID를 수집합니다.
# -ALL_GTIDS : 추적기는 트랜잭션이 읽기 / 쓰기 또는 읽기 전용인지에 관계없이 현재 트랜잭션이 커밋 될 때 gtid_executed 시스템 변수에서 모든 GTID를 수집합니다.
# 
# session_track_gtids는 트랜잭션 컨텍스트 내에서 설정할 수 없습니다.
# 
# 세션 상태 추적에 대한 자세한 내용은 5.1.14 절“클라이언트 세션 상태 변경에 대한 서버 추적”을 참조하십시오.
#
# * Apply Option
# session_track_gtids=OFF
# 
# --------------------------------------------
# 
# @ session_track_schema
# 
# Property : Value
# Command-Line Format : --session-track-schema[={OFF|ON}]
# System Variable : session_track_schema
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 서버가 기본 세션 (데이터베이스)이 현재 세션 내에 설정되는시기를 추적하고 클라이언트에게 스키마 이름을 사용할 수 있도록 알립니다.
# 스키마 이름 추적기가 사용 가능한 경우, 새 스키마 이름이 이전 이름과 동일하더라도 기본 스키마가 설정 될 때마다 이름 알림이 발생합니다.
# 세션 상태 추적에 대한 자세한 내용은 5.1.14 절“클라이언트 세션 상태 변경에 대한 서버 추적”을 참조하십시오.
#
# * Apply Option
# session_track_schema=ON
# 
# --------------------------------------------
# 
# @ session_track_state_change
# 
# Property : Value
# Command-Line Format : --session-track-state-change[={OFF|ON}]
# System Variable : session_track_state_change
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 서버가 현재 세션 상태의 변경 사항을 추적하는지 여부를 제어하고 상태 변경이 발생하면 클라이언트에게 알립니다. 클라이언트 세션 상태의 다음 속성에 대한 변경 사항을보고 할 수 있습니다.
# 
# -기본 스키마 (데이터베이스).
# -시스템 변수에 대한 세션 별 값.
# -사용자 정의 변수.
# -임시 테이블.
# -준비된 진술.
# 
# 세션 상태 추적기가 사용 가능한 경우 새 속성 값이 이전과 동일하더라도 추적 된 세션 속성과 관련된 각 변경에 대해 알림이 발생합니다. 예를 들어, 사용자 정의 변수를 현재 값으로 설정하면 알림이 생성됩니다.
# 
# session_track_state_change 변수는 변경 내용이 아닌 변경 사항이 발생한시기에 대한 알림 만 제어합니다.
# 예를 들어, 상태 변경 알림은 기본 스키마가 설정되거나 추적 된 세션 시스템 변수가 할당 될 때 발생하지만 알림에는 스키마 이름 또는 변수 값이 포함되지 않습니다.
# 스키마 이름 또는 세션 시스템 변수 값에 대한 알림을 받으려면 각각 session_track_schema 또는 session_track_system_variables 시스템 변수를 사용하십시오.
#
# * Apply Option
# session_track_state_change=OFF
# 
# --------------------------------------------
# 
# @ session_track_system_variables
# 
# Property : Value
# Command-Line Format : --session-track-system-variables=#
# System Variable : session_track_system_variables
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# Default Value : time_zone, autocommit, character_set_client, character_set_results, character_set_connection
# 
# 서버가 세션 시스템 변수에 대한 지정을 추적하고 클라이언트에게 지정된 각 변수의 이름과 값을 통지하는지 여부를 제어합니다. 변수 값은 할당을 추적 할 쉼표로 구분 된 변수 목록입니다.
# 기본적으로 time_zone, 자동 커밋, character_set_client, character_set_results 및 character_set_connection에 대해 알림이 사용됩니다. 후자의 세 변수는 SET NAMES의 영향을받는 변수입니다.
# 특수 값 *은 서버가 모든 세션 변수에 대한 지정을 추적하게합니다. 주어진 경우이 값은 특정 시스템 변수 이름없이 자체적으로 지정해야합니다.
# 세션 변수 할당 알림을 비활성화하려면 session_track_system_variables를 빈 문자열로 설정하십시오.
# 세션 시스템 변수 추적이 사용 가능한 경우 새 값이 이전 값과 동일하더라도 추적 된 세션 변수에 대한 모든 지정에 대해 알림이 발생합니다.
# 세션 상태 추적에 대한 자세한 내용은 5.1.14 절“클라이언트 세션 상태 변경에 대한 서버 추적”을 참조하십시오.
#
# * Apply Option
# session_track_system_variables=time_zone, autocommit, character_set_client, character_set_results, character_set_connection
# 
# --------------------------------------------
# 
# @ session_track_transaction_info
# 
# Property : Value
# Command-Line Format : --session-track-transaction-info=value
# System Variable : session_track_transaction_info
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values	OFF, STATE, CHARACTERISTICS
# 
# 서버가 현재 세션 내 트랜잭션의 상태와 특성을 추적하는지 여부를 제어하고 클라이언트에게이 정보를 제공하도록 알립니다. 다음 session_track_transaction_info 값이 허용됩니다.
# 
# -OFF : 트랜잭션 상태 추적을 비활성화합니다. 이것이 기본값입니다.
# -상태 : 특성 추적없이 트랜잭션 상태 추적을 사용합니다. 상태 추적을 통해 클라이언트는 트랜잭션이 진행 중인지 여부와 롤백하지 않고 다른 세션으로 이동할 수 있는지 여부를 결정할 수 있습니다.
# -특성 : 특성 추적을 포함하여 트랜잭션 상태 추적을 활성화합니다. 특성 추적을 통해 클라이언트는 다른 세션에서 트랜잭션을 다시 시작하는 방법을 판별하여 원래 세션과 동일한 특성을 갖도록 할 수 있습니다. 다음과 같은 특성이이 목적과 관련이 있습니다.
# ISOLATION LEVEL
# READ ONLY 
# READ WRITE
# WITH CONSISTENT SNAPSHOT
# 
# 클라이언트가 트랜잭션을 다른 세션으로 안전하게 재배치하려면 트랜잭션 상태뿐만 아니라 트랜잭션 특성도 추적해야합니다.
# 또한 클라이언트는 transaction_isolation 및 transaction_read_only 시스템 변수를 추적하여 세션 기본값을 올바르게 결정해야합니다.
# 이러한 변수를 추적하려면 session_track_system_variables 시스템 변수의 값에 변수를 나열하십시오.
# 
# 세션 상태 추적에 대한 자세한 내용은 5.1.14 절“클라이언트 세션 상태 변경에 대한 서버 추적”을 참조하십시오.
#
# * Apply Option
# session_track_transaction_info=OFF
#
# ===============================================================================
# ========================== Replication Parameter  =============================
# ===============================================================================
# 
# -------------------------------------------------------------------------------
# -------------Replication Master Options and Variables--------------------------
# -------------------------------------------------------------------------------
# 
# @ --show-slave-auth-info
# 
# Property : Value
# Command-Line Format : --show-slave-auth-info[={OFF|ON}]
# Type : Boolean
# Default Value : OFF
#
# --report-user 및 --report-password 옵션으로 시작한 슬레이브에 대한 마스터 서버의 SHOW SLAVE HOSTS 출력에 슬레이브 사용자 이름 및 비밀번호를 표시합니다.
#
# * Apply Option
# show-slave-auth-info=OFF
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_enabled
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-enabled[={OFF|ON}]
# System Variable : rpl_semi_sync_master_enabled
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 마스터에서 반동기 복제를 사용할지 여부를 제어합니다. 플러그인을 활성화 또는 비활성화 하려면 이 변수를 각각 ON 또는 OFF (또는 1 또는 0)로 설정하십시오. 기본 설정은 OFF입니다.
# 이 변수는 마스터 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_master_enabled=OFF
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_timeout
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-timeout=#
# System Variable : rpl_semi_sync_master_timeout
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10000
#
# 시간 초과 및 비동기 복제로 되돌리기 전에 마스터가 슬레이브로부터 승인을 받기 위해 커밋을 기다리는 시간을 제어하는 밀리 초 단위의 값입니다. 기본값은 10000 (10 초)입니다.
# 
# 이 변수는 마스터 측 반동기 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_master_timeout=10000
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_trace_level
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-trace-level=#
# System Variable : rpl_semi_sync_master_trace_level
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 32
# 
# 마스터에서 반 동기식 복제 디버그 추적 수준입니다. 네 가지 수준이 정의됩니다.
# 1 = 일반 수준 (예 : 시간 함수 실패)
# 16 = 세부 수준 (보다 자세한 정보)
# 32 = 순 대기 수준 (네트워크 대기에 대한 자세한 정보)
# 64 = 기능 수준 (기능 입력 및 종료에 대한 정보)
# 
# 이 변수는 마스터 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.#
# * Apply Option
# rpl_semi_sync_master_trace_level=32
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_wait_for_slave_count
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-wait-for-slave-count=#
# System Variable : rpl_semi_sync_master_wait_for_slave_count
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1
# Minimum Value : 1
# Maximum Value : 65535
# 
# 진행하기 전에 마스터가 트랜잭션 당 수신해야하는 슬레이브 승인 수입니다.
# 기본적으로 rpl_semi_sync_master_wait_for_slave_count는 1입니다.
# 이는 단일 슬레이브 승인을받은 후 반 동기식 복제가 진행됨을 의미합니다. 이 변수의 작은 값에 성능이 가장 좋습니다.
# 
# 예를 들어, rpl_semi_sync_master_wait_for_slave_count가 2 인 경우, 2 개의 슬레이브가 rpl_semi_sync_master_timeout에 의해 구성된 시간 초과 기간 전에 반동기 복제가 진행되도록 트랜잭션 수신을 승인해야합니다.
# 시간 초과 기간 동안 적은 수의 슬레이브가 트랜잭션 수신을 확인하면 마스터는 일반 복제로 돌아갑니다.
# 
# 노트
# 이 동작은 rpl_semi_sync_master_wait_no_slave에 따라 다릅니다.
# 
# 이 변수는 마스터 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_master_wait_for_slave_count=1
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_wait_no_slave
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-wait-no-slave[={OFF|ON}]
# System Variable : rpl_semi_sync_master_wait_no_slave
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 시간 초과 기간 동안 슬레이브 수가 rpl_semi_sync_master_wait_for_slave_count에 의해 구성된 슬레이브 수보다 적더라도 rpl_semi_sync_master_timeout으로 구성된 시간 초과 기간 동안 마스터가 대기하는지 여부를 제어합니다.
# 
# rpl_semi_sync_master_wait_no_slave의 값이 ON (기본값) 인 경우 제한 시간 동안 슬레이브 카운트가 rpl_semi_sync_master_wait_for_slave_count보다 작게 떨어질 수 있습니다.
# 시간 종료 기간이 만료되기 전에 충분한 슬레이브가 트랜잭션을 승인하면 반 동기식 복제가 계속됩니다.
# 
# rpl_semi_sync_master_wait_no_slave의 값이 OFF 인 경우, rpl_semi_sync_master_timeout에 의해 구성된 시간 초과 기간 동안
# 언제라도 슬레이브 카운트가 rpl_semi_sync_master_wait_for_slave_count에 구성된 수보다 작게 떨어지면 마스터는 일반 복제로 되돌아갑니다.
# 
# 이 변수는 마스터 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_master_wait_no_slave=ON
# 
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_master_wait_point
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-master-wait-point=value
# System Variable : rpl_semi_sync_master_wait_point
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : AFTER_SYNC
# Valid Values  : AFTER_SYNC, AFTER_COMMIT
# 
# 이 변수는 트랜잭션을 커밋 한 클라이언트에 상태를 반환하기 전에 세미 동기식 복제 마스터가 트랜잭션 수신의 슬레이브 승인을 기다리는 지점을 제어합니다. 이 값들은 허용됩니다 :
# + AFTER_SYNC (기본값) : 마스터는 각 트랜잭션을 이진 로그 및 슬레이브에 기록하고 이진 로그를 디스크에 동기화합니다.
# 마스터는 동기화 후 트랜잭션 수신에 대한 슬레이브 승인을 기다립니다. 승인을 받으면 마스터는 트랜잭션을 스토리지 엔진에 커밋하고 결과를 클라이언트에 반환 한 다음 진행할 수 있습니다.
# + AFTER_COMMIT : 마스터는 각 트랜잭션을 이진 로그에 기록하고 슬레이브는 이진 로그를 동기화하고 트랜잭션을 스토리지 엔진에 커밋합니다.
# 마스터는 커밋 후 트랜잭션 수신에 대한 슬레이브 승인을 기다립니다. 승인을 받으면 마스터는 결과를 클라이언트에 반환 한 다음 진행할 수 있습니다.
# 
# 이러한 설정의 복제 특성은 다음과 같이 다릅니다.
# + AFTER_SYNC를 사용하면 모든 클라이언트가 커밋 된 트랜잭션을 동시에 볼 수 있습니다. 슬레이브에 의해 승인되고 마스터의 스토리지 엔진에 커밋 된 후. 따라서 모든 클라이언트는 마스터에서 동일한 데이터를 봅니다.
# 마스터 장애가 발생하면 마스터에서 커밋 된 모든 트랜잭션이 슬레이브로 복제됩니다 (중계 로그에 저장 됨).
# 슬레이브가 최신 상태이므로 마스터 충돌 및 슬레이브 장애 조치는 손실이 없습니다.
# 그러나이 시나리오에서 마스터를 다시 시작할 수 없으며 이진 로그 복구 후 외부화 될 때 슬레이브와 충돌하는 커밋되지 않은 트랜잭션이 바이너리 로그에 포함될 수 있기 때문에 버려야합니다.
# + AFTER_COMMIT를 사용하면 트랜잭션을 발행하는 클라이언트는 서버가 스토리지 엔진에 커밋하고 슬레이브 승인을받은 후에 만 ​​반환 상태를 얻습니다.
# 커밋 후 및 슬레이브 승인 전에 다른 클라이언트는 커밋 클라이언트 전에 커밋 된 트랜잭션을 볼 수 있습니다.
# 
# 슬레이브가 트랜잭션을 처리하지 않는 문제가 발생하면 마스터 충돌 및 슬레이브 장애 조치가 발생하는 경우 해당 클라이언트가 마스터에서 본 것과 관련하여 데이터가 손실 될 수 있습니다.
# 
# 이 변수는 마스터 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
# rpl_semi_sync_master_wait_point는 MySQL 5.7.2에서 추가되었습니다. 이전 버전의 경우 반동기 마스터 동작은 AFTER_COMMIT 설정과 같습니다.
# 
# 이 변경 사항은 세미 동기식 인터페이스 버전을 증가시키기 때문에 버전 호환성 제약이 도입되었습니다.
# MySQL 5.7.2 이상의 서버는 이전 버전의 반 동기식 복제 플러그인과 작동하지 않으며, 이전 버전의 서버는 MySQL 5.7.2 이상의 반 동기식 복제 플러그인과 작동하지 않습니다.
#
# * Apply Option
# rpl_semi_sync_master_wait_point=AFTER_SYNC
# 
# 
# ---------------------------------------------------------------------------
# -----------Replication Slave Options and Variables-------------------------
# ---------------------------------------------------------------------------
# 
# @ --master-info-file=file_name
# 
# Property : Value
# Command-Line Format : --master-info-file=file_name
# Type : File name
# Default Value : master.info
# 
# 슬레이브가 마스터에 대한 정보를 기록하는 파일에 사용할 이름입니다.
# 기본 이름은 데이터 디렉토리의 master.info입니다.
# 이 파일의 형식에 대한 자세한 내용은 16.2.4.2 절“슬레이브 상태 로그”를 참조하십시오.
#
# * Apply Option
# master-info-file=file_name=master.info
# 
# --------------------------------------------
# 
# @ --max-relay-log-size=size
# 
# Property : Value
# Command-Line Format : --max-relay-log-size=#
# System Variable : max_relay_log_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 1073741824
# 
# 서버가 릴레이 로그 파일을 자동으로 회전시키는 크기입니다. 이 값이 0이 아니면 릴레이 로그의 크기가이 값을 초과하면 자동으로 회전됩니다.
# 이 값이 0(기본값)이면 릴레이 로그 회전이 발생하는 크기는 max_binlog_size 값에 의해 결정됩니다. 자세한 내용은 16.2.4.1 절“슬레이브 릴레이 로그”를 참조하십시오.
#
# * Apply Option
# max-relay-log-size=-1
# 
# --------------------------------------------
# 
# @ --relay-log-purge={0|1}
# 
# Property : Value
# Command-Line Format : --relay-log-purge[={OFF|ON}]
# System Variable : relay_log_purge
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 더 이상 필요하지 않은 즉시 릴레이 로그 자동 제거를 비활성화하거나 활성화하십시오. 기본값은 1(사용)입니다.
# SET GLOBAL relay_log_purge = N을 사용하여 동적으로 변경할 수있는 전역 변수입니다.
# --relay-log-recovery 옵션을 활성화 할 때 릴레이 로그 제거를 비활성화하면 데이터 일관성이 위험 해집니다.
#
# * Apply Option
# relay-log-purge=ON
# 
# --------------------------------------------
# 
# @ --relay-log-space-limit=size
# 
# Property : Value
# Command-Line Format : --relay-log-space-limit=#
# System Variable : relay_log_space_limit
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 이 옵션은 슬레이브에있는 모든 릴레이 로그의 총 크기에 대한 상한을 바이트 단위로 설정합니다. 값이 0이면 "제한 없음"을 의미합니다.
# 디스크 공간이 제한된 슬레이브 서버 호스트에 유용합니다. 한계에 도달하면, I / O 스레드는 SQL 스레드가 사용되지 않은 일부 릴레이 로그를 따라 잡을 때까지 마스터 서버에서 2 진 로그 이벤트 읽기를 중지합니다.
# 이 한계는 절대적인 것은 아닙니다. SQL 스레드가 릴레이 로그를 삭제하기 전에 더 많은 이벤트가 필요한 경우가 있습니다.
# 이 경우 I / O 스레드가 제한을 초과하면 SQL 스레드가 일부 릴레이 로그를 삭제할 수있을 때까지 교착 상태가 발생할 수 있습니다.
# --relay-log-space-limit 값을 --max-relay-log-size 값 (또는 --max-relay-log-size가 0 인 경우 --max-binlog-size 값의 두 배 미만으로 설정하지 않아야합니다.).
# 이 경우 --relay-log-space-limit가 초과되어 I / O 스레드가 여유 공간을 기다릴 가능성이 있지만 SQL 스레드에는 제거 할 릴레이 로그가없고 I / O를 만족시킬 수 없습니다.
# 실. 그러면 I / O 스레드가 --relay-log-space-limit를 일시적으로 무시합니다.
#
# * Apply Option
# relay-log-relay-log-space-limit=0
# 
# --------------------------------------------
# 
# @ --replicate-do-db=db_name
# 
# Property : Value
# Command-Line Format : --replicate-do-db=name
# Type : String
# 
# 데이터베이스 이름을 사용하여 복제 필터를 만듭니다. 이러한 필터는 CHANGE REPLICATION FILTER REPLICATE_DO_DB를 사용하여 만들 수도 있습니다.
# 이 필터링의 정확한 효과는 명령문 기반 복제 또는 행 기반 복제의 사용 여부에 따라 다르며 다음 몇 단락에서 설명됩니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 
# ### Statement-based replication. ###
# 기본 데이터베이스 (USE에서 선택한 데이터베이스)가 db_name 인 명령문으로 복제를 제한하도록 슬레이브 SQL 스레드에 지시하십시오. 둘 이상의 데이터베이스를 지정하려면 각 데이터베이스에 대해이 옵션을 여러 번 사용하십시오.
# 그러나 이렇게하면 다른 데이터베이스 (또는 데이터베이스 없음)가 선택된 동안 UPDATE some_db.some_table SET foo = 'bar'와 같은 데이터베이스 간 문을 복제하지 않습니다.
# 
# 경고
# 여러 데이터베이스를 지정하려면이 옵션의 여러 인스턴스를 사용해야합니다. 데이터베이스 이름은 쉼표를 포함 할 수 있으므로 쉼표로 구분 된 목록을 제공하면 목록이 단일 데이터베이스의 이름으로 취급됩니다.
# 
# 명령문 기반 복제를 사용할 때 예상대로 작동하지 않는 예 : 슬레이브가 --replicate-do-db = sales로 시작되고 마스터에서 다음 명령문을 발행하면 UPDATE 문이 복제되지 않습니다.
# 
# USE prices;
# UPDATE sales.january SET amount=amount+1000;
# 이“기본 데이터베이스 만 검사”동작의 주된 이유는 명령문만으로는 복제 여부를 알기가 어렵 기 때문입니다 (예 : 다중 테이블 DELETE 문 또는 다중 테이블 UPDATE 문을 사용하는 경우) 여러 데이터베이스에서).
# 필요하지 않은 경우 모든 데이터베이스가 아닌 기본 데이터베이스 만 확인하는 것이 더 빠릅니다.
# 
# 
# ### Row-based replication. ###
# 슬레이브 SQL 스레드에게 복제를 데이터베이스 db_name으로 제한하도록 지시합니다. db_name에 속하는 테이블 만 변경됩니다. 현재 데이터베이스는 이에 영향을 미치지 않습니다.
# 슬레이브가 --replicate-do-db = sales로 시작되고 행 기반 복제가 적용되고 마스터에서 다음 명령문이 실행된다고 가정하십시오.
# 
# USE prices;
# UPDATE sales.february SET amount=amount+100;
# 슬레이브의 영업 데이터베이스에있는 2 월 테이블은 UPDATE 문에 따라 변경됩니다. 이것은 USE 문이 발행되었는지 여부에 관계없이 발생합니다.
# 그러나 마스터에서 다음 명령문을 발행해도 행 기반 복제 및 --replicate-do-db = sales를 사용할 때 슬레이브에 영향을 미치지 않습니다.
# 
# USE prices;
# UPDATE prices.march SET amount=amount-25;
# USE 가격 명세서가 USE 판매로 변경 되더라도 UPDATE 문의 효과는 여전히 복제되지 않습니다.
# 
# 여러 데이터베이스를 참조하는 문과 관련하여 행 기반 복제와 달리 행 기반 복제와 달리 --replicate-do-db가 문 기반 복제에서 처리되는 방식의 또 다른 중요한 차이점입니다.
# 슬레이브가 --replicate-do-db = db1로 시작되고 마스터에서 다음 명령문이 실행된다고 가정하십시오.
# 
# USE db1;
# UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
# 명령문 기반 복제를 사용하는 경우 두 테이블이 모두 슬레이브에서 업데이트됩니다. 그러나 행 기반 복제를 사용하는 경우 table1 만 슬레이브에서 영향을받습니다.
# table2는 다른 데이터베이스에 있으므로 슬레이브의 table2는 UPDATE에 의해 변경되지 않습니다. 이제 USE db1 문 대신 USE db4 문이 사용되었다고 가정합니다.
# 
# USE db4;
# UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
# 이 경우 명령문 기반 복제를 사용할 때 UPDATE 문은 슬레이브에 영향을 미치지 않습니다. 그러나 행 기반 복제를 사용하는 경우 UPDATE는 슬레이브의 table1을 변경하지만 table2는 변경하지 않습니다.
# 즉, --replicate-do-db로 이름 지정된 데이터베이스의 테이블 만 변경되고 기본값은 선택됩니다. 데이터베이스는이 동작에 영향을 미치지 않습니다.
# 
# 데이터베이스 간 업데이트가 필요하면 --replicate-wild-do-table = db_name. %를 대신 사용하십시오. 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
# 
# 노트
# 이 옵션은 --binlog-do-db가 이진 로깅에 영향을 미치는 것과 같은 방식으로 복제에 영향을 미치며 --replicate-do-db가 복제 동작에 미치는 영향에 대한 복제 형식의 영향은 복제 형식의 영향과 동일합니다.
# --binlog-do-db의 동작이 옵션은 BEGIN, COMMIT 또는 ROLLBACK 문에는 영향을 미치지 않습니다.
#
# * Apply Option
# replicate-do-db=db_name
#
# --------------------------------------------
# 
# @ --replicate-ignore-db=db_name
# 
# Property : Value
# Command-Line Format : --replicate-ignore-db=name
# Type : String
# 
# 데이터베이스 이름을 사용하여 복제 필터를 만듭니다. 이러한 필터는 CHANGE REPLICATION FILTER REPLICATE_IGNORE_DB를 사용하여 만들 수도 있습니다.
# --replicate-do-db와 마찬가지로이 필터링의 정확한 효과는 명령문 기반 또는 행 기반 복제의 사용 여부에 따라 다르며 다음 몇 단락에서 설명됩니다.
# 
# Note
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# ### Statement-based replication. ###
# 기본 데이터베이스 (USE가 선택한 데이터베이스)가 db_name 인 명령문을 복제하지 않도록 슬레이브 SQL 스레드에 지시합니다.
# 
# ### Row-based replication. ###
# 슬레이브 SQL 스레드가 db_name 데이터베이스의 테이블을 갱신하지 않도록 지시합니다. 기본 데이터베이스는 영향을 미치지 않습니다.
# 
# 명령문 기반 복제를 사용할 때 다음 예제는 예상대로 작동하지 않습니다. 슬레이브가 --replicate-ignore-db = sales로 시작되고 마스터에서 다음 명령문을 발행한다고 가정하십시오.
# 
# USE prices;
# UPDATE sales.january SET amount=amount+1000;
# --replicate-ignore-db는 기본 데이터베이스 (USE 문으로 결정)에만 적용되므로 UPDATE 문은 이러한 경우에 복제됩니다.
# 판매 데이터베이스가 명령문에 명시 적으로 지정되었으므로 명령문이 필터링되지 않았습니다.
# 그러나 행 기반 복제를 사용할 때 UPDATE 문의 효과는 슬레이브로 전파되지 않으며 슬레이브의 sales.january 테이블 사본은 변경되지 않습니다.
# 이 경우 --replicate-ignore-db = sales는 마스터의 판매 데이터베이스 복사본에있는 테이블의 모든 변경 사항이 슬레이브에 의해 무시되도록합니다.
# 
# 무시할 둘 이상의 데이터베이스를 지정하려면 각 데이터베이스에 대해이 옵션을 여러 번 사용하십시오. 데이터베이스 이름은 쉼표를 포함 할 수 있으므로 쉼표로 구분 된 목록을 제공하면 목록이 단일 데이터베이스의 이름으로 취급됩니다.
# 
# 데이터베이스 간 업데이트를 사용하고 있고 이러한 업데이트를 복제하지 않으려는 경우이 옵션을 사용하지 마십시오. 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
# 
# 데이터베이스 간 업데이트가 필요하면 --replicate-wild-ignore-table = db_name. %를 대신 사용하십시오. 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
# 
# 노트
# 이 옵션은 --binlog-ignore-db가 이진 로깅에 영향을 미치는 것과 같은 방식으로 복제에 영향을 미치며 --replicate-ignore-db가 복제 동작에 미치는 영향에 대한 복제 형식의 영향은 복제 형식의 영향과 동일합니다.
# --binlog-ignore-db의 동작이 옵션은 BEGIN, COMMIT 또는 ROLLBACK 문에는 영향을 미치지 않습니다.
#
# * Apply Option
# replicate-ignore-db=db_name
# 
# --------------------------------------------
# 
# @ --replicate-do-table=db_name.tbl_name
# 
# Property : Value
# Command-Line Format : --replicate-do-table=name
# Type : String
# 
# 슬레이브 SQL 스레드에 지정된 테이블로 복제를 제한하도록 지시하여 복제 필터를 작성합니다.
# 둘 이상의 테이블을 지정하려면 각 테이블에 대해이 옵션을 여러 번 사용하십시오. --replicate-do-db와 달리 데이터베이스 간 업데이트와 기본 데이터베이스 업데이트 모두에서 작동합니다.
# 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오. CHANGE REPLICATION FILTER REPLICATE_DO_TABLE 문을 발행하여 이러한 필터를 작성할 수도 있습니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 이 옵션은 테이블에 적용되는 명령문에만 영향을줍니다. 스토어드 루틴과 같은 다른 데이터베이스 오브젝트에만 적용되는 명령문에는 영향을 미치지 않습니다.
# 스토어드 루틴에서 작동하는 명령문을 필터링하려면 하나 이상의 --replicate-*-db 옵션을 사용하십시오.
#
# * Apply Option
# replicate-do-table=db_name.tbl_name
# 
# --------------------------------------------
# 
# @ --replicate-ignore-table=db_name.tbl_name
# 
# Property : Value
# Command-Line Format : --replicate-ignore-table=name
# Type : String
# 
# 동일한 명령문으로 다른 테이블을 업데이트하더라도 슬레이브 SQL 스레드가 지정된 테이블을 업데이트하는 명령문을 복제하지 않도록 지시하여 복제 필터를 작성합니다.
# 무시할 테이블을 두 개 이상 지정하려면 각 테이블마다 한 번씩이 옵션을 여러 번 사용하십시오.
# --replicate-ignore-db와 달리 데이터베이스 간 업데이트에 적용됩니다. 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
# CHANGE REPLICATION FILTER REPLICATE_IGNORE_TABLE 문을 발행하여 이러한 필터를 작성할 수도 있습니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 이 옵션은 테이블에 적용되는 명령문에만 영향을줍니다. 스토어드 루틴과 같은 다른 데이터베이스 오브젝트에만 적용되는 명령문에는 영향을 미치지 않습니다.
# 스토어드 루틴에서 작동하는 명령문을 필터링하려면 하나 이상의 --replicate-*-db 옵션을 사용하십시오.
#
# * Apply Option
# --replicate-ignore-table=db_name.tbl_name
# 
# --------------------------------------------
# 
# @ --replicate-rewrite-db=from_name->to_name
# 
# Property : Value
# Command-Line Format : --replicate-rewrite-db=old_name->new_name
# Type : String
# 
# 슬레이브가 기본 데이터베이스 (USE에서 선택한 데이터베이스)를 마스터의 from_name 인 경우 to_name으로 변환하는 복제 필터를 작성하도록 지시합니다.
# from_name이 마스터의 기본 데이터베이스 인 경우에만 테이블 관련 명령문 만 영향을받습니다 (CREATE DATABASE, DROP DATABASE 및 ALTER DATABASE와 같은 명령문은 아님).
#  다시 쓰기를 여러 번 지정하려면이 옵션을 여러 번 사용하십시오. 서버는 일치하는 from_name 값을 가진 첫 번째 서버를 사용합니다.
#  --replicate- * 규칙을 테스트하기 전에 데이터베이스 이름 변환이 수행됩니다. CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB 문을 발행하여 이러한 필터를 작성할 수도 있습니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 이 옵션을 사용할 때 테이블 이름이 데이터베이스 이름으로 규정 된 명령문은 --replicate-do-table과 같은 테이블 레벨 복제 필터링 옵션에서 작동하지 않습니다.
# 마스터에 a라는 데이터베이스, 슬레이브에 b라는 데이터베이스, 각각 테이블 t를 포함하고 --replicate-rewrite-db = 'a-> b'로 마스터를 시작했다고 가정합니다.
# 나중에 우리는 DELETE FROM a.t를 실행합니다. 이 경우 다음과 같은 이유로 관련 필터링 규칙이 작동하지 않습니다.
# 
# a. 슬레이브가 데이터베이스 b에 테이블 t를 가지고 있기 때문에 --replicate-do-table = a.t가 작동하지 않습니다.
# b. --replicate-do-table = b.t는 원래 문장과 일치하지 않으므로 무시됩니다.
# c. --replicate-do-table = *. t는 --replicate-do-table = a.t와 동일하게 처리되므로 작동하지 않습니다.
# 마찬가지로 --replication-rewrite-db 옵션은 데이터베이스 간 업데이트에서 작동하지 않습니다.
# 
# 명령 행에서이 옵션을 사용하고> 문자가 명령 해석기에 특수한 경우 옵션 값을 인용하십시오. 예를 들면 다음과 같습니다.
# shell> mysqld --replicate-rewrite-db = "olddb-> newdb"
#
# * Apply Option
# replicate-rewrite-db=from_name->to_name
# 
# --------------------------------------------
# 
# @ --replicate-same-server-id
# 
# Property : Value
# Command-Line Format : --replicate-same-server-id[={OFF|ON}]
# Type : Boolean
# Default Value : OFF
# 
# 슬레이브 서버에서 사용됩니다. 일반적으로 순환 복제로 인한 무한 루프를 방지하려면 기본 설정 인 0을 사용해야합니다.
# 1로 설정하면 슬레이브는 자체 서버 ID가있는 이벤트를 건너 뛰지 않습니다. 일반적으로 이는 드문 구성에서만 유용합니다.
# log_slave_updates가 활성화 된 경우 1로 설정할 수 없습니다.
# 기본적으로 슬레이브 I / O 스레드는 슬레이브 서버 ID가있는 경우 이진 로그 이벤트를 릴레이 로그에 쓰지 않습니다 (이 최적화는 디스크 사용량을 절약하는 데 도움이 됨).
# --replicate-same-server-id를 사용하려면 슬레이브 SQL 스레드가 실행할 자체 이벤트를 슬레이브가 읽기 전에이 옵션으로 슬레이브를 시작해야합니다.
#
# * Apply Option
# replicate-same-server-id
# 
# --------------------------------------------
# 
# @ --replicate-wild-do-table=db_name.tbl_name
# 
# Property : Value
# Command-Line Format : --replicate-wild-do-table=name
# Type : String
# 
# 업데이트 된 테이블이 지정된 데이터베이스 및 테이블 이름 패턴과 일치하는 명령문으로 복제를 제한하도록 슬레이브 스레드에 지시하여 복제 필터를 작성합니다.
# 패턴은 % 및 _ 와일드 카드 문자를 포함 할 수 있으며 LIKE 패턴 일치 연산자와 동일한 의미를 갖습니다.
# 둘 이상의 테이블을 지정하려면 각 테이블에 대해이 옵션을 여러 번 사용하십시오. 이것은 데이터베이스 간 업데이트에 적용됩니다.
# 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오. CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE 문을 발행하여 이러한 필터를 작성할 수도 있습니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 이 옵션은 테이블, 뷰 및 트리거에 적용됩니다.
# 저장 프로 시저 및 함수 또는 이벤트에는 적용되지 않습니다. 후자의 오브젝트에서 작동하는 명령문을 필터링하려면 하나 이상의 --replicate-*-db 옵션을 사용하십시오.
# 
# 예를 들어 --replicate-wild-do-table = foo % .bar %는 데이터베이스 이름이 foo로 시작하고 테이블 이름이 bar로 시작하는 테이블을 사용하는 업데이트 만 복제합니다.
# 
# 테이블 이름 패턴이 % 인 경우 테이블 이름 패턴과 일치하며 옵션은 데이터베이스 레벨 명령문 (CREATE DATABASE, DROP DATABASE 및 ALTER DATABASE)에도 적용됩니다.
# 예를 들어 --replicate-wild-do-table = foo %. %를 사용하는 경우 데이터베이스 이름이 foo % 패턴과 일치하면 데이터베이스 수준 문이 복제됩니다.
# 
# 데이터베이스 또는 테이블 이름 패턴에 리터럴 와일드 카드 문자를 포함 시키려면 백 슬래시로 이스케이프 처리하십시오.
# 예를 들어, my_own % db라는 데이터베이스의 모든 테이블을 복제하지만 my1ownAABCdb 데이터베이스에서 테이블을 복제하지 않으려면 다음과 같이 _ 및 % 문자를 이스케이프해야합니다.
# --replicate-wild-do-table = my \ _own \ % db. 명령 행에서 옵션을 사용하는 경우 명령 인터프리터에 따라 백 슬래시를 두 배로 늘리거나 옵션 값을 인용해야합니다.
# 예를 들어, bash 쉘을 사용하면 --replicate-wild-do-table = my \\ _ own \\ % db를 입력해야합니다.
#
# * Apply Option
# replicate-wild-do-table=db_name.tbl_name
# 
# --------------------------------------------
# 
# @ --replicate-wild-ignore-table=db_name.tbl_name
# 
# Property : Value
# Command-Line Format : --replicate-wild-ignore-table=name
# Type : String
# 
# 슬레이브 필터가 지정된 와일드 카드 패턴과 일치하는 테이블을 명령문에서 복제하지 못하도록하는 복제 필터를 작성합니다.
# 무시할 테이블을 두 개 이상 지정하려면 각 테이블마다 한 번씩이 옵션을 여러 번 사용하십시오. 이것은 데이터베이스 간 업데이트에 적용됩니다.
# 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
# CHANGE REPLICATION FILTER REPLICATE_WILD_IGNORE_TABLE 문을 발행하여 이러한 필터를 작성할 수도 있습니다.
# 
# 노트
# 일부 서버에서 트랜잭션을 필터링하면 그룹이 일관된 상태에서 동의에 도달 할 수 없으므로 그룹 복제 용으로 구성된 MySQL 서버 인스턴스에서 복제 필터를 사용할 수 없습니다.
# 
# 예를 들어 --replicate-wild-ignore-table = foo % .bar %는 데이터베이스 이름이 foo로 시작하고 테이블 이름이 bar로 시작하는 테이블을 사용하는 업데이트를 복제하지 않습니다.
# 일치하는 방법에 대한 자세한 내용은 --replicate-wild-do-table 옵션에 대한 설명을 참조하십시오.
# 옵션 값에 리터럴 와일드 카드 문자를 포함시키는 규칙은 --replicate-wild-ignore-table과 동일합니다.
#
# * Apply Option
# replicate-wild-ignore-table=db_name.tbl_name
# 
# --------------------------------------------
# 
# @ --skip-slave-start
# 
# Property : Value
# Command-Line Format : --skip-slave-start[={OFF|ON}]
# Type : Boolean
# Default Value : OFF
# 
# 서버가 시작될 때 슬레이브 서버가 슬레이브 스레드를 시작하지 않도록 지시합니다. 나중에 스레드를 시작하려면 START SLAVE 문을 사용하십시오.
#
# * Apply Option
# skip-slave-start=OFF
# 
# --------------------------------------------
# 
# @ --slave-skip-errors=[err_code1,err_code2,...|all|ddl_exist_errors]
# 
# Property : Value
# Command-Line Format : --slave-skip-errors=name
# System Variable : slave_skip_errors
# Scope : Global
# Dynamic : No
# Type : String
# Default Value : OFF
# Valid Values  : OFF, [list of error codes], all, ddl_exist_errors
# 
# 일반적으로 슬레이브에서 오류가 발생하면 복제가 중지되므로 데이터의 불일치를 수동으로 해결할 수 있습니다. 이 옵션은 명령문이 옵션 값에 나열된 오류를 리턴 할 때 슬레이브 SQL 스레드가 복제를 계속하게합니다.
# 
# 오류가 발생하는 이유를 완전히 이해하지 않으면이 옵션을 사용하지 마십시오. 복제 설정 및 클라이언트 프로그램에 버그가없고 MySQL 자체에 버그가없는 경우 복제를 중지하는 오류가 발생하지 않아야합니다.
# 이 옵션을 무차별 적으로 사용하면 슬레이브가 마스터와 동기화되지 않게되어 왜 이런 일이 발생했는지 알 수 없습니다.
# 
# 오류 코드의 경우 슬레이브 오류 로그 및 SHOW SLAVE STATUS 출력에 오류 메시지가 제공 한 숫자를 사용해야합니다.
# 부록 B, 오류, 오류 코드 및 일반적인 문제에는 서버 오류 코드가 나와 있습니다.
# 
# 속기 값 ddl_exist_errors는 오류 코드 목록 1007,1008,1050,1051,1054,1060,1061,1068,1094,1146과 같습니다.
# 
# 또한 권장하지 않는 all 값을 사용하여 슬레이브가 모든 오류 메시지를 무시하고 상황에 관계없이 계속 진행할 수 있습니다. 말할 것도없이, 모두를 사용하면 데이터의 무결성에 대한 보장이 없습니다.
# 이 경우 슬레이브의 데이터가 마스터에있는 데이터와 가까운 곳에 있지 않은 경우이 경우 불평하거나 파일 버그 보고서를 작성하지 마십시오. 경고를 받았습니다.
# 
# 예제:
# --slave-skip-errors=1062,1053
# --slave-skip-errors=all
# --slave-skip-errors=ddl_exist_errors
#
# * Apply Option
# slave-skip-errors=OFF
# 
# --------------------------------------------
# 
# @ --slave-sql-verify-checksum={0|1}
# 
# Property : Value
# Command-Line Format : --slave-sql-verify-checksum[={OFF|ON}]
# Type : Boolean
# Default Value : ON
# When this option is enabled, the slave examines checksums read from the relay log, in the event of a mismatch, the slave stops with an error.
# 
# 다음 옵션은 복제 테스트 및 디버깅을 위해 MySQL 테스트 스위트에서 내부적으로 사용됩니다. 프로덕션 환경에서 사용하기위한 것이 아닙니다.
#
# * Apply Option
# slave-sql-verify-checksum=ON
# 
# --------------------------------------------
# 
# @ --abort-slave-event-count
# 
# Property : Value
# Command-Line Format : --abort-slave-event-count=#
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# 
# 이 옵션을 0 (기본값) 이외의 양의 정수 값으로 설정하면 다음과 같이 복제 동작에 영향을줍니다.
# 슬레이브 SQL 스레드가 시작된 후 값 로그 이벤트가 실행될 수 있습니다. 그 후 슬레이브 마스터 스레드는 마스터의 네트워크 연결이 끊어진 것처럼 더 이상 이벤트를받지 않습니다.
# 슬레이브 스레드는 계속 실행되고 SHOW SLAVE STATUS의 출력은 Slave_IO_Running 및 Slave_SQL_Running 열 모두에 Yes를 표시하지만 릴레이 로그에서 더 이상 이벤트를 읽지 않습니다.
#
# * Apply Option
# abort-slave-event-count=0
# 
# --------------------------------------------
# 
# @ --disconnect-slave-event-count
# 
# Property : Value
# Command-Line Format : --disconnect-slave-event-count=#
# Type : Integer
# Default Value : 0
#
# * Apply Option
# disconnect-slave-event-count=0
# 
# --------------------------------------------
# 
# @ init_slave
# 
# Property : Value
# Command-Line Format : --init-slave=name
# System Variable : init_slave
# Scope : Global
# Dynamic : Yes
# Type : String
# 
# 이 변수는 init_connect와 유사하지만 SQL 스레드가 시작될 때마다 슬레이브 서버가 실행하는 문자열입니다.
# 문자열의 형식은 init_connect 변수의 형식과 동일합니다. 이 변수의 설정은 후속 START SLAVE 문에 적용됩니다.
# 
# 노트
# SQL 스레드는 init_slave를 실행하기 전에 클라이언트에게 승인을 보냅니다. 따라서 START SLAVE가 리턴 될 때 init_slave가 실행되었다는 보장이 없습니다.
# 자세한 내용은 13.4.2.6 절“START SLAVE 문”을 참조하십시오.
#
# * Apply Option
# init_slave=none
# 
# 
# --------------------------------------------
# 
# @ log_slow_slave_statements
# 
# Property : Value
# Command-Line Format : --log-slow-slave-statements[={OFF|ON}]
# System Variable : log_slow_slave_statements
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 느린 쿼리 로그가 활성화되면이 변수는 슬레이브에서 long_query_time 초 이상 실행 된 쿼리에 대한 로깅을 활성화합니다.
# 행 기반 복제가 사용중인 경우 (binlog_format = ROW) log_slow_slave_statements는 영향을 미치지 않습니다.
# 바이너리 로그에서 명령문 형식으로 로그인 할 때, 즉 binlog_format = STATEMENT가 설정되거나 binlog_format = MIXED가 설정되고,
# 명령문이 명령문 형식으로 로깅 된 경우에만 쿼리가 슬레이브의 느린 쿼리 로그에 추가됩니다.
# binlog_format = MIXED가 설정 될 때 행 형식으로 기록되거나 binlog_format = ROW가 설정 될 때 기록 된 느린 쿼리는 log_slow_slave_statements가 활성화되어 있어도 슬레이브의 느린 쿼리 로그에 추가되지 않습니다.
# 
# log_slow_slave_statements를 설정해도 즉각적인 효과는 없습니다. 변수 상태는 모든 후속 START SLAVE 문에 적용됩니다.
# 또한 long_query_time에 대한 전역 설정은 SQL 스레드 수명 동안 적용됩니다.
# 해당 설정을 변경하면 슬레이브의 SQL 스레드를 중지했다가 다시 시작하여 변경을 구현해야합니다 (예 : SQL_THREAD 옵션으로 STOP SLAVE 및 START SLAVE 문을 발행하여).
#
# * Apply Option
# log_slow_slave_statements=OFF
# 
# --------------------------------------------
# 
# @ master_info_repository
# 
# Property : Value
# Command-Line Format : --master-info-repository={FILE|TABLE}
# System Variable : master_info_repository
# Scope : Global
# Dynamic : Yes
# Type : String
# Default Value : FILE
# Valid Values  : FILE, TABLE
# 
# 이 변수의 설정은 슬레이브 서버가 마스터 상태 및 연결 정보를 FILE (master.info) 또는 TABLE (mysql.slave_master_info)에 기록할지 여부를 결정합니다.
# 복제 스레드가 실행되고 있지 않을 때만이 변수의 값을 변경할 수 있습니다.
# 
# 이 변수의 설정은 sync_master_info 시스템 변수의 설정에 의한 영향에 직접적인 영향을 미칩니다. 자세한 내용은 해당 변수 설명을 참조하십시오.
# 
# FILE 로깅의 경우 --master-info-file server 옵션을 사용하여 파일 이름을 변경할 수 있습니다.
# 
# 여러 복제 채널을 구성하기 전에이 변수를 TABLE로 설정해야합니다. 여러 복제 채널을 사용하는 경우 값을 다시 FILE로 설정할 수 없습니다.
#
# * Apply Option
# master_info_repository=FILE
# 
# --------------------------------------------
# 
# @ max_relay_log_size
# 
# Property : Value
# Command-Line Format : --max-relay-log-size=#
# System Variable : max_relay_log_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 1073741824
# 
# 복제 슬레이브가 릴레이 로그에 쓸 때 현재 로그 파일 크기가이 변수의 값을 초과하면 슬레이브는 릴레이 로그를 회전시킵니다 (현재 파일을 닫고 다음 파일을 엽니다).
# max_relay_log_size가 0이면 서버는 이진 로그 및 릴레이 로그 모두에 max_binlog_size를 사용합니다.
# max_relay_log_size가 0보다 크면 릴레이 로그의 크기가 제한되므로 두 로그에 대해 서로 다른 크기를 가질 수 있습니다.
# max_relay_log_size를 4096 바이트와 1GB (포함) 또는 0으로 설정해야합니다. 기본값은 0입니다. 16.2.2 절“복제 구현 세부 사항”을 참조하십시오.
#
# * Apply Option
# max_relay_log_size=0
# 
# --------------------------------------------
# 
# @ relay_log
# 
# Property : Value
# Command-Line Format : --relay-log=file_name
# System Variable : relay_log
# Scope : Global
# Dynamic : No
# Type : File name
# 
# 릴레이 로그 파일의 기본 이름입니다. 기본 복제 채널의 경우 릴레이 로그의 기본 이름은 host_name-relay-bin입니다.
# 기본이 아닌 복제 채널의 경우 릴레이 로그의 기본 이름은 host_name-relay-bin-channel입니다. 여기서 channel은이 릴레이 로그에 기록 된 복제 채널의 이름입니다.
# 
# 다른 이름을 지정하기 위해 기본 이름에 선행 절대 경로 이름이 지정되지 않은 한 서버는 파일을 데이터 디렉토리에 씁니다.
# 서버는 기본 이름에 숫자 접미 부를 추가하여 릴레이 로그 파일을 순서대로 작성합니다.
# 
# MySQL이 서버 옵션을 구문 분석하는 방식으로 인해 서버 시작시이 변수를 지정하면 값을 제공해야합니다. 옵션이 실제로 지정되지 않은 경우에만 기본 기본 이름이 사용됩니다.
# 서버 시작시 값을 지정하지 않고 relay_log 시스템 변수를 지정하면 예기치 않은 동작이 발생할 수 있습니다.
# 이 동작은 사용 된 다른 옵션, 지정된 순서 및 명령 줄 또는 옵션 파일에 지정되어 있는지에 따라 다릅니다. MySQL이 서버 옵션을 처리하는 방법에 대한 자세한 내용은 4.2.2 절“프로그램 옵션 지정”을 참조하십시오.
# 
# 이 변수를 지정하면 지정된 값이 릴레이 로그 색인 파일의 기본 이름으로도 사용됩니다.
# relay_log_index 시스템 변수를 사용하여 다른 릴레이 로그 인덱스 파일 기본 이름을 지정하여이 동작을 무시할 수 있습니다.
# 
# 서버는 색인 파일에서 항목을 읽을 때 항목에 상대 경로가 포함되어 있는지 확인합니다. 그렇다면 경로의 상대 부분이 relay_log 시스템 변수를 사용하여 설정된 절대 경로로 바뀝니다.
# 절대 경로는 변경되지 않습니다. 이 경우 새 경로를 사용할 수 있도록 색인을 수동으로 편집해야합니다.
# 
# 다음 작업을 수행하는 데 relay_log 시스템 변수가 유용 할 수 있습니다.
# 
# - 이름이 호스트 이름과 독립적 인 릴레이 로그 생성.
# - 릴레이 로그가 매우 큰 경향이 있고 max_relay_log_size를 줄이고 싶지 않기 때문에 데이터 디렉토리 이외의 다른 영역에 릴레이 로그를 넣어야하는 경우.
# - 디스크간 로드 균형 조정을 사용하여 속도를 향상시킵니다.
# 
# relay_log_basename 시스템 변수에서 릴레이 로그 파일 이름 및 경로를 얻을 수 있습니다.
#
# * Apply Option
# relay_log=direcoty/relay_log_filename
# 
# --------------------------------------------
# 
# @ relay_log_basename
# 
# Property : Value
# System Variable : relay_log_basename
# Scope : Global
# Dynamic : No
# Type : File name
# 
# Default Value : datadir + '/' + hostname + '-relay-bin'
# Holds the name and complete path to the relay log file. This variable is set by the server and is read only.
# 기본값 datadir + '/'+ hostname + '-relay-bin'
# 릴레이 로그 파일의 이름과 전체 경로를 보유합니다. 이 변수는 서버에 의해 설정되며 읽기 전용입니다.
#
# * Apply Option
# relay_log_basename=relay_log_basename
# 
# --------------------------------------------
# 
# @ relay_log_index
# 
# Property : Value
# Command-Line Format : --relay-log-index=file_name
# System Variable : relay_log_index
# Scope : Global
# Dynamic : No
# Type : File name
# Default Value : *host_name*-relay-bin.index
# 
# 릴레이 로그 인덱스 파일의 이름입니다. 기본 복제 채널의 기본 이름은 host_name-relay-bin.index입니다.
# 기본이 아닌 복제 채널의 경우 기본 이름은 host_name-relay-bin-channel.index입니다. 여기서 channel은이 릴레이 로그 인덱스에 기록 된 복제 채널의 이름입니다.
# 
# 다른 디렉토리를 지정하기 위해 이름에 선행 절대 경로 이름이 지정되지 않은 한 서버는 파일을 데이터 디렉토리에 기록합니다. 이름.
# 
# MySQL이 서버 옵션을 구문 분석하는 방식으로 인해 서버 시작시이 변수를 지정하면 값을 제공해야합니다. 옵션이 실제로 지정되지 않은 경우에만 기본 기본 이름이 사용됩니다.
# 서버 시작시 값을 지정하지 않고 relay_log_index 시스템 변수를 지정하면 예기치 않은 동작이 발생할 수 있습니다.
# 이 동작은 사용 된 다른 옵션, 지정된 순서 및 명령 줄 또는 옵션 파일에 지정되어 있는지에 따라 다릅니다. MySQL이 서버 옵션을 처리하는 방법에 대한 자세한 내용은 4.2.2 절“프로그램 옵션 지정”을 참조하십시오.
#
# * Apply Option
# relay_log_index=*host_name*-relay-bin.index
# 
# --------------------------------------------
# 
# @ relay_log_info_file
# 
# Property : Value
# Command-Line Format : --relay-log-info-file=file_name
# System Variable : relay_log_info_file
# Scope : Global
# Dynamic : No
# Type : File name
# Default Value : relay-log.info
# 
# relay_log_info_repository = FILE 인 경우 슬레이브가 릴레이 로그에 대한 정보를 기록하는 파일의 이름입니다.
# relay_log_info_repository = TABLE 인 경우 리포지토리가 FILE로 변경된 경우에 사용되는 파일 이름입니다. 기본 이름은 데이터 디렉토리의 relay-log.info입니다.
#
# * Apply Option
# relay_log_info_file=relay-log.info
# 
# --------------------------------------------
# 
# @ relay_log_info_repository
# 
# Property : Value
# Command-Line Format : --relay-log-info-repository=value
# System Variable : relay_log_info_repository
# Scope : Global
# Dynamic : Yes
# Type : String
# Default Value : FILE
# Valid Values  : FILE, TABLE
# 
# 이 변수는 릴레이 로그에서 슬레이브의 위치가 FILE (relay-log.info) 또는 TABLE (mysql.slave_relay_log_info)에 기록되는지 여부를 결정합니다.
# 복제 스레드가 실행되고 있지 않을 때만이 변수의 값을 변경할 수 있습니다.
# 
# 이 변수의 설정은 또한 sync_relay_log_info 시스템 변수의 설정에 의한 영향에 직접적인 영향을 미칩니다. 자세한 내용은 해당 변수 설명을 참조하십시오.
# 
# 여러 복제 채널을 구성하기 전에이 변수를 TABLE로 설정해야합니다. 다중 복제 채널을 사용하는 경우 값을 다시 FILE로 설정할 수 없습니다.
#
# * Apply Option
# relay_log_info_repository=FILE
# 
# --------------------------------------------
# 
# @ relay_log_purge
# 
# Property : Value
# Command-Line Format : --relay-log-purge[={OFF|ON}]
# System Variable : relay_log_purge
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 더 이상 필요하지 않은 즉시 릴레이 로그 파일 자동 제거를 비활성화하거나 활성화합니다. 기본값은 1 (ON)입니다.
#
# * Apply Option
# relay_log_purge=ON
# 
# --------------------------------------------
# 
# @ relay_log_recovery
# 
# Property : Value
# Command-Line Format : --relay-log-recovery[={OFF|ON}]
# System Variable : relay_log_recovery
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : OFF
# 
# 사용 가능한 경우 이 변수는 서버 시작 직후에 자동 릴레이 로그 복구를 사용합니다.
# 복구 프로세스는 새 릴레이 로그 파일을 작성하고이 새 릴레이 로그로 SQL 스레드 위치를 초기화 한 후 I / O 스레드를 SQL 스레드 위치로 초기화합니다.
# 그런 다음 마스터에서 릴레이 로그를 읽습니다. 이 전역 변수는 런타임시 읽기 전용입니다. 슬레이브 시작시 --relay-log-recovery 옵션을 사용하여 값을 설정할 수 있습니다.
# 이 옵션은 예상치 못한 복제 슬레이브 중단 후 릴레이 로그가 손상되지 않도록 사용해야합니다. 이 옵션을 사용하면 슬레이브가 예기치 않은 중지에 대해 복원력을 갖도록 할 수 있습니다.
# 자세한 내용은 16.3.2 절“예상치 않은 복제 슬레이브 중지 처리”를 참조하십시오.
# 
# 이 변수는 더 이상 필요하지 않을 때 로그 제거를 제어하는 ​​relay_log_purge 변수와 상호 작용합니다.
# relay_log_purge가 비활성화 된 경우 relay_log_recovery를 활성화하면 제거되지 않은 파일에서 릴레이 로그를 읽을 때 데이터가 일치하지 않을 위험이 있습니다.
# 
# 멀티 스레드 슬레이브를 사용할 때 (즉, slave_parallel_workers가 0보다 큰 경우) 릴레이 로그에서 실행 된 트랜잭션 순서에서 간격과 같은 불일치가 발생할 수 있습니다.
# 불일치가있을 때 relay_log_recovery를 활성화하면 오류가 발생하고 옵션이 적용되지 않습니다.
# 이 상황에서 해결책은 서버를보다 일관된 상태로 만드는 START SLAVE UNTIL SQL_AFTER_MTS_GAPS를 발행 한 다음 RESET SLAVE를 발행하여 릴레이 로그를 제거하는 것입니다.
# 자세한 내용은 16.4.1.32 절“복제 및 트랜잭션 불일치”를 참조하십시오.
# 
# 노트
# 이 변수는 다음 그룹 복제 채널에 영향을 미치지 않습니다.
# - group_replication_applier
# - group_replication_recovery
# 
# 외부 마스터 나 다른 그룹에서 복제되는 채널과 같이 그룹에서 실행중인 다른 모든 채널이 영향을받습니다.
#
# * Apply Option
# relay_log_recovery=OFF
# 
# --------------------------------------------
# 
# @ report_host
# 
# Property : Value
# Command-Line Format : --report-host=host_name
# System Variable : report_host
# Scope : Global
# Dynamic : No
# Type : String
# 
# 슬레이브 등록 중에 마스터에보고 할 슬레이브의 호스트 이름 또는 IP 주소입니다.
# 이 값은 마스터 서버의 SHOW SLAVE HOSTS 출력에 나타납니다. 슬레이브가 마스터에 자신을 등록하지 않게하려면 값을 설정하지 않은 상태로 두십시오.
# 
# 노트
# 슬레이브가 연결된 후 마스터가 단순히 TCP / IP 소켓에서 슬레이브의 IP 주소를 읽는 것으로 충분하지 않습니다.
# NAT 및 기타 라우팅 문제로 인해 해당 IP가 마스터 또는 다른 호스트에서 슬레이브에 연결하는 데 유효하지 않을 수 있습니다.
#
# * Apply Option
# report_host=host_name
# 
# --------------------------------------------
# 
# @ report_password
# 
# Property : Value
# Command-Line Format : --report-password=name
# System Variable : report_password
# Scope : Global
# Dynamic : No
# Type : String
# 
# 슬레이브 등록 중에 마스터에보고 될 슬레이브의 계정 비밀번호입니다. 마스터가 --show-slave-auth-info로 시작된 경우이 값은 마스터 서버의 SHOW SLAVE HOSTS 출력에 나타납니다.
# 
# 이 변수의 이름이 달리 암시 할 수도 있지만 report_password는 MySQL 사용자 권한 시스템에 연결되어 있지 않으므로 MySQL 복제 사용자 계정의 암호와 반드시 같거나 같을 필요는 없습니다.
#
# * Apply Option
# report_password=none
# 
# --------------------------------------------
# 
# @ report_port
# 
# Property : Value
# Command-Line Format : --report-port=port_num
# System Variable : report_port
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : [slave_port]
# Minimum Value : 0
# Maximum Value : 65535
# 
# 슬레이브 등록시 슬레이브에 연결하기위한 TCP / IP 포트 번호가 마스터에보고됩니다.
# 슬레이브가 기본 포트가 아닌 포트에서 수신 대기 중이거나 마스터 또는 다른 클라이언트에서 슬레이브로의 특수 터널이있는 경우에만 설정하십시오. 확실하지 않으면이 옵션을 사용하지 마십시오.
# 
# 이 옵션의 기본값은 슬레이브가 실제로 사용하는 포트 번호입니다. SHOW SLAVE HOSTS에 의해 표시되는 기본값이기도합니다.
#
# * Apply Option
# report_port=slave_port
# 
# --------------------------------------------
# 
# @ report_user
# 
# Property : Value
# Command-Line Format : --report-user=name
# System Variable : report_user
# Scope : Global
# Dynamic : No
# Type : String
# 
# 슬레이브 등록 중에 마스터에보고 될 슬레이브의 계정 사용자 이름입니다. 마스터가 --show-slave-auth-info로 시작된 경우이 값은 마스터 서버의 SHOW SLAVE HOSTS 출력에 나타납니다.
# 
# 이 변수의 이름은 달리 의미 할 수 있지만 report_user는 MySQL 사용자 권한 시스템에 연결되어 있지 않으므로 MySQL 복제 사용자 계정의 이름과 반드시 ​​같거나 같을 필요는 없습니다.
#
# * Apply Option
# report_user=username
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_slave_enabled
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-slave-enabled[={OFF|ON}]
# System Variable : rpl_semi_sync_slave_enabled
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 슬레이브에서 반동기 복제를 사용할지 여부를 제어합니다. 플러그인을 활성화 또는 비활성화하려면이 변수를 각각 ON 또는 OFF (또는 1 또는 0)로 설정하십시오. 기본 설정은 OFF입니다.
# 
# 이 변수는 슬레이브 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_slave_enabled=OFF
# 
# --------------------------------------------
# 
# @ rpl_semi_sync_slave_trace_level
# 
# Property : Value
# Command-Line Format : --rpl-semi-sync-slave-trace-level=#
# System Variable : rpl_semi_sync_slave_trace_level
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 32
# 
# 슬레이브의 반 동기식 복제 디버그 추적 수준입니다. 허용 가능한 값은 rpl_semi_sync_master_trace_level을 참조하십시오.
# 
# 이 변수는 슬레이브 측 반 동기식 복제 플러그인이 설치된 경우에만 사용할 수 있습니다.
#
# * Apply Option
# rpl_semi_sync_slave_trace_level=32
# 
# --------------------------------------------
# 
# @ rpl_stop_slave_timeout
# 
# Property : Value
# Command-Line Format : --rpl-stop-slave-timeout=seconds
# System Variable : rpl_stop_slave_timeout
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 31536000
# Minimum Value : 2
# Maximum Value : 31536000
# 
# 이 변수를 설정하여 시간 초과 전에 STOP SLAVE가 대기하는 시간 (초)을 제어 할 수 있습니다.
# 이는 슬레이브에 대한 다른 클라이언트 연결을 사용하여 STOP SLAVE와 다른 슬레이브 SQL 문 사이의 교착 상태를 피하기 위해 사용할 수 있습니다.
# 
# rpl_stop_slave_timeout의 최대 값과 기본값은 31536000 초 (1 년)입니다. 최소값은 2 초입니다. 이 변수에 대한 변경 사항은 후속 STOP SLAVE 문에 적용됩니다.
# 
# 이 변수는 STOP SLAVE 문을 발행하는 클라이언트에만 영향을줍니다. 시간 종료에 도달하면 발행 클라이언트는 명령 실행이 완료되지 않았다는 오류 메시지를 리턴합니다.
# 그런 다음 클라이언트는 슬레이브 스레드가 중지되기를 기다리는 것을 중지하지만 슬레이브 스레드는 계속 중지를 시도하고 STOP SLAVE 명령은 계속 유효합니다.
# 슬레이브 스레드가 더 이상 사용되지 않으면 STOP SLAVE 문이 실행되고 슬레이브가 중지됩니다.
#
# * Apply Option
# rpl_stop_slave_timeout=31536000
# 
# --------------------------------------------
# 
# @ slave_checkpoint_group
# 
# Property : Value
# Command-Line Format : --slave-checkpoint-group=#
# System Variable : slave_checkpoint_group
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 512
# Minimum Value : 32
# Maximum Value : 524280
# Block Size	8
# 
# SHOW SLAVE STATUS에 표시된대로 상태를 업데이트하기 위해 검사 점 작업을 호출하기 전에 멀티 스레드 슬레이브가 처리 할 수있는 최대 트랜잭션 수를 설정합니다.
# 이 변수를 설정해도 멀티 스레딩이 활성화되지 않은 슬레이브에는 영향을 미치지 않습니다. 이 변수를 설정해도 즉각적인 효과는 없습니다. 변수 상태는 모든 후속 START SLAVE 명령에 적용됩니다.
# 
# 노트
# 멀티 스레드 슬레이브는 현재 NDB 클러스터에서 지원되지 않으며이 변수의 설정을 자동으로 무시합니다. 자세한 내용은 21.6.3 절“NDB 클러스터 복제의 알려진 문제”를 참조하십시오.
# 
# 이 변수는 slave_checkpoint_period 시스템 변수와 함께 작동하여 어느 한도를 초과하면 검사 점이 실행되고 카운터가 트랜잭션 수와 마지막 검사 점 이후 경과 된 시간을 모두 추적하는 카운터가 재설정됩니다.
# 
# 서버가 -DWITH_DEBUG를 사용하여 빌드 된 경우를 제외하고이 변수에 허용되는 최소값은 32입니다.이 경우 최소값은 1입니다. 유효 값은 항상 8의 배수입니다.
# 이 값을 배수가 아닌 값으로 설정할 수 있지만 서버는 값을 저장하기 전에 값을 8의 다음 하위 배수로 내림합니다. (예외 : 디버그 서버는 이러한 반올림을 수행하지 않습니다.)
# 서버의 구축 방법에 관계없이 기본값은 512이고 최대 허용 값은 524280입니다.
#
# * Apply Option
# slave_checkpoint_group=512
# 
# --------------------------------------------
# 
# @ slave_checkpoint_period
# 
# Property : Value
# Command-Line Format : --slave-checkpoint-period=#
# System Variable : slave_checkpoint_period
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 300
# Minimum Value : 1
# Maximum Value : 4G
# 
# SHOW SLAVE STATUS에 표시된대로 멀티 스레드 슬레이브의 상태를 업데이트하기 위해 검사 점 작업을 호출하기 전에 통과 할 수있는 최대 시간 (밀리 초)을 설정합니다.
# 이 변수를 설정해도 멀티 스레딩이 활성화되지 않은 슬레이브에는 영향을 미치지 않습니다. 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# 노트
# 멀티 스레드 슬레이브는 현재 NDB 클러스터에서 지원되지 않으며이 변수의 설정을 자동으로 무시합니다. 자세한 내용은 21.6.3 절“NDB 클러스터 복제의 알려진 문제”를 참조하십시오.
# 
# 이 변수는 한계를 초과 할 때 검사 점이 실행되고 마지막 검사 점 이후의 트랜잭션 수와 경과 시간을 추적하는 카운터가 카운터를 초기화하는 방식으로 slave_checkpoint_group 시스템 변수와 함께 작동합니다.
# 
# 서버가 -DWITH_DEBUG를 사용하여 빌드 된 경우를 제외하고이 변수에 허용되는 최소값은 1입니다. 이 경우 최소값은 0입니다. 서버의 빌드 방법에 관계없이 기본값은 300이며 가능한 최대 값은 4294967296 ( 4GB).
#
# * Apply Option
# slave_checkpoint_period=300
# 
# --------------------------------------------
# 
# @ slave_compressed_protocol
# 
# Property : Value
# Command-Line Format : --slave-compressed-protocol[={OFF|ON}]
# System Variable : slave_compressed_protocol
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 마스터 및 슬레이브 프로토콜이 모두 지원하는 경우 마스터 / 슬레이브 프로토콜의 압축 사용 여부입니다. 이 변수를 비활성화하면 (기본값) 연결이 압축 해제됩니다.
# 이 변수에 대한 변경 사항은 후속 연결 시도에 적용됩니다. 여기에는 START SLAVE 문을 발행 한 후 실행중인 I / O 스레드에 의한 재 연결 (예 : CHANGE MASTER TO 문에 대해 MASTER_RETRY_COUNT 옵션을 설정 한 후)이 포함됩니다.
# 4.2.5 절“연결 압축 제어”도 참조하십시오.
#
# * Apply Option
# slave_compressed_protocol=OFF
# 
# --------------------------------------------
# 
# @ slave_exec_mode
# 
# Property : Value
# Command-Line Format : --slave-exec-mode=mode
# System Variable : slave_exec_mode
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : IDEMPOTENT (NDB), STRICT (Other)
# Valid Values  : IDEMPOTENT, STRICT
# 
# 슬레이브 스레드가 복제 중 충돌 및 오류를 해결하는 방법을 제어합니다. IDEMPOTENT 모드는 중복 키 및 키가없는 오류를 억제합니다. 엄격은 그러한 억제가 일어나지 않음을 의미합니다.
# 
# IDEMPOTENT 모드는 다중 마스터 복제, 순환 복제 및 NDB 클러스터 복제를위한 기타 특수 복제 시나리오에서 사용하기위한 것입니다.
# 자세한 내용은 21.6.10 절“NDB 클러스터 복제 : 다중 마스터 및 순환 복제”및 21.6.11 절“NDB 클러스터 복제 충돌 해결”을 참조하십시오.
# NDB 클러스터는 slave_exec_mode에 대해 명시 적으로 설정된 값을 무시합니다. 항상 그것을 IDEMPOTENT로 취급합니다.
# 
# MySQL Server 5.7에서는 STRICT 모드가 기본값입니다.
# 
# NDB 이외의 스토리지 엔진의 경우 IDEMPOTENT 모드는 중복 키 오류 및 키를 찾을 수 없음 오류를 안전하게 무시할 수있는 경우에만 사용해야합니다.
# 다중 마스터 복제 또는 순환 복제가 사용되는 NDB 클러스터의 페일 오버 시나리오에 사용되며 다른 경우에는 사용하지 않는 것이 좋습니다.
#
# * Apply Option
# slave_exec_mode=IDEMPOTENT (NDB), STRICT (Other)
# 
# --------------------------------------------
# 
# @ slave_load_tmpdir
# 
# Property : Value
# Command-Line Format : --slave-load-tmpdir=dir_name
# System Variable : slave_load_tmpdir
# Scope : Global
# Dynamic : No
# Type : Directory name
# Default Value : Value of --tmpdir
# 
# 슬레이브가 임시 파일을 생성하는 디렉토리의 이름입니다. 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 변수 값은 기본적으로 tmpdir 시스템 변수의 값과 같거나 해당 시스템 변수가 지정되지 않은 경우 적용되는 기본값입니다.
# 
# 슬레이브 SQL 스레드는 LOAD DATA 문을 복제 할 때 릴레이 로그에서 임시 파일로로드 할 파일을 추출한 다음 테이블에로드합니다.
# 마스터에로드 된 파일이 크면 슬레이브의 임시 파일도 커집니다. 따라서이 옵션을 사용하여 임시 파일을 사용 가능한 공간이 많은 일부 파일 시스템에있는 디렉토리에 두도록 지시하는 것이 좋습니다.
# 이 경우 릴레이 로그도 매우 커서 릴레이 파일을 해당 파일 시스템에 배치하도록 relay_log 시스템 변수를 설정할 수도 있습니다.
# 
# 이 옵션으로 지정된 디렉토리는 메모리 기반 파일 시스템이 아닌 디스크 기반 파일 시스템에 있어야 LOAD DATA 문을 복제하는 데 사용 된 임시 파일이 시스템을 다시 시작하더라도 살아남을 수 있습니다.
# 또한 디렉토리는 시스템 시작 프로세스 중에 운영 체제가 지우는 디렉토리가 아니어야합니다. 그러나 임시 파일을 제거한 경우 다시 시작한 후 복제를 계속할 수 있습니다.
#
# * Apply Option
# slave_load_tmpdir=dir_name
# 
# --------------------------------------------
# 
# @ slave_max_allowed_packet
# 
# Property : Value
# Command-Line Format : --slave-max-allowed-packet=#
# System Variable : slave_max_allowed_packet
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1073741824
# Minimum Value : 1024
# Maximum Value : 1073741824
# 
# 이 변수는 슬레이브 SQL 및 I / O 스레드의 최대 패킷 크기를 설정하므로 업데이트가 max_allowed_packet을 초과하여 행 기반 복제를 사용하는 대규모 업데이트로 인해 복제가 실패하지 않습니다.
# 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# 이 전역 변수는 항상 1024의 양의 정수 배수 인 값을 갖습니다. 그렇지 않은 값으로 설정하면 값이 저장되거나 사용되므로 1024의 다음으로 가장 높은 배수로 내림됩니다.
# slave_max_allowed_packet을 0으로 설정하면 1024가 사용됩니다. (이러한 경우 모두 잘림 경고가 발생합니다.) 기본값 및 최대 값은 1073741824 (1GB)입니다. 최소값은 1024입니다.
#
# * Apply Option
# slave_max_allowed_packet=1073741824
# 
# --------------------------------------------
# 
# @ slave_net_timeout
# 
# Property : Value
# Command-Line Format : --slave-net-timeout=#
# System Variable : slave_net_timeout
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 60
# Minimum Value : 1
# 
# 슬레이브가 연결이 끊어진 것으로 간주하고 읽기를 중단 한 후 다시 연결하려고 시도하기 전에 마스터로부터 더 많은 데이터 또는 하트 비트 신호를 기다리는 시간 (초)입니다.
# 이 변수를 설정해도 즉각적인 효과는 없습니다. 변수 상태는 모든 후속 START SLAVE 명령에 적용됩니다.
# 
# 첫 번째 재 시도는 시간 종료 직후에 발생합니다. 재시도 간격은 CHANGE MASTER TO 문의 MASTER_CONNECT_RETRY 옵션으로 제어되며 재 연결 시도 횟수는 CHANGE MASTER TO 문의 MASTER_RETRY_COUNT 옵션으로 제한됩니다.
# 
# 연결 상태가 양호 할 경우 데이터가 없을 때 발생하는 연결 시간 초과를 중지시키는 하트 비트 간격은 CHANGE MASTER TO 문에 대한 MASTER_HEARTBEAT_PERIOD 옵션으로 제어됩니다.
# 하트 비트 간격은 기본적으로 slave_net_timeout 값의 절반으로 설정되며 마스터 정보 로그에 기록되고 replication_connection_configuration 성능 스키마 테이블에 표시됩니다.
# slave_net_timeout의 값 또는 기본 설정을 변경해도 하트 비트 간격이 명시 적으로 설정되었는지 또는 이전에 계산 된 기본값을 사용하는지에 관계없이 자동으로 변경되지는 않습니다.
# 연결 시간 종료가 변경되면 CHANGE MASTER TO도 변경하여 연결 시간 종료 전에 발생하는 하트 비트 간격을 적절한 값으로 조정해야합니다.
#
# * Apply Option
# slave_net_timeout=60
# 
# --------------------------------------------
# 
# @ slave_parallel_type
# 
# Property : Value
# Command-Line Format : --slave-parallel-type=value
# System Variable : slave_parallel_type
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : DATABASE
# Valid Values  : DATABASE, LOGICAL_CLOCK
# 
# 다중 스레드 슬레이브를 사용하는 경우 (slave_parallel_workers가 0보다 큰 경우)이 변수는 슬레이브에서 병렬로 실행할 수있는 트랜잭션을 결정하는 데 사용되는 정책을 지정합니다.
# 이 변수는 멀티 스레딩이 활성화되지 않은 슬레이브에는 영향을 미치지 않습니다. 가능한 값은 다음과 같습니다.
# 
# -LOGICAL_CLOCK : 마스터에서 동일한 이진 로그 그룹 커밋의 일부인 트랜잭션이 슬레이브에 병렬로 적용됩니다. 트랜잭션 간의 종속성은 타임 스탬프를 기반으로 추적되어 가능한 경우 추가 병렬화를 제공합니다.
# 이 값을 설정하면 binlog_transaction_dependency_tracking 시스템 변수를 마스터에서 사용하여 트랜잭션에 쓰기 세트를 사용할 수 있고 타임 스탬프에 비해 향상된 결과를 제공하는 경우,
# 쓰기 세트가 타임 스탬프 대신 병렬화에 사용되도록 지정할 수 있습니다.
# 
# -데이터베이스 : 다른 데이터베이스를 업데이트하는 트랜잭션이 병렬로 적용됩니다. 이 값은 데이터가 마스터에서 독립적으로 동시에 업데이트되는 여러 데이터베이스로 파티션 된 경우에만 적합합니다.
# 데이터베이스 간 제약 조건이 없어야합니다. 이러한 제약 조건이 슬레이브에서 위반 될 수 있습니다.
# 
# slave_preserve_commit_order = 1이 설정되면 LOGICAL_CLOCK 만 사용할 수 있습니다.
# 
# 복제 토폴로지가 여러 레벨의 슬레이브를 사용하는 경우 LOGICAL_CLOCK은 슬레이브가 마스터에서 떨어져있는 각 레벨에 대해 덜 병렬화를 달성 할 수 있습니다.
# 마스터에서 binlog_transaction_dependency_tracking을 사용하여 가능한 경우 병렬화를 위해 타임 스탬프 대신 쓰기 세트가 사용되도록 지정하여이 효과를 줄일 수 있습니다.
#
# * Apply Option
# slave_parallel_type=DATABASE
# 
# --------------------------------------------
# 
# @ slave_parallel_workers
# 
# Property : Value
# Command-Line Format : --slave-parallel-workers=#
# System Variable : slave_parallel_workers
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 1024
# 
# 복제 트랜잭션을 병렬로 실행하기위한 슬레이브 적용자 스레드 수를 설정합니다. 이 변수를 0보다 큰 수로 설정하면이 개수의 적용 가능한 스레드가있는 다중 스레드 슬레이브가 만들어집니다.
# 0 (기본값)으로 설정하면 병렬 실행이 비활성화되고 슬레이브는 단일 적용자 스레드를 사용합니다. slave_parallel_workers를 설정해도 즉각적인 효과는 없습니다. 변수 상태는 모든 후속 START SLAVE 문에 적용됩니다.
# 
# 노트
# 멀티 스레드 슬레이브는 현재 NDB 클러스터에서 지원되지 않으며이 변수의 설정을 자동으로 무시합니다. 자세한 내용은 21.6.3 절“NDB 클러스터 복제의 알려진 문제”를 참조하십시오.
# 
# 멀티 스레드 슬레이브는 코디네이터 스레드와이 변수로 구성된 적용자 스레드 수를 사용하여 병렬 실행을 제공합니다.
# Applier 스레드간에 트랜잭션이 분배되는 방식은 slave_parallel_type에 의해 구성됩니다. slave_preserve_commit_order = 1이 아닌 한 슬레이브가 병렬로 적용하는 트랜잭션은 순서가 맞지 않을 수 있습니다.
# 따라서 가장 최근에 실행 된 트랜잭션을 확인한다고해서 마스터의 모든 이전 트랜잭션이 슬레이브에서 실행 된 것은 아닙니다.
# 이는 다중 스레드 슬레이브를 사용할 때 로깅 및 복구에 영향을 미칩니다. 예를 들어, 다중 스레드 슬레이브에서 START SLAVE UNTIL 문은 SQL_AFTER_MTS_GAPS 사용 만 지원합니다.
# 
# MySQL 5.7에서는 슬레이브에서 멀티 스레딩이 활성화 된 경우 트랜잭션 재 시도가 지원됩니다.
# 이전 버전에서는 멀티 스레드 슬레이브를 사용할 때 slave_transaction_retries가 0으로 취급되었습니다.
#
# * Apply Option
# slave_parallel_workers=0
# 
# --------------------------------------------
# 
# @ slave_pending_jobs_size_max
# 
# Property : Value
# Command-Line Format : --slave-pending-jobs-size-max=#
# System Variable : slave_pending_jobs_size_max
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 16M
# Minimum Value : 1024
# Maximum Value : 16EiB
# Block Size	1024
# 
# 다중 스레드 슬레이브의 경우이 변수는 아직 적용되지 않은 이벤트를 보유하는 슬레이브 작업자 큐에 사용할 수있는 최대 메모리 양 (바이트)을 설정합니다.
# 이 변수를 설정해도 멀티 스레딩이 활성화되지 않은 슬레이브에는 영향을 미치지 않습니다. 이 변수를 설정해도 즉각적인 효과는 없습니다. 변수 상태는 모든 후속 START SLAVE 명령에 적용됩니다.
# 
# 이 변수의 가능한 최소값은 1024입니다. 기본값은 16MB입니다. 최대 값은 18446744073709551615 (16 엑사 바이트)입니다.
# 1024의 정확한 배수가 아닌 값은 저장되기 전에 1024의 다음으로 높은 배수로 내림됩니다.
# 
# 이 변수의 값은 소프트 한계이며 일반 워크로드와 일치하도록 설정할 수 있습니다.
# 비정상적으로 큰 이벤트가이 크기를 초과하면 모든 슬레이브 작업자가 빈 큐를 가질 때까지 트랜잭션이 보류 된 다음 처리됩니다. 모든 후속 거래는 대규모 거래가 완료 될 때까지 보류됩니다.
#
# * Apply Option
# slave_pending_jobs_size_max=16M
# 
# --------------------------------------------
# 
# @ slave_preserve_commit_order
# 
# Property : Value
# Command-Line Format : --slave-preserve-commit-order[={OFF|ON}]
# System Variable : slave_preserve_commit_order
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 멀티 스레드 슬레이브의 경우이 변수에 1을 설정하면 트랜잭션이 슬레이브의 릴레이 로그에 나타나는 순서대로 슬레이브에서 외부화되고 릴레이 로그에서 실행 된 트랜잭션 순서의 간격이 방지됩니다.
# 이 변수는 멀티 스레딩이 활성화되지 않은 슬레이브에는 영향을 미치지 않습니다.
# slave_preserve_commit_order = 1은 비 트랜잭션 DML 업데이트의 순서를 유지하지 않으므로 릴레이 로그에서 트랜잭션보다 우선하는 트랜잭션보다 먼저 커밋되어 간격이 생길 수 있습니다.
# 
# slave_preserve_commit_order = 1을 사용하려면 슬레이브에서 --log-bin 및 --log-slave-updates를 활성화하고 slave_parallel_type을 LOGICAL_CLOCK으로 설정해야합니다.
# 이 변수를 변경하기 전에 모든 복제 스레드 (여러 복제 채널을 사용하는 경우 모든 복제 채널에 대해)를 중지해야합니다.
# 
# slave_preserve_commit_order가 활성화되면 실행 스레드는 커밋 전에 모든 이전 트랜잭션이 커밋 될 때까지 기다립니다.
# 슬레이브 스레드는 다른 작업자가 트랜잭션을 커밋하기를 기다리는 동안 이전 트랜잭션이 커밋되기를 기다리는 중으로 상태를보고합니다. (MySQL 5.7.8 이전에는 이것이 커밋을 기다리는 중으로 표시되었습니다.)
# 다중 스레드 슬레이브에서이 모드를 활성화하면 마스터가없는 상태로 들어 가지 않습니다. 이는 읽기 스케일에 대한 복제 사용을 지원합니다. -밖. 16.3.4 절.“스케일 아웃에 복제 사용”을 참조하십시오.
# 
# slave_preserve_commit_order = 0을 설정하면 슬레이브가 병렬로 적용하는 트랜잭션의 순서가 잘못 될 수 있습니다.
# 따라서 가장 최근에 실행 된 트랜잭션을 확인한다고해서 마스터의 모든 이전 트랜잭션이 슬레이브에서 실행 된 것은 아닙니다.
# 슬레이브의 릴레이 로그에서 실행 된 트랜잭션 순서에 차이가있을 수 있습니다. 이는 다중 스레드 슬레이브를 사용할 때 로깅 및 복구에 영향을 미칩니다.
# slave_preserve_commit_order = 1 설정은 간격을 방지하지만 마스터 로그 위치 지연 (Exec_master_log_pos가 트랜잭션이 실행 된 위치 뒤에 있음)을 방지하지는 않습니다.
# 자세한 내용은 16.4.1.32 절“복제 및 트랜잭션 불일치”를 참조하십시오.
#
# * Apply Option
# slave_preserve_commit_order=OFF
# 
# --------------------------------------------
# 
# @ slave_rows_search_algorithms
# 
# Property : Value
# Command-Line Format : --slave-rows-search-algorithms=value
# System Variable : slave_rows_search_algorithms
# Scope : Global
# Dynamic : Yes
# Type : Set
# Default Value : TABLE_SCAN,INDEX_SCAN
# Valid Values  : :
# TABLE_SCAN,INDEX_SCAN
# INDEX_SCAN,HASH_SCAN
# TABLE_SCAN,HASH_SCAN
# TABLE_SCAN,INDEX_SCAN,HASH_SCAN (equivalent to INDEX_SCAN,HASH_SCAN)
# 
# 행 기반 로깅 및 복제를 위해 행 배치를 준비 할 때이 변수는 행에서 일치 항목을 검색하는 방법, 특히 해시 스캔 사용 여부를 제어합니다.
# 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# INDEX_SCAN, TABLE_SCAN, HASH_SCAN 목록에서 다음 두 값 조합의 쉼표로 구분 된 목록을 지정하십시오.
# 값은 문자열로 예상되므로 서버 시작이 아닌 런타임시 설정되면 값을 인용해야합니다. 또한 값에 공백이 없어야합니다. 권장되는 조합 (목록)과 그 효과는 다음 표에 나와 있습니다.
# 
# Index used / option value	| INDEX_SCAN,HASH_SCAN | INDEX_SCAN,TABLE_SCAN
# Primary key or unique key	| Index scan	         | Index scan
# (Other) Key	              | Hash scan over index | Index scan
# No index                  | Hash scan            | Table scan
# 
# -기본값은 INDEX_SCAN, TABLE_SCAN입니다. 이는 인덱스를 사용할 수있는 모든 검색에서이를 사용하며 인덱스가없는 검색은 테이블 스캔을 사용함을 의미합니다.
# -기본 또는 고유 키를 사용하지 않는 검색에 해싱을 사용하려면 INDEX_SCAN, HASH_SCAN을 설정하십시오. INDEX_SCAN, HASH_SCAN을 지정하면 허용되는 INDEX_SCAN, TABLE_SCAN, HASH_SCAN을 지정하는 것과 동일한 효과가 있습니다.
# -TABLE_SCAN, HASH_SCAN 조합을 사용하지 마십시오. 이 설정은 모든 검색을 강제로 해싱합니다.
#  INDEX_SCAN, HASH_SCAN에 비해 이점이 없으며 동일한 행에 대한 여러 업데이트가 포함 된 단일 이벤트 또는 순서에 따른 업데이트의 경우 "레코드를 찾을 수 없음"오류 또는 중복 키 오류가 발생할 수 있습니다.
# 
# 알고리즘이 목록에 지정된 순서는 SELECT 또는 SHOW VARIABLES 문에 의해 표시되는 순서와 차이가 없습니다.
# 
# 단일 값을 지정할 수는 있지만 단일 값을 설정하면 해당 알고리즘 만 사용하도록 검색이 제한되므로 최적이 아닙니다.
# 특히 인덱스가 없으면 검색에서 행을 찾을 수 없으므로 INDEX_SCAN 만 설정하지 않는 것이 좋습니다.
#
# * Apply Option
# slave_rows_search_algorithms=TABLE_SCAN,INDEX_SCAN
# 
# --------------------------------------------
# 
# @ slave_skip_errors
# 
# Property : Value
# Command-Line Format : --slave-skip-errors=name
# System Variable : slave_skip_errors
# Scope : Global
# Dynamic : No
# Type : String
# Default Value : OFF
# Valid Values  : OFF
# [list of error codes]
# all
# ddl_exist_errors
# 
# 일반적으로 슬레이브에서 오류가 발생하면 복제가 중지되므로 데이터의 불일치를 수동으로 해결할 수 있습니다.
# 이 변수는 명령문이 변수 값에 나열된 오류를 리턴 할 때 슬레이브 SQL 스레드가 복제를 계속하게합니다.
#
# * Apply Option
# slave_skip_errors=OFF
# 
# --------------------------------------------
# 
# @ slave_sql_verify_checksum
# 
# Property : Value
# Command-Line Format : --slave-sql-verify-checksum[={OFF|ON}]
# System Variable : slave_sql_verify_checksum
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 슬레이브 SQL 스레드가 릴레이 로그에서 읽은 체크섬을 사용하여 데이터를 확인하게합니다.
# 불일치가 발생하면 슬레이브는 오류와 함께 정지합니다. 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# 노트
# 슬레이브 I / O 스레드는 네트워크를 통해 이벤트를 수락 할 때 가능하면 항상 체크섬을 읽습니다.
#
# * Apply Option
# slave_sql_verify_checksum=ON
# 
# --------------------------------------------
# 
# @ slave_transaction_retries
# 
# Property : Value
# Command-Line Format : --slave-transaction-retries=#
# System Variable : slave_transaction_retries
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10
# Minimum Value : 0
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 복제 슬레이브 SQL 스레드가 InnoDB 교착 상태로 인해 트랜잭션을 실행하지 못하거나 트랜잭션의 실행 시간이 InnoDB의 innodb_lock_wait_timeout 또는 NDB의 TransactionDeadlockDetectionTimeout
# 또는 TransactionInactiveTimeout을 초과하여 트랜잭션을 실행하지 못하면 오류가 발생하기 전에 slave_transaction_retries 시간을 자동으로 재 시도합니다.
# 일시적이지 않은 오류가 있는 트랜잭션은 재시도되지 않습니다.
# 
# slave_transaction_retries의 기본값은 10입니다. 변수를 0으로 설정하면 트랜잭션의 자동 재 시도를 사용하지 않습니다. 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# MySQL 5.7.5부터 슬레이브에서 멀티 스레딩이 활성화되면 트랜잭션 재 시도가 지원됩니다. 이전 버전에서는 멀티 스레드 슬레이브를 사용할 때 slave_transaction_retries가 0으로 취급되었습니다.
# 
# 성능 스키마 테이블 replication_applier_status는 각 복제 채널에서 발생한 재시도 횟수를 COUNT_TRANSACTIONS_RETRIES 열에 표시합니다.
#
# * Apply Option
# slave_transaction_retries=10
# 
# --------------------------------------------
# 
# @ slave_type_conversions
# 
# Property : Value
# Command-Line Format : --slave-type-conversions=set
# System Variable : slave_type_conversions
# Scope : Global
# Dynamic : No
# Type : Set
# Default Value : 
# Valid Values  : ALL_LOSSY, ALL_NON_LOSSY, ALL_SIGNED, ALL_UNSIGNED
# 
# 행 기반 복제를 사용할 때 슬레이브에 적용되는 유형 변환 모드를 제어합니다.
# MySQL 5.7.2 이상에서이 값은 쉼표로 구분 된 ALL_LOSSY, ALL_NON_LOSSY, ALL_SIGNED, ALL_UNSIGNED 목록에서 0 개 이상의 요소로 구성된 세트입니다.
# 마스터와 슬레이브 사이의 유형 변환을 허용하지 않으려면이 변수를 빈 문자열로 설정하십시오. 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# ALL_SIGNED 및 ALL_UNSIGNED가 MySQL 5.7.2 (버그 # 15831300)에 추가되었습니다.
# 행 기반 복제에서 속성 승격 및 수준 내리기에 적용 가능한 유형 변환 모드에 대한 자세한 내용은 행 기반 복제 : 속성 승격 및 수준 내리기를 참조하십시오.
#
# * Apply Option
# slave_type_conversions=none
# 
# --------------------------------------------
# 
# @ sql_slave_skip_counter
# 
# Property : Value
# System Variable : sql_slave_skip_counter
# Scope : Global
# Dynamic : Yes
# Type : Integer
# 
# 슬레이브 서버가 건너 뛰어야하는 마스터의 이벤트 수입니다. 옵션을 설정해도 즉각적인 효과는 없습니다. 변수는 다음 START SLAVE 문에 적용됩니다.
# 다음 START SLAVE 문도 값을 다시 0으로 변경합니다.이 변수가 0이 아닌 값으로 설정되고 여러 복제 채널이 구성된 경우 START SLAVE 문은 FOR CHANNEL 채널 절에서만 사용할 수 있습니다.
# 
# 이 옵션은 GTID 기반 복제와 호환되지 않으며 gtid_mode = ON 인 경우 0이 아닌 값으로 설정해서는 안됩니다.
# GTID를 사용할 때 트랜잭션을 건너 뛰려면 대신 마스터에서 gtid_executed를 사용하십시오. 이를 수행하는 방법에 대한 정보는 빈 트랜잭션 주입을 참조하십시오.
# 
# 중대한
# 이 변수를 설정하여 지정된 이벤트 수를 건너 뛰면 슬레이브가 이벤트 그룹 중간에서 시작되는 경우 슬레이브는 다음 이벤트 그룹의 시작을 찾아 해당 지점에서 시작할 때까지 계속 건너 뜁니다.
# 자세한 내용은 13.4.2.5 절“SET GLOBAL sql_slave_skip_counter 문”을 참조하십시오.
#
# * Apply Option
# sql_slave_skip_counter=none
# 
# --------------------------------------------
# 
# @ sync_master_info
# 
# Property : Value
# Command-Line Format : --sync-master-info=#
# System Variable : sync_master_info
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10000
# Minimum Value : 0
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 복제 슬레이브에 대한이 변수의 영향은 다음 단락에서 설명하는 것처럼 슬레이브의 master_info_repository가 FILE 또는 TABLE로 설정되어 있는지 여부에 따라 다릅니다.
# 
# master_info_repository = 파일 sync_master_info의 값이 0보다 크면 슬레이브는 모든 sync_master_info 이벤트 후 fdatasync ()를 사용하여 master.info 파일을 디스크에 동기화합니다.
# 0이면 MySQL 서버는 master.info 파일을 디스크에 동기화하지 않습니다. 대신 서버는 운영 체제에 의존하여 다른 파일과 마찬가지로 내용을 주기적으로 플러시합니다.
# 
# master_info_repository = 테이블. sync_master_info의 값이 0보다 크면 슬레이브는 모든 sync_master_info 이벤트 후에 마스터 정보 저장소 테이블을 업데이트합니다.
# 0이면 테이블이 업데이트되지 않습니다.
# 
# sync_master_info의 기본값은 10000입니다.이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
#
# * Apply Option
# sync_master_info=10000
# 
# --------------------------------------------
# 
# @ sync_relay_log
# 
# Property : Value
# Command-Line Format : --sync-relay-log=#
# System Variable : sync_relay_log
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10000
# Minimum Value : 0
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 이 변수의 값이 0보다 크면 MySQL 서버는 모든 sync_relay_log 이벤트가 릴레이 로그에 기록 된 후 릴레이 로그를 디스크에 동기화합니다 (fdatasync () 사용).
# 이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# sync_relay_log를 0으로 설정하면 디스크에 대한 동기화가 수행되지 않습니다.
# 이 경우 서버는 운영 체제를 사용하여 다른 파일과 마찬가지로 릴레이 로그의 내용을 수시로 플러시합니다.
# 
# 충돌이 발생하면 릴레이 로그에서 최대 하나의 이벤트가 손실되므로 값 1이 가장 안전한 선택입니다.
# 그러나 디스크에 배터리 백업 캐시가 없어 동기화 속도가 매우 빠르지 않은 한 가장 느린 선택이기도합니다.
#
# * Apply Option
# sync_relay_log=10000
# 
# --------------------------------------------
# 
# @ sync_relay_log_info
# 
# Property : Value
# Command-Line Format : --sync-relay-log-info=#
# System Variable : sync_relay_log_info
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10000
# Minimum Value : 0
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# sync_relay_log_info의 기본값은 10000입니다.이 변수를 설정하면 실행중인 채널을 포함하여 모든 복제 채널에 즉시 적용됩니다.
# 
# 복제 슬레이브에서이 변수의 영향은 서버의 relay_log_info_repository 설정 (FILE 또는 TABLE)에 따라 다릅니다.
# 설정이 TABLE 인 경우 변수의 영향은 릴레이 로그 정보 테이블에서 사용하는 스토리지 엔진이 트랜잭션 (InnoDB 등)인지 트랜잭션 (MyISAM)인지에 따라 달라집니다.
# sync_relay_log_info 값이 0보다 크고 0보다 큰 서버의 동작에 대한 이러한 요인의 영향은 다음과 같습니다.
# 
# sync_relay_log_info = 0
# - relay_log_info_repository가 FILE로 설정된 경우 MySQL 서버는 relay-log.info 파일을 디스크에 동기화하지 않습니다. 대신 서버는 운영 체제에 의존하여 다른 파일과 마찬가지로 내용을 주기적으로 플러시합니다.
# - relay_log_info_repository가 TABLE로 설정되고 해당 테이블의 스토리지 엔진이 트랜잭션 인 경우 테이블은 각 트랜잭션 후에 업데이트됩니다. 이 경우 sync_relay_log_info 설정은 효과적으로 무시됩니다.
# - relay_log_info_repository가 TABLE로 설정되고 해당 테이블의 스토리지 엔진이 트랜잭션이 아닌 경우 테이블은 업데이트되지 않습니다.
# 
# sync_relay_log_info = N > 0
# - relay_log_info_repository가 FILE로 설정된 경우 슬레이브는 매 N 트랜잭션 후 relay-log.info 파일을 디스크에 동기화합니다 (fdatasync () 사용).
# - relay_log_info_repository가 TABLE로 설정되고 해당 테이블의 스토리지 엔진이 트랜잭션 인 경우 테이블은 각 트랜잭션 후에 업데이트됩니다. 이 경우 sync_relay_log_info 설정은 효과적으로 무시됩니다.
# - relay_log_info_repository가 TABLE로 설정되고 해당 테이블의 스토리지 엔진이 트랜잭션이 아닌 경우 테이블은 N 개의 이벤트마다 업데이트됩니다.
#
# * Apply Option
# sync_relay_log_info=10000
#
# --------------------------------------------
# 
# read_only
# 
# Command-Line Format	--read-only[={OFF|ON}]
# System Variable	read_only
# Scope	Global
# Dynamic	Yes
# Type	Boolean
# Default Value	OFF
# 
# read_only 시스템 변수가 활성화되면 서버는 SUPER 권한이있는 사용자를 제외하고는 클라이언트 업데이트를 허용하지 않습니다. 이 변수는 기본적으로 비활성화되어 있습니다.
# 
# 서버는 또한 super_read_only 시스템 변수 (기본적으로 비활성화 됨)를 지원하며 다음과 같은 효과가 있습니다.
#   -super_read_only가 활성화 된 경우 서버는 SUPER 권한이있는 사용자로부터도 클라이언트 업데이트를 금지합니다.
#   -super_read_only를 ON으로 설정하면 암시 적으로 read_only를 ON으로 강제합니다.
#   -read_only를 OFF로 설정하면 암시 적으로 super_read_only를 OFF로 강제합니다.
# 
# read_only가 활성화된 경우에도 서버는 다음 작업을 허용합니다.
#   - 서버가 복제 복제 본인 경우 복제본 스레드에서 수행하는 업데이트입니다. 복제 설정에서 복제본이 클라이언트가 아닌 원본 서버에서만 업데이트를 수락하도록 복제본 서버에서 read_only를 활성화하는 것이 유용 할 수 있습니다.
#   - ANALYZE TABLE 또는 OPTIMIZE TABLE 문 사용. 읽기 전용 모드의 목적은 테이블 구조 또는 내용의 변경을 방지하는 것입니다. 분석 및 최적화는 그러한 변경에 해당되지 않습니다.
#      예를 들어 mysqlcheck --all-databases --analyze를 사용하여 읽기 전용 복제 복제본에 대한 일관성 검사를 수행할 수 있습니다.
#   - TEMPORARY 테이블에 대한 작업.
#   - 로그 테이블 (mysql.general_log 및 mysql.slow_log)에 삽입합니다. 5.4.1 절.“일반 쿼리 로그 및 느린 쿼리 로그 출력 대상 선택”을 참조하십시오.
#   - MySQL 5.7.16부터 UPDATE 또는 TRUNCATE TABLE 작업과 같은 성능 스키마 테이블이 업데이트되었습니다.
# 
# 원본 서버에서 read_only에 대한 변경 사항은 복제본 서버에 복제되지 않습니다. 값은 소스의 설정에 관계없이 복제 서버에서 설정할 수 있습니다.
#
# 다음 조건은 read_only를 활성화하려는 시도에 적용됩니다 (super_read_only 활성화로 인한 암시 적 시도 포함).
#   -명시 적 잠금 (LOCK TABLES로 획득)이 있거나 보류중인 트랜잭션이있는 경우 시도가 실패하고 오류가 발생합니다.
#   -잠금이 해제되고 명령문과 트랜잭션이 종료 될 때까지 다른 클라이언트가 진행중인 명령문, 활성 LOCK TABLES WRITE 또는 진행중인 커밋이있는 동안 시도가 차단됩니다.
#    read_only를 활성화하려는 시도가 보류중인 동안 테이블 잠금 또는 트랜잭션 시작에 대한 다른 클라이언트의 요청도 read_only가 설정 될 때까지 차단됩니다.
#   -메타 데이터 잠금을 유지하는 활성 트랜잭션이 있으면 해당 트랜잭션이 끝날 때까지 시도가 차단됩니다.
#   -읽기 전용은 테이블 잠금을 포함하지 않기 때문에 전역 읽기 잠금 (FLUSH TABLES WITH READ LOCK으로 획득)을 유지하는 동안 활성화 할 수 있습니다.
# 
# * Apply Option
# read_only=OFF
# 
# --------------------------------------------
# 
# super_read_only
# 
# Command-Line Format	--super-read-only[={OFF|ON}]
# System Variable	super_read_only
# Scope	Global
# Dynamic	Yes
# Type	Boolean
# Default Value	OFF
# 
# 
# read_only 시스템 변수가 활성화된 경우 서버는 SUPER 권한이있는 사용자의 클라이언트 업데이트만 허용합니다.
# super_read_only 시스템 변수도 활성화된 경우 서버는 SUPER가 있는 사용자의 클라이언트 업데이트도 금지합니다.
# 읽기 전용 모드에 대한 설명과 read_only 및 super_read_only가 상호 작용하는 방법에 대한 정보는 read_only 시스템 변수에 대한 설명을 참조하십시오.
# 
# super_read_only가 활성화 되어있을 때 방지되는 클라이언트 업데이트에는 CREATE FUNCTION (UDF 설치) 및 INSTALL PLUGIN과 같이 반드시 업데이트로 표시되지 않는 작업이 포함됩니다.
# 이러한 작업은 mysql 시스템 데이터베이스의 테이블 변경을 포함하기 때문에 금지됩니다.
# 
# 소스 서버에서 super_read_only에 대한 변경 사항은 복제본 서버에 복제되지 않습니다. 값은 소스의 설정에 관계없이 복제 서버에서 설정할 수 있습니다.
# 
# * Apply Option
# super_read_only=OFF
# 
# ---------------------------------------------------------------------------
# -----------Binary Logging Options and Variables----------------------------
# ---------------------------------------------------------------------------
# 
# @ --binlog-row-event-max-size=N
# 
# Property : Value
# Command-Line Format : --binlog-row-event-max-size=#
# Type : Integer
# Default Value : 8192
# Minimum Value : 256
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 행 기반 이진 로그 이벤트의 최대 크기를 바이트 단위로 지정하십시오. 행은 가능한 경우이 크기보다 작은 이벤트로 그룹화됩니다.
# 값은 256의 배수 여야합니다. 기본값은 8192입니다. 16.2.1 절“복제 형식”을 참조하십시오.
#
# * Apply Option
# binlog-row-event-max-size=N
# 
# --------------------------------------------
# 
# @ --log-bin[=base_name]
# 
# Property : Value
# Command-Line Format : --log-bin=file_name
# Type : File name
# 
# 이진 로깅을 활성화합니다. 이진 로깅을 사용하면 서버는 데이터를 변경하는 모든 문을 백업 및 복제에 사용되는 이진 로그로 기록합니다.
# 이진 로그는 기본 이름과 숫자 확장자를 가진 일련의 파일입니다. 이진 로그의 형식 및 관리에 대한 자세한 내용은 5.4.4 절“이진 로그”를 참조하십시오.
# 
# --log-bin 옵션에 값을 제공하면 해당 값이 로그 시퀀스의 기본 이름으로 사용됩니다. 서버는 기본 이름에 숫자 접미사를 추가하여 이진 로그 파일을 순서대로 만듭니다.
# MySQL 5.7에서 기본 이름은 호스트 시스템의 이름을 사용하여 기본적으로 host_name-bin입니다. 기본 이름 변경에 관계없이 동일한 이진 로그 파일 이름을 계속 사용할 수 있도록 기본 이름을 지정하는 것이 좋습니다.
# 
# 이진 로그 파일의 기본 위치는 데이터 디렉토리입니다. --log-bin 옵션을 사용하여 다른 이름을 지정할 기본 이름에 선행 절대 경로 이름을 추가하여 대체 위치를 지정할 수 있습니다.
# 서버는 사용 된 이진 로그 파일을 추적하는 이진 로그 인덱스 파일에서 항목을 읽을 때 항목에 상대 경로가 포함되어 있는지 확인합니다.
# 그렇다면 경로의 상대 부분이 --log-bin 옵션을 사용하여 설정된 절대 경로로 바뀝니다. 이진 로그 인덱스 파일에 기록 된 절대 경로는 변경되지 않습니다.
# 이 경우 새 경로를 사용할 수 있도록 색인 파일을 수동으로 편집해야합니다. (이전 버전의 MySQL에서는 이진 로그 또는 릴레이 로그 파일을 재배치 할 때마다 수동 개입이 필요했습니다.) (버그 # 11745230, 버그 # 12133)
# 
# 이 옵션을 설정하면 log_bin 시스템 변수가 기본 이름이 아닌 ON (또는 1)으로 설정됩니다. 이진 로그 파일 기본 이름 및 지정된 경로는 log_bin_basename 시스템 변수로 사용 가능합니다.
# 
# server_id 시스템 변수를 지정하지 않고 --log-bin 옵션을 지정하면 서버를 시작할 수 없습니다. (버그 # 11763963, 버그 # 56739)
# 
# 서버에서 GTID를 사용중인 경우 비정상 종료 후 서버를 다시 시작할 때 이진 로깅을 사용하지 않으면 일부 GTID가 손실되어 복제가 실패 할 수 있습니다.
# 정상 종료시, 현재 이진 로그 파일의 GTID 세트는 mysql.gtid_executed 테이블에 저장됩니다. 이러한 상황이 발생하지 않은 비정상 종료 후 복구 중에 GTID가 이진 로그 파일에서 테이블에 추가됩니다 (이진 로깅이 여전히 사용 가능한 경우).
# 서버를 다시 시작하기 위해 이진 로깅을 사용하지 않으면 서버가 이진 로그 파일에 액세스하여 GTID를 복구 할 수 없으므로 복제를 시작할 수 없습니다. 정상적인 종료 후 이진 로깅을 안전하게 비활성화 할 수 있습니다.
#
# * Apply Option
# log-bin=directory/file_name
# 
# --------------------------------------------
# 
# @ --binlog-do-db=db_name
# 
# Property : Value
# Command-Line Format : --binlog-do-db=name
# Type : String
# 
# 이 옵션은 --replicate-do-db가 복제에 영향을주는 방식과 유사한 방식으로 이진 로깅에 영향을줍니다.
# 
# 이 옵션의 효과는 --replicate-do-db의 효과가 명령문 기반 또는 행 기반 복제의 영향 여부와 같은 방식으로 명령문 기반 또는 행 기반 로깅 형식의 사용 여부에 따라 다릅니다. 사용하다.
# 주어진 명령문을 기록하는 데 사용 된 형식이 binlog_format 값으로 표시되는 형식과 반드시 ​​같을 필요는 없습니다.
# 예를 들어 CREATE TABLE 및 ALTER TABLE과 같은 DDL 문은 유효한 로깅 형식에 관계없이 항상 문으로 기록되므로 --binlog-do-db에 대한 다음 문 기반 규칙은 항상 문이 기록됩니다.
# 
# ++ Statement-based logging.
# 이 명령문 만 기본 데이터베이스 (즉, USE에서 선택한 데이터베이스)가 db_name 인 2 진 로그에 기록됩니다. 둘 이상의 데이터베이스를 지정하려면 각 데이터베이스에 대해이 옵션을 여러 번 사용하십시오.
# 그러나 그렇게하면 다른 데이터베이스 (또는 데이터베이스가없는)가 선택된 동안 UPDATE some_db.some_table SET foo = 'bar'와 같은 데이터베이스 간 명령문이 기록되지 않습니다.
# 
# 경고
# 여러 데이터베이스를 지정하려면이 옵션의 여러 인스턴스를 사용해야합니다. 데이터베이스 이름에는 쉼표가 포함될 수 있으므로 쉼표로 구분 된 목록을 제공하면 목록이 단일 데이터베이스의 이름으로 취급됩니다.
# 
# 명령문 기반 로깅을 사용할 때 예상대로 작동하지 않는 예 : 서버가 --binlog-do-db = sales로 시작되고 다음 명령문을 발행하면 UPDATE 문이 로깅되지 않습니다.
# USE prices;
# UPDATE sales.january SET amount=amount+1000;
# 이 "기본 데이터베이스 만 검사"동작의 주된 이유는 명령문만으로는 복제 여부를 알기가 어렵 기 때문입니다 (예 : 다중 테이블 DELETE 문 또는 다중 테이블 UPDATE 문을 사용하는 경우) 여러 데이터베이스에서).
# 필요하지 않은 경우 모든 데이터베이스가 아닌 기본 데이터베이스 만 확인하는 것이 더 빠릅니다.
# 
# 옵션을 설정할 때 데이터베이스가 지정되지 않았더라도 지정된 데이터베이스가 복제 될 때 자명하지 않을 수있는 다른 경우가 발생합니다.
# 서버가 --binlog-do-db = sales로 시작되면 --binlog-do-db를 설정할 때 가격이 포함되지 않은 경우에도 다음 UPDATE 문이 기록됩니다.
# USE sales;
# UPDATE prices.discounts SET percentage = percentage + 10;
# UPDATE 문이 발행 될 때 sales가 기본 데이터베이스이므로 UPDATE가 로그됩니다.
# 
# ++ Row-based logging.
# 로깅은 데이터베이스 db_name으로 제한됩니다. db_name에 속하는 테이블의 변경 사항 만 기록됩니다. 기본 데이터베이스는 이에 영향을 미치지 않습니다.
# 서버가 --binlog-do-db = sales로 시작되고 행 기반 로깅이 적용되고 다음 명령문이 실행된다고 가정하십시오.
# USE prices;
# UPDATE sales.february SET amount=amount+100;
# 
# 판매 데이터베이스의 2 월 테이블에 대한 변경 사항은 UPDATE 문에 따라 기록됩니다. 이것은 USE 문이 발행되었는지 여부에 관계없이 발생합니다.
# 그러나 행 기반 로깅 형식 및 --binlog-do-db = sales를 사용하는 경우 다음 UPDATE에 의한 변경 사항은 기록되지 않습니다.
# USE prices;
# UPDATE prices.march SET amount=amount-25;
# USE 가격 명세서가 USE 판매로 변경 되더라도 UPDATE 문의 효과는 여전히 이진 로그에 기록되지 않습니다.
# 
# 행 기반 로깅과 달리 명령문 기반 로깅에 대한 --binlog-do-db 처리의 또 다른 중요한 차이점은 여러 데이터베이스를 참조하는 명령문과 관련하여 발생합니다.
# 서버가 --binlog-do-db = db1로 시작되고 다음 명령문이 실행된다고 가정하십시오.
# USE db1;
# UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
# 
# 명령문 기반 로깅을 사용하는 경우 두 테이블에 대한 업데이트가 이진 로그에 기록됩니다. 그러나 행 기반 형식을 사용하는 경우 table1에 대한 변경 사항 만 기록됩니다.
# table2가 다른 데이터베이스에 있으므로 UPDATE에 의해 변경되지 않습니다. 이제 USE db1 문 대신 USE db4 문이 사용되었다고 가정하십시오.
# USE db4;
# UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
# 이 경우 명령문 기반 로깅을 사용할 때 UPDATE 문이 2 진 로그에 기록되지 않습니다. 그러나 행 기반 로깅을 사용하는 경우 table1에 대한 변경 사항은 기록되지만 table2에 대한 변경 내용은 기록되지 않습니다.
# 즉, --binlog-do-db로 명명 된 데이터베이스의 테이블에 대한 변경 사항 만 기록되며 기본값 선택 데이터베이스는이 동작에 영향을 미치지 않습니다.
#
# * Apply Option
# binlog-do-db=db_name
# 
# --------------------------------------------
# 
# @ --binlog-ignore-db=db_name
# 
# Property : Value
# Command-Line Format : --binlog-ignore-db=name
# Type : String
# 
# 이 옵션은 --replicate-ignore-db가 복제에 영향을주는 방식과 유사한 방식으로 이진 로깅에 영향을줍니다.
# 
# 이 옵션의 효과는 --replicate-ignore-db의 효과가 명령문 기반 또는 행 기반 복제의 영향 여부와 같은 방식으로 명령문 기반 또는 행 기반 로깅 형식의 사용 여부에 따라 다릅니다. 사용하다.
# 주어진 명령문을 기록하는 데 사용 된 형식이 binlog_format 값으로 표시되는 형식과 반드시 ​​같을 필요는 없습니다.
# 예를 들어 CREATE TABLE 및 ALTER TABLE과 같은 DDL 문은 유효한 로깅 형식에 관계없이 항상 문으로 기록되므로 --binlog-ignore-db에 대한 다음 문 기반 규칙은 항상 문이 기록됩니다.
# 
# ++ Statement-based logging.
# 기본 데이터베이스 (USE에서 선택한 데이터베이스)가 db_name 인 명령문은 서버가 로그하지 않도록 지시합니다.
# 
# MySQL 5.7.2 이전에는이 ​​옵션으로 기본 데이터베이스가 지정되지 않은 경우 (즉, SELECT DATABASE ()가 NULL을 리턴 한 경우) 완전한 테이블 이름을 포함하는 명령문이 기록되지 않았습니다.
# MySQL 5.7.2 이상에서 기본 데이터베이스가없는 경우 --binlog-ignore-db 옵션이 적용되지 않으며 이러한 명령문은 항상 기록됩니다. (버그 # 11829838, 버그 # 60188)
# 
# ++ Row-based format.
# 데이터베이스 db_name의 테이블에 업데이트를 로그하지 않도록 서버에 지시합니다. 현재 데이터베이스는 영향을 미치지 않습니다.
# 
# 명령문 기반 로깅을 사용할 때 다음 예제는 예상대로 작동하지 않습니다. 서버가 --binlog-ignore-db = sales로 시작되고 다음 명령문을 발행한다고 가정하십시오.
# USE prices;
# UPDATE sales.january SET amount=amount+1000;
# --binlog-ignore-db는 기본 데이터베이스 (USE 문에 의해 결정됨)에만 적용되므로 UPDATE 문은 이러한 경우에 기록됩니다. 판매 데이터베이스가 명령문에 명시 적으로 지정되었으므로 명령문이 필터링되지 않았습니다.
# 그러나 행 기반 로깅을 사용하는 경우 UPDATE 문의 효과가 2 진 로그에 기록되지 않으므로 sales.january 테이블에 대한 변경 사항이 기록되지 않습니다.
# 이 경우 --binlog-ignore-db = sales는 이진 로깅을 위해 마스터의 판매 데이터베이스 복사본에있는 테이블에 대한 모든 변경 사항이 무시되도록합니다.
# 
# 무시할 둘 이상의 데이터베이스를 지정하려면 각 데이터베이스에 대해이 옵션을 여러 번 사용하십시오.
# 데이터베이스 이름에는 쉼표가 포함될 수 있으므로 쉼표로 구분 된 목록을 제공하면 목록이 단일 데이터베이스의 이름으로 취급됩니다.
# 
# 데이터베이스 간 업데이트를 사용하고 있고 이러한 업데이트를 기록하지 않으려면이 옵션을 사용하지 마십시오.
#
# * Apply Option
# binlog-ignore-db=db_name
# 
# --------------------------------------------
# 
# @ binlog_cache_size
# 
# Property : Value
# Command-Line Format : --binlog-cache-size=#
# System Variable : binlog_cache_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 32768
# Minimum Value : 4096
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 
# 보관할 캐시 크기는 트랜잭션 중에 이진 로그에 대한 변경 사항입니다. 서버가 트랜잭션 저장 엔진을 지원하고 서버에서 이진 로그가 활성화 된 경우 (--log-bin 옵션) 각 이진 로그 캐시가 각 클라이언트에 할당됩니다.
# 대규모 트랜잭션을 자주 사용하는 경우이 캐시 크기를 늘려 성능을 향상시킬 수 있습니다.
# Binlog_cache_use 및 Binlog_cache_disk_use 상태 변수는이 변수의 크기를 조정하는 데 유용 할 수 있습니다. 5.4.4 절.“이진 로그”를 참조하십시오.
# 
# binlog_cache_size는 트랜잭션 캐시의 크기 만 설정합니다. 명령문 캐시의 크기는 binlog_stmt_cache_size 시스템 변수에 의해 관리됩니다.
#
# * Apply Option
# binlog_cache_size=32768
# 
# --------------------------------------------
# 
# @ binlog_direct_non_transactional_updates
# 
# Property : Value
# Command-Line Format : --binlog-direct-non-transactional-updates[={OFF|ON}]
# System Variable : binlog_direct_non_transactional_updates
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 동시성 문제로 인해 트랜잭션에 트랜잭션 테이블과 비 트랜잭션 테이블 모두에 대한 업데이트가 포함되어 있으면 슬레이브가 일치하지 않을 수 있습니다.
# MySQL은 트랜잭션이 아닌 명령문을 트랜잭션 캐시에 작성하여 커밋시 플러시함으로써 이러한 명령문 간의 인과 관계를 유지하려고합니다.
# 그러나 트랜잭션을 대신하여 비 트랜잭션 테이블에 대한 수정이 이진 로그에 즉시 기록되지 않을 수 있으므로 다른 연결에 즉시 표시 될 때 문제가 발생합니다.
# 
# binlog_direct_non_transactional_updates 변수는이 문제에 대한 가능한 해결 방법을 제공합니다.
# 기본적으로이 변수는 비활성화되어 있습니다. binlog_direct_non_transactional_updates를 사용하면 트랜잭션이 아닌 테이블에 대한 업데이트가 트랜잭션 캐시가 아닌 이진 로그에 직접 기록됩니다.
# 
# binlog_direct_non_transactional_updates는 명령문 기반 2 진 로깅 형식을 사용하여 복제 된 명령문에 대해서만 작동합니다.
# 즉, binlog_format의 값이 STATEMENT이거나 binlog_format이 MIXED이고 지정된 명령문이 명령문 기반 형식을 사용하여 복제되는 경우에만 작동합니다.
# 이 변수는 이진 로그 형식이 ROW이거나 binlog_format이 MIXED로 설정되어 있고 주어진 명령문이 행 기반 형식을 사용하여 복제 된 경우에는 효과가 없습니다.
# 
# 중요사항
# 이 변수를 사용 가능하게하기 전에 트랜잭션 테이블과 비 트랜잭션 테이블 사이에 종속성이 없는지 확인해야합니다.
# 이러한 종속성의 예로는 INSERT INTO myisam_table SELECT * FROM innodb_table 문이 있습니다.
# 그렇지 않으면 그러한 진술로 인해 슬레이브가 마스터에서 벗어날 수 있습니다.
# 
# 이진 로그 형식이 ROW 또는 MIXED이면이 변수가 적용되지 않습니다.
#
# * Apply Option
# binlog_direct_non_transactional_updates=OFF
# 
# --------------------------------------------
# 
# @ binlog_error_action
# 
# Property : Value
# Command-Line Format : --binlog-error-action[=value]
# System Variable : binlog_error_action
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : ABORT_SERVER
# Valid Values  : IGNORE_ERROR, ABORT_SERVER
# 
# 서버가 이진 로그에 쓰거나, 플러시 또는 동기화 할 수없는 등의 오류가 발생할 때 발생하는 상황을 제어하여 마스터의 이진 로그가 일치하지 않고 복제 슬레이브가 동기화를 잃을 수 있습니다.
# 
# MySQL 5.7.7 이상에서이 변수의 기본값은 ABORT_SERVER이며, 이진 로그에 오류가 발생할 때마다 서버가 로깅을 중지하고 종료합니다.
# 재시작시 예기치 않은 서버 정지의 경우와 같이 복구가 진행됩니다 (16.3.2 절“예기치 않은 복제 슬레이브 중지 처리”참조).
# 
# binlog_error_action이 IGNORE_ERROR로 설정되면 서버에 이러한 오류가 발생하면 진행중인 트랜잭션이 계속되고 오류가 기록 된 후 로깅이 중지되고 업데이트가 계속 수행됩니다.
# 이진 로깅을 재개하려면 log_bin을 다시 활성화해야합니다. 서버를 다시 시작해야합니다. 이 설정은 이전 버전의 MySQL과 호환됩니다.
# 
# 이전 릴리스에서이 변수의 이름은 binlogging_impossible_mode입니다.
#
# * Apply Option
# binlog_error_action=ABORT_SERVER
# 
# --------------------------------------------
# 
# @ binlog_format
# 
# Property : Value
# Command-Line Format : --binlog-format=format
# System Variable : binlog_format
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : ROW
# Valid Values  : ROW, STATEMENT, MIXED
# 
# 이 변수는 이진 로깅 형식을 설정하며 STATEMENT, ROW 또는 MIXED 중 하나 일 수 있습니다. 16.2.1 절.“복제 형식”을 참조하십시오.
# 
# binlog_format은 일부 조건 하에서 런타임에이 변수를 변경하는 것이 불가능하거나 나중에 설명하는 것처럼 복제에 실패하는 경우를 제외하고 시작 또는 런타임에 설정할 수 있습니다.
# 
# MySQL 5.7.7 이전의 기본 형식은 STATEMENT입니다. MySQL 5.7.7 이상에서 기본값은 ROW입니다. 예외 : NDB 클러스터에서 기본값은 MIXED입니다. NDB 클러스터에서는 명령문 기반 복제가 지원되지 않습니다.
# 
# 이 시스템 변수의 세션 값 설정은 제한된 조작입니다. 세션 사용자에게는 제한된 세션 변수를 설정하기에 충분한 권한이 있어야합니다. 5.1.8.1 절.“시스템 변수 권한”을 참조하십시오.
# 
# 이 변수에 대한 변경 사항이 적용되는시기와 영향이 지속되는 시간을 결정하는 규칙은 다른 MySQL 서버 시스템 변수와 동일합니다. 자세한 정보는 13.7.4.1 절.“변수 할당을위한 SET 구문”을 참조하십시오.
# 
# MIXED를 지정하면 행 기반 복제만으로 올바른 결과를 얻을 수있는 경우를 제외하고 명령문 기반 복제가 사용됩니다. 예를 들어, 명령문에 사용자 정의 함수 (UDF) 또는 UUID () 함수가 포함 된 경우에 발생합니다.
# 
# 각 이진 로깅 형식이 설정 될 때 저장 프로그램 (저장 프로 시저 및 기능, 트리거 및 이벤트)이 처리되는 방법에 대한 자세한 내용은 23.7 절.“저장된 프로그램 이진 로깅”을 참조하십시오.
# 
# 런타임에 복제 형식을 전환 할 수없는 경우 예외가 있습니다.
# + 저장된 기능 또는 트리거 내에서.
# + 세션이 현재 행 기반 복제 모드이고 열려있는 임시 테이블이있는 경우.
# + 거래 내에서.
# 
# 이 경우 형식을 전환하려고하면 오류가 발생합니다.
# 
# 복제 마스터에서 로깅 형식을 변경해도 복제 슬레이브가 로깅 형식을 일치하도록 변경하지 않습니다.
# 복제가 진행되는 동안 복제 형식을 전환하면 복제 슬레이브에 이진 로깅이 활성화되어 있으면 마스터가 ROW 또는 MIXED 형식 로깅을 사용하는 동안 STATEMENT 형식 로깅을 사용하여 슬레이브에 문제가 발생할 수 있습니다.
# 복제 슬레이브는 자체 이진 로그에 사용하기 위해 ROW 로깅 형식으로 수신 된 이진 로그 항목을 STATEMENT 형식으로 변환 할 수 없으므로이 상황으로 인해 복제가 실패 할 수 있습니다.
# 자세한 내용은 5.4.4.2 절“이진 로그 형식 설정”을 참조하십시오.
# 
# The binary log format affects the behavior of the following server options:
# 
# + --replicate-do-db
# + --replicate-ignore-db
# + --binlog-do-db
# + --binlog-ignore-db
# 
# 이러한 효과는 개별 옵션에 대한 설명에서 자세히 설명합니다.
#
# * Apply Option
# binlog_format=ROW
# 
# --------------------------------------------
# 
# @ binlog_group_commit_sync_delay
# 
# Property : Value
# Command-Line Format : --binlog-group-commit-sync-delay=#
# System Variable : binlog_group_commit_sync_delay
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 1000000
# 
# 이진 로그 파일을 디스크에 동기화하기 전에 이진 로그 커밋이 대기하는 시간 (마이크로 초)을 제어합니다. 기본적으로 binlog_group_commit_sync_delay는 0으로 설정되며 이는 지연이 없음을 의미합니다.
# binlog_group_commit_sync_delay를 마이크로 초 지연으로 설정하면 더 많은 트랜잭션을 한 번에 디스크에 동기화하여 더 큰 그룹이 그룹당 더 적은 시간 단위를 필요로하기 때문에 트랜잭션 그룹을 커밋하는 전체 시간을 줄입니다.
# 
# sync_binlog = 0 또는 sync_binlog = 1이 설정되면 binlog_group_commit_sync_delay에 의해 지정된 지연이 동기화 전 (또는 진행 전 sync_binlog = 0의 경우)의 모든 이진 로그 커밋 그룹에 적용됩니다.
# sync_binlog가 1보다 큰 값 n으로 설정되면 n 개의 이진 로그 커밋 그룹마다 지연이 적용됩니다.
# 
# binlog_group_commit_sync_delay를 설정하면 복제 슬레이브가 있거나 장애 조치 후에있을 수있는 모든 서버에서 병렬 커밋 트랜잭션의 수가 증가하여 복제 슬레이브에서 병렬 실행이 증가 할 수 있습니다.
# 이 효과의 이점을 얻으려면 슬레이브 서버에 slave_parallel_type = LOGICAL_CLOCK이 설정되어 있어야하며 binlog_transaction_dependency_tracking = COMMIT_ORDER도 설정하면 효과가 더 중요합니다.
# binlog_group_commit_sync_delay 설정을 조정할 때 마스터 처리량과 슬레이브 처리량을 모두 고려해야합니다.
# 
# binlog_group_commit_sync_delay를 설정하면 이진 로그가있는 서버 (마스터 또는 슬레이브)의 이진 로그에 대한 fsync () 호출 수를 줄일 수도 있습니다.
# 
# binlog_group_commit_sync_delay를 설정하면 서버에서 트랜잭션 대기 시간이 증가하여 클라이언트 응용 프로그램에 영향을 줄 수 있습니다.
# 또한 동시 작업이 많은 경우 지연이 경합을 증가시켜 처리량을 줄일 수 있습니다. 일반적으로 지연 설정의 이점은 단점보다 중요하지만 최적의 설정을 결정하려면 항상 조정을 수행해야합니다.
#
# * Apply Option
# binlog_group_commit_sync_delay=0
# 
# --------------------------------------------
# 
# @ binlog_group_commit_sync_no_delay_count
# 
# Property : Value
# Command-Line Format : --binlog-group-commit-sync-no-delay-count=#
# System Variable : binlog_group_commit_sync_no_delay_count
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 1000000
# 
# binlog_group_commit_sync_delay에 지정된대로 현재 지연을 중단하기 전에 대기 할 최대 트랜잭션 수입니다. binlog_group_commit_sync_delay를 0으로 설정하면이 옵션이 적용되지 않습니다.
#
# * Apply Option
# binlog_group_commit_sync_no_delay_count=0
# 
# --------------------------------------------
# 
# @ binlog_order_commits
# 
# Property : Value
# Command-Line Format : --binlog-order-commits[={OFF|ON}]
# System Variable : binlog_order_commits
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 이 변수가 복제 마스터 (기본값)에서 활성화되면 스토리지 엔진에 발행 된 트랜잭션 커밋 명령이 단일 스레드에서 직렬화되므로 트랜잭션은 항상 이진 로그에 기록 된 순서와 동일한 순서로 커밋됩니다.
# 이 변수를 비활성화하면 여러 스레드를 사용하여 트랜잭션 커밋 명령을 실행할 수 있습니다.
# 이진 로그 그룹 커밋과 함께 사용하면 단일 트랜잭션의 커밋 속도가 처리량에 병목 현상이 발생하지 않도록하여 성능이 향상 될 수 있습니다.
# 
# 트랜잭션은 관련된 모든 스토리지 엔진이 트랜잭션을 커밋 할 준비가되었음을 확인한 시점에 이진 로그에 기록됩니다. 이진 로그 그룹 커밋 논리는 이진 로그 쓰기가 발생한 후 트랜잭션 그룹을 커밋합니다.
# binlog_order_commits가 비활성화되면이 프로세스에 여러 스레드가 사용되므로 커밋 그룹의 트랜잭션이 이진 로그의 순서와 다른 순서로 커밋 될 수 있습니다. (단일 클라이언트의 트랜잭션은 항상 시간 순서대로 커밋됩니다.)
# 많은 경우에 별도의 트랜잭션에서 수행되는 작업이 일관된 결과를 생성해야하기 때문에 중요하지 않으며, 그렇지 않은 경우 단일 트랜잭션을 대신 사용해야합니다.
# 
# 마스터 및 멀티 스레드 복제 슬레이브의 트랜잭션 기록이 동일하게 유지되도록하려면 slave_preserve_commit_order = 1을 설정하십시오.
#
# * Apply Option
# binlog_order_commits=ON
# 
# --------------------------------------------
# 
# @ binlog_row_image
# 
# Property : Value
# Command-Line Format : --binlog-row-image=image_type
# System Variable : binlog_row_image
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : full
# Valid Values	
# full (Log all columns)
# minimal (Log only changed columns, and columns needed to identify rows)
# noblob (Log all columns, except for unneeded BLOB and TEXT columns)
# 
# MySQL 행 기반 복제의 경우이 변수는 행 이미지가 이진 로그에 기록되는 방식을 결정합니다.
# 
# MySQL 행 기반 복제에서 각 행 변경 이벤트에는 업데이트 할 행을 검색 할 때 열이 일치하는 "이전"이미지와 변경 사항이 포함 된 "이후"이미지의 두 이미지가 포함됩니다.
# 일반적으로 MySQL은 이전 및 이후 이미지 모두에 대해 전체 행 (즉, 모든 열)을 기록합니다.
# 그러나 두 이미지 모두에 모든 열을 반드시 포함 할 필요는 없으며 실제로 필요한 열만 로깅하여 디스크, 메모리 및 네트워크 사용량을 절약 할 수 있습니다.
# 
# 노트
# 행을 삭제하면 삭제 후 전파 할 변경된 값이 없으므로 이전 이미지 만 기록됩니다. 행을 삽입 할 때 일치하는 기존 행이 없으므로 이후 이미지 만 기록됩니다.
# 행을 업데이트 할 때만 사전 및 사후 이미지가 필요하며 둘 다 이진 로그에 기록됩니다.
# 
# 이전 이미지의 경우 행을 고유하게 식별하는 데 필요한 최소 열 세트 만 기록하면됩니다. 행을 포함하는 테이블에 기본 키가 있으면 기본 키 열만 이진 로그에 기록됩니다.
# 그렇지 않으면 테이블에 고유 한 키가 있고 모든 열이 NULL이 아닌 경우 고유 키의 열만 기록하면됩니다. (테이블에 기본 열이나 NULL 열이없는 고유 키가없는 경우 모든 열을 이전 이미지에서 사용하고 기록해야합니다.)
# 이후 이미지에서는 실제로 변경된 열만 기록해야합니다.
# 
# binlog_row_image 시스템 변수를 사용하여 서버가 전체 또는 최소 행을 기록하도록 할 수 있습니다. 이 변수는 실제로 다음 목록에 표시된 것처럼 세 가지 가능한 값 중 하나를 사용합니다.
# + 전체 : 이전 이미지와 이후 이미지 모두에 모든 열을 기록합니다.
# + 최소 : 변경 될 행을 식별하는 데 필요한 이전 이미지의 열만 기록합니다. SQL 문에 의해 값이 지정되었거나 자동 증가에 의해 생성 된 이후 이미지의 열만 기록하십시오.
# + noblob : 행을 식별하는 데 필요하지 않거나 변경되지 않은 BLOB 및 TEXT 열을 제외하고 모든 열 (전체와 동일)을 기록하십시오.
# 
# 노트
# 이 변수는 NDB 클러스터에서 지원되지 않습니다. NDB 테이블 로깅에는 영향을 미치지 않습니다.
# 
# 기본값은 전체입니다.
# 
# 최소 또는 noblob를 사용하는 경우 소스 및 대상 테이블 모두에 대해 다음 조건이 충족되는 경우에만 지정된 테이블에 대해 삭제 및 업데이트가 올바르게 작동합니다.
# + 모든 열은 반드시 같은 순서로 있어야합니다. 각 열은 다른 테이블의 해당 열과 동일한 데이터 형식을 사용해야합니다.
# + 테이블은 동일한 기본 키 정의를 가져야합니다.
# (즉, 테이블은 기본 키의 일부가 아닌 인덱스를 제외하고 테이블과 동일해야합니다.)
# 
# 이러한 조건이 충족되지 않으면 대상 테이블의 기본 키 열 값이 삭제 또는 업데이트에 고유 한 일치를 제공하기에 불충분 한 것으로 판명 될 수 있습니다. 이 경우 경고 나 오류가 발생하지 않습니다.
# 마스터와 슬레이브는 조용히 분기되어 일관성이 떨어집니다.
# 
# 이진 로깅 형식이 STATEMENT 인 경우이 변수를 설정해도 효과가 없습니다.
# binlog_format이 MIXED 인 경우 binlog_row_image 설정은 행 기반 형식을 사용하여 기록 된 변경 사항에 적용되지만이 설정은 명령문으로 기록 된 변경 사항에는 영향을 미치지 않습니다.
# 
# 전역 또는 세션 레벨에서 binlog_row_image를 설정해도 내재 된 커미트가 발생하지 않습니다. 이는 트랜잭션에 영향을주지 않고 트랜잭션이 진행되는 동안이 변수를 변경할 수 있음을 의미합니다.
#
# * Apply Option
# binlog_row_image=full
# 
# --------------------------------------------
# 
# @ binlog_rows_query_log_events
# 
# Property : Value
# Command-Line Format : --binlog-rows-query-log-events[={OFF|ON}]
# System Variable : binlog_rows_query_log_events
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 이 시스템 변수는 행 기반 로깅에만 영향을줍니다. 사용 가능한 경우, 서버는 행 쿼리 로그 이벤트와 같은 정보 로그 이벤트를 2 진 로그에 기록합니다.
# 이 정보는 행 업데이트에서 재구성 할 수 없을 때 마스터에서 발행 된 원래 쿼리를 얻는 것과 같은 디버깅 및 관련 목적으로 사용될 수 있습니다.
# 
# 이러한 정보 이벤트는 일반적으로 이진 로그를 읽는 MySQL 프로그램에서 무시되므로 백업에서 복제하거나 복원 할 때 문제가 발생하지 않습니다.
# 이를 보려면 mysqlbinlog의 --verbose 옵션을 -vv 또는 --verbose --verbose로 두 번 사용하여 상세 수준을 높이십시오.
#
# * Apply Option
# binlog_rows_query_log_events=OFF
# 
# --------------------------------------------
# 
# @ binlog_stmt_cache_size
# 
# Property : Value
# Command-Line Format : --binlog-stmt-cache-size=#
# System Variable : binlog_stmt_cache_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 32768
# Minimum Value : 4096
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# 이 변수는 트랜잭션 중에 발행 된 비 트랜잭션 명령문을 보유하기 위해 2 진 로그의 캐시 크기를 결정합니다.
# 서버가 트랜잭션 저장 엔진을 지원하고 서버에서 이진 로그가 활성화 된 경우 (--log-bin 옵션) 각 클라이언트에 대해 별도의 이진 로그 트랜잭션 및 명령문 캐시가 할당됩니다.
# 트랜잭션 중에 큰 비 트랜잭션 문을 자주 사용하는 경우이 캐시 크기를 늘려 성능을 향상시킬 수 있습니다.
# Binlog_stmt_cache_use 및 Binlog_stmt_cache_disk_use 상태 변수는이 변수의 크기를 조정하는 데 유용 할 수 있습니다. 5.4.4 절.“이진 로그”를 참조하십시오.
# 
# binlog_cache_size 시스템 변수는 트랜잭션 캐시의 크기를 설정합니다.
#
# * Apply Option
# binlog_stmt_cache_size=32768
# 
# --------------------------------------------
# 
# @ binlog_transaction_dependency_tracking
# 
# Property : Value
# Command-Line Format : --binlog-transaction-dependency-tracking=value
# Introduced	5.7.22
# System Variable : binlog_transaction_dependency_tracking
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : COMMIT_ORDER
# Valid Values  : COMMIT_ORDER, WRITESET, WRITESET_SESSION
# 
# 
# 마스터가 슬레이브의 멀티 스레드 애플리케이터가 병렬로 실행할 수있는 트랜잭션을 결정하기 위해 사용하는 종속성 정보 소스. 이 변수는 다음 목록에 설명 된 세 가지 값 중 하나를 사용할 수 있습니다.
# + COMMIT_ORDER : 종속성 정보는 마스터의 커밋 타임 스탬프에서 생성됩니다. 이것이 기본값입니다. 이 모드는이 변수가 WRITESET 또는 WRITESET_SESSION 인 경우에도 쓰기 세트가없는 모든 트랜잭션에 사용됩니다.
# 기본 키가없는 테이블을 업데이트하는 트랜잭션과 외래 키 제약 조건이있는 테이블을 업데이트하는 트랜잭션의 경우에도 마찬가지입니다.
# + WRITESET : 마스터의 쓰기 세트에서 종속성 정보가 생성되며 다른 튜플을 쓰는 트랜잭션을 병렬화 할 수 있습니다.
# + WRITESET_SESSION : 종속성 정보는 마스터의 쓰기 세트에서 생성되지만 동일한 세션에서 두 개의 업데이트를 다시 정렬 할 수는 없습니다.
# WRITESET 및 WRITESET_SESSION 모드는 COMMIT_ORDER 모드에서 반환 된 것보다 새로운 트랜잭션 종속성을 제공하지 않습니다.
# 
# transaction_write_set_extraction이 OFF이면이 변수의 값을 COMMIT_ORDER 이외의 값으로 설정할 수 없습니다.
# binlog_transaction_dependency_tracking의 현재 값이 WRITESET 또는 WRITESET_SESSION 인 경우 transaction_write_set_extraction의 값을 변경할 수 없습니다.
# 
# 주어진 행을 변경하기 위해 최신 트랜잭션을 유지하고 점검 할 행 해시 수는 binlog_transaction_dependency_history_size의 값에 의해 결정됩니다.
#
# * Apply Option
# binlog_transaction_dependency_tracking=COMMIT_ORDER
# 
# --------------------------------------------
# 
# @ binlog_transaction_dependency_history_size
# 
# Property : Value
# Command-Line Format : --binlog-transaction-dependency-history-size=#
# Introduced	5.7.22
# System Variable : binlog_transaction_dependency_history_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 25000
# Minimum Value : 1
# Maximum Value : 1000000
# 
# 메모리에 유지되고 주어진 행을 마지막으로 수정 한 트랜잭션을 찾는 데 사용되는 행 해시 수의 상한을 설정합니다. 이 수의 해시에 도달하면 히스토리가 제거됩니다.
#
# * Apply Option
# binlog_transaction_dependency_history_size=25000
# 
# --------------------------------------------
# 
# binlogging_impossible_mode
# 
# Command-Line Format : --binlogging-impossible-mode[=value]
# Introduced : 5.6.20
# Deprecated : 5.6.22
# System Variable : binlogging_impossible_mode
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : IGNORE_ERROR
# Valid Values : IGNORE_ERROR, ABORT_SERVER
# 
# 이 옵션은 더 이상 사용되지 않습니다. 향후 MySQL 릴리스에서 제거 될 것으로 예상됩니다. binlog_error_action 변수를 사용하여 서버가 바이너리 로그에 쓸 수 없을 때 발생하는 상황을 제어합니다.
#
# * Apply Option
# binlogging_impossible_mode=IGNORE_ERROR
# 
# --------------------------------------------
# 
# @ expire_logs_days
# 
# Property : Value
# Command-Line Format : --expire-logs-days=#
# System Variable : expire_logs_days
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 99
# 
# 자동 이진 로그 파일 제거 일 수입니다. 기본값은 0이며 "자동 제거 없음"을 의미합니다. 시작시 및 이진 로그를 비울 때 가능한 제거가 발생합니다.
# 5.4 절.“MySQL 서버 로그”에 표시된대로 로그 플러시가 발생합니다.
# 
# 이진 로그 파일을 수동으로 제거하려면 PURGE BINARY LOGS 문을 사용하십시오. 13.4.1.1 절.“PURGE BINARY LOGS 문”을 참조하십시오.
#
# * Apply Option
# expire_logs_days=0
# 
# 
# --------------------------------------------
# 
# @ log_bin
# 
# Property : Value
# System Variable : log_bin
# Scope : Global
# Dynamic : No
# Type : Boolean
# 
# 이진 로그 사용 여부입니다. --log-bin 옵션이 사용되면이 변수의 값은 ON입니다. 그렇지 않으면 OFF입니다.
# 이 변수는 이진 로깅 상태에 대해서만보고합니다 (활성화 또는 비활성화). 실제로 --log-bin이 설정된 값은보고하지 않습니다.
# 
# 5.4.4 절.“이진 로그”를 참조하십시오.
#
# * Apply Option
# log_bin=off
# 
# --------------------------------------------
# 
# @ log_bin_basename
# 
# Property : Value
# System Variable : log_bin_basename
# Scope : Global
# Dynamic : No
# Type : File name
# 
# --log-bin server 옵션으로 설정할 수있는 이진 로그 파일의 기본 이름과 경로를 유지합니다. MySQL 5.7에서 기본 이름은 접미사 -bin을 가진 호스트 컴퓨터의 이름입니다. 기본 위치는 데이터 디렉토리입니다.
#
# * Apply Option
# log_bin_basename=log_bin_basename
# 
# --------------------------------------------
# 
# @ log_bin_index
# 
# Property : Value
# Command-Line Format : --log-bin-index=file_name
# System Variable : log_bin_index
# Scope : Global
# Dynamic : No
# Type : File name
# 
# --log-bin-index 서버 옵션으로 설정할 수있는 이진 로그 인덱스 파일의 기본 이름과 경로를 유지합니다.
#
# * Apply Option
# log_bin_index=file_name
# 
# --------------------------------------------
# 
# @ log_bin_trust_function_creators
# 
# Property : Value
# Command-Line Format : --log-bin-trust-function-creators[={OFF|ON}]
# System Variable : log_bin_trust_function_creators
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 
# 이 변수는 이진 로깅이 활성화 된 경우에 적용됩니다. 안전하지 않은 이벤트가 2 진 로그에 기록되도록하는 저장된 함수를 작성하지 않도록 저장된 함수 작성자를 신뢰할 수 있는지 여부를 제어합니다.
# 0 (기본값)으로 설정하면 CREATE ROUTINE 또는 ALTER ROUTINE 권한 외에 SUPER 권한이없는 한 저장된 기능을 만들거나 변경할 수 없습니다.
# 0으로 설정하면 함수가 DETERMINISTIC 특성 또는 READS SQL DATA 또는 NO SQL 특성으로 선언되어야한다는 제한 사항이 적용됩니다.
# 변수가 1로 설정되면 MySQL은 저장된 함수 생성에 대해 이러한 제한을 시행하지 않습니다. 이 변수는 트리거 생성에도 적용됩니다. 23.7 절.“저장된 프로그램 이진 로깅”을 참조하십시오.
#
# * Apply Option
# log_bin_trust_function_creators=OFF
# 
# --------------------------------------------
# 
# @ log_bin_use_v1_row_events
# 
# Property : Value
# Command-Line Format : --log-bin-use-v1-row-events[={OFF|ON}]
# System Variable : log_bin_use_v1_row_events
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : OFF
# 
# 버전 2 이진 로깅이 사용 중인지 여부 이 변수가 0 (기본값, 사용 안함)이면 버전 2 2 진 로그 이벤트가 사용 중입니다.
# 이 변수가 1 (활성화) 인 경우, 서버는 버전 1 로깅 이벤트 (이전 릴리스에서 사용 된 유일한 이진 로그 이벤트 버전)를 사용하여 이진 로그를 작성하므로 이전 슬레이브에서 읽을 수있는 이진 로그를 생성합니다.
# 
# MySQL 5.7은 기본적으로 버전 2 이진 로그 행 이벤트를 사용합니다. 그러나 MySQL 5.6.6 이전의 MySQL Server 릴리스에서는 버전 2 이벤트를 읽을 수 없습니다.
# log_bin_use_v1_row_events를 활성화하면 mysqld는 버전 1 로깅 이벤트를 사용하여 이진 로그를 작성합니다.
# 
# 이 변수는 런타임시 읽기 전용입니다. 버전 1 및 버전 2 이진 이벤트 이진 로깅간에 전환하려면 서버 시작시 log_bin_use_v1_row_events를 설정해야합니다.
# 
# NDB 클러스터 복제의 업그레이드를 수행 할 때를 제외하고, log_bin_use_v1_row_events는 NDB $ EPOCH_TRANS ()를 충돌 감지 기능으로 사용하여 복제 충돌 감지 및 해결을 설정할 때 주로 중요합니다.
# 버전 2 이진 로그 행 이벤트가 필요합니다. 따라서이 변수와 --ndb-log-transaction-id는 호환되지 않습니다.
# 
# 노트
# MySQL NDB Cluster 7.5는 기본적으로 버전 2 이진 로그 행 이벤트를 사용합니다. 업그레이드 또는 다운 그레이드를 계획 할 때와 NDB 클러스터 복제를 사용하는 설정을 염두에 두어야합니다.
# 
# 자세한 내용은 21.6.11 절“NDB 클러스터 복제 충돌 해결”을 참조하십시오.
#
# * Apply Option
# log_bin_use_v1_row_events=OFF
# 
# --------------------------------------------
# 
# @ log_builtin_as_identified_by_password
# 
# Property : Value
# Command-Line Format : --log-builtin-as-identified-by-password[={OFF|ON}]
# System Variable : log_builtin_as_identified_by_password
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 이 변수는 사용자 관리 문의 바이너리 로깅에 영향을줍니다. 활성화되면 변수에 다음과 같은 효과가 있습니다.
# 
# 내장 인증 플러그인을 포함하는 CREATE USER 문에 대한 이진 로깅은 IDENTIFIED BY PASSWORD 절을 포함하도록 명령문을 재 작성합니다.
# 
# SET PASSWORD 문은 ALTER USER 문에 다시 쓰지 않고 SET PASSWORD 문으로 기록됩니다.
# 
# 제공된 일반 텍스트 (암호화되지 않은) 암호 대신 암호 해시를 기록하도록 SET PASSWORD 문이 변경되었습니다.
# 
# 이 변수를 활성화하면 5.6 및 5.7.6 이전 슬레이브와의 버전 간 복제 및 이진 로그에서이 구문이 필요한 응용 프로그램의 호환성이 향상됩니다.
#
# * Apply Option
# log_builtin_as_identified_by_password=OFF
# 
# --------------------------------------------
# 
# @ log_slave_updates
# 
# Property : Value
# Command-Line Format : --log-slave-updates[={OFF|ON}]
# System Variable : log_slave_updates
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : OFF
# 
# 슬레이브 서버가 마스터 서버로부터 수신 한 업데이트를 슬레이브 자체 바이너리 로그에 기록해야하는지 여부
# 
# 일반적으로 슬레이브는 마스터 서버에서 수신 한 모든 업데이트를 자체 이진 로그에 기록하지 않습니다. 이 변수를 활성화하면 슬레이브가 SQL 스레드가 수행 한 업데이트를 자체 이진 로그에 기록합니다.
# 이 옵션을 적용하려면 --log-bin 옵션으로 슬레이브를 시작하여 바이너리 로깅을 활성화해야합니다. 16.1.6 절.“복제 및 이진 로깅 옵션 및 변수”를 참조하십시오.
# 
# log_slave_updates는 복제 서버를 연결하려고 할 때 활성화됩니다. 예를 들어이 배열을 사용하여 복제 서버를 설정할 수 있습니다.
# 
# A-> B-> C
# 여기서 A는 슬레이브 B의 마스터 역할을하고 B는 슬레이브 C의 마스터 역할을합니다.이 작업을 수행하려면 B가 마스터이자 슬레이브 여야합니다.
# 이진 로깅을 활성화하려면 A와 B를 --log-bin으로 시작하고, log_slave_updates를 활성화 한 B는 A에서받은 업데이트가 B에 의해 이진 로그에 기록되도록해야합니다.
#
# * Apply Option
# log_slave_updates=OFF
# 
# --------------------------------------------
# 
# @ log_statements_unsafe_for_binlog
# 
# Property : Value
# Command-Line Format : --log-statements-unsafe-for-binlog[={OFF|ON}]
# Introduced	5.7.11
# System Variable : log_statements_unsafe_for_binlog
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 오류 1592가 발생하면 생성 된 경고가 오류 로그에 추가되는지 여부를 제어합니다.
#
# * Apply Option
# log_statements_unsafe_for_binlog=ON
# 
# --------------------------------------------
# 
# @ max_binlog_cache_size
# 
# Property : Value
# Command-Line Format : --max-binlog-cache-size=#
# System Variable : max_binlog_cache_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 18446744073709551615
# Minimum Value : 4096
# Maximum Value : 18446744073709551615
# 
# 트랜잭션에 이보다 많은 바이트의 메모리가 필요한 경우, 서버는 'max_binlog_cache_size'바이트 이상의 스토리지 오류가 필요한 다중 명령문 트랜잭션을 생성합니다.
# 최소값은 4096입니다. 가능한 최대 값은 16EB (엑사 바이트)입니다. 권장되는 최대 값은 4GB입니다. 이는 MySQL이 현재 4GB보다 큰 이진 로그 위치에서 작동 할 수 없기 때문입니다.
# 
# max_binlog_cache_size는 트랜잭션 캐시의 크기 만 설정합니다. 명령문 캐시의 상한은 max_binlog_stmt_cache_size 시스템 변수에 의해 결정됩니다.
# 
# max_binlog_cache_size 세션에 대한 가시성은 binlog_cache_size 시스템 변수의 세션에 대한 가시성과 일치합니다. 즉, 값을 변경하면 값이 변경된 후 시작된 새 세션에만 영향을줍니다.
#
# * Apply Option
# max_binlog_cache_size=18446744073709551615
# 
# --------------------------------------------
# 
# @ max_binlog_size
# 
# Property : Value
# Command-Line Format : --max-binlog-size=#
# System Variable : max_binlog_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1073741824
# Minimum Value : 4096
# Maximum Value : 1073741824
# 
# 이진 로그에 쓰면 현재 로그 파일 크기가이 변수의 값을 초과하면 서버는 이진 로그를 회전시킵니다 (현재 파일을 닫고 다음 파일을 엽니 다). 최소값은 4096 바이트입니다. 최대 및 기본값은 1GB입니다.
# 
# 트랜잭션은 하나의 청크로 이진 로그에 기록되므로 여러 이진 로그간에 분할되지 않습니다. 따라서 트랜잭션이 크면 max_binlog_size보다 큰 이진 로그 파일이 표시 될 수 있습니다.
# 
# max_relay_log_size가 0 인 경우 max_binlog_size 값은 릴레이 로그에도 적용됩니다.
#
# * Apply Option
# max_binlog_size=1073741824
# 
# --------------------------------------------
# 
# @ max_binlog_stmt_cache_size
# 
# Property : Value
# Command-Line Format : --max-binlog-stmt-cache-size=#
# System Variable : max_binlog_stmt_cache_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 18446744073709547520
# Minimum Value : 4096
# Maximum Value : 18446744073709547520
# 
# 트랜잭션 내의 비 트랜잭션 명령문에이 바이트 이상의 메모리가 필요한 경우 서버는 오류를 생성합니다. 최소값은 4096입니다. 최대 값 및 기본값은 32 비트 플랫폼에서 4GB이고 64 비트 플랫폼에서 16EB (엑사 바이트)입니다.
# 
# max_binlog_stmt_cache_size는 명령문 캐시의 크기 만 설정합니다. 트랜잭션 캐시의 상한은 max_binlog_cache_size 시스템 변수에 의해 독점적으로 관리됩니다.
#
# * Apply Option
# max_binlog_stmt_cache_size=18446744073709547520
# 
# --------------------------------------------
# 
# @ sync_binlog
# 
# Property : Value
# Command-Line Format : --sync-binlog=#
# System Variable : sync_binlog
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1
# Minimum Value : 0
# Maximum Value : 4294967295
# 
# MySQL 서버가 바이너리 로그를 디스크와 동기화하는 빈도를 제어합니다.
# + sync_binlog = 0 : MySQL 서버에 의한 이진 로그의 디스크 동기화를 비활성화합니다. 대신, MySQL 서버는 운영 체제에 의존하여 다른 파일에서와 같이 이진 로그를 때때로 디스크로 플러시합니다.
# 이 설정은 최상의 성능을 제공하지만 정전 또는 운영 체제 충돌시 서버가 이진 로그에 동기화되지 않은 트랜잭션을 커밋했을 수 있습니다.
# + sync_binlog = 1 : 트랜잭션이 커밋되기 전에 이진 로그를 디스크에 동기화합니다. 이것은 가장 안전한 설정이지만 증가 된 디스크 쓰기 수로 인해 성능에 부정적인 영향을 줄 수 있습니다.
# 정전 또는 운영 체제 충돌이 발생하면 이진 로그에서 누락 된 트랜잭션은 준비된 상태 일뿐입니다. 이를 통해 자동 복구 루틴이 트랜잭션을 롤백 할 수 있으므로 2 진 로그에서 트랜잭션이 유실되지 않습니다.
# + sync_binlog = N. 여기서 N은 0 또는 1 이외의 값입니다. 이진 로그는 N 이진 로그 커밋 그룹이 수집 된 후 디스크에 동기화됩니다.
# 정전 또는 운영 체제 충돌이 발생하면 서버가 이진 로그로 플러시되지 않은 트랜잭션을 커밋했을 수 있습니다. 이 설정은 증가 된 디스크 쓰기 수로 인해 성능에 부정적인 영향을 줄 수 있습니다.
# 값이 클수록 성능이 향상되지만 데이터 손실 위험이 높아집니다.
# 
# 트랜잭션과 함께 InnoDB를 사용하는 복제 설정에서 최대한의 내구성과 일관성을 유지하려면 다음 설정을 사용하십시오.
# + sync_binlog = 1.
# + innodb_flush_log_at_trx_commit = 1.
# 
# 주의
# 많은 운영 체제와 일부 디스크 하드웨어는 디스크 비우기 작업을 속입니다. 그들은 플러시가 발생하지 않았지만 mysqld에게 플러시가 발생했다고 말할 수 있습니다.
# 이 경우 권장 설정으로도 트랜잭션의 내구성을 보장 할 수 없으며 최악의 경우 정전으로 인해 InnoDB 데이터가 손상 될 수 있습니다.
# SCSI 디스크 컨트롤러 나 디스크 자체에서 배터리 백업 디스크 캐시를 사용하면 파일 플러시 속도가 빨라지고 작업이 더 안전 해집니다. 하드웨어 캐시에서 디스크 쓰기 캐싱을 비활성화 할 수도 있습니다.
#
# * Apply Option
# sync_binlog=1
# 
# --------------------------------------------
# 
# @ transaction_write_set_extraction
# 
# Property : Value
# Command-Line Format : --transaction-write-set-extraction[=value]
# System Variable : transaction_write_set_extraction
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values  : (≥ 5.7.14) - OFF, MURMUR32, XXHASH64
# Valid Values  : (≤ 5.7.13) - OFF, MURMUR32
# 
# 트랜잭션과 연관된 쓰기를 식별하는 해시를 생성하는 데 사용되는 알고리즘을 정의합니다. 그룹 복제를 사용하는 경우 해시 값은 분산 충돌 감지 및 처리에 사용됩니다.
# 그룹 복제를 실행하는 64 비트 시스템에서는 불필요한 해시 충돌을 피하여 인증 실패 및 사용자 트랜잭션 롤백을 방지하기 위해이를 XXHASH64로 설정하는 것이 좋습니다. 17.7.1 절“그룹 복제 요구 사항”을 참조하십시오.
# 
# 노트
# binlog_transaction_dependency_tracking이 WRITESET 또는 WRITESET_SESSION으로 설정되면이 변수의 값을 변경할 수 없습니다.
#
# * Apply Option
# transaction_write_set_extraction=OFF
# 
# =========================================================================
# =========== Global Transaction ID System Variables ======================
# =========================================================================
# 
# @ binlog_gtid_simple_recovery
# 
# Property : Value
# Command-Line Format : --binlog-gtid-simple-recovery[={OFF|ON}]
# System Variable : binlog_gtid_simple_recovery
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : ON
# 
# 이 변수는 MySQL이 시작되거나 재시작 될 때 GTID를 검색하는 동안 이진 로그 파일이 반복되는 방법을 제어합니다.
# 
# binlog_gtid_simple_recovery = TRUE (기본값) 인 경우 gtid_executed 및 gtid_purged의 값은 시작시 가장 최근의 가장 오래된 이진 로그 파일에서 Previous_gtids_log_event의 값을 기반으로 계산됩니다.
# 계산에 대한 설명은 gtid_purged 시스템 변수를 참조하십시오. 이 설정은 서버를 다시 시작하는 동안 2 개의 이진 로그 파일에만 액세스합니다.
# 서버의 모든 이진 로그가 MySQL 5.7.8 이상을 사용하여 생성되었고 MySQL 5.7.8 이상을 사용하는 경우 binlog_gtid_simple_recovery = TRUE를 항상 안전하게 사용할 수 있습니다.
# 
# binlog_gtid_simple_recovery = TRUE를 사용하면 다음 두 가지 상황에서 gtid_executed 및 gtid_purged가 잘못 초기화 될 수 있습니다.
# + 최신 이진 로그는 MySQL 5.7.5 또는 이전 버전에서 생성되었으며 gtid_mode는 일부 이진 로그의 경우 ON이지만 최신 이진 로그의 경우 OFF입니다.
# + SET @@ GLOBAL.gtid_purged 문은 MySQL 5.7.7 또는 이전 버전에서 발행되었으며 SET @@ GLOBAL.gtid_purged 문 시점에 활성화 된 이진 로그는 아직 제거되지 않았습니다.
# 
# 어떤 상황에서든 잘못된 GTID 세트가 계산되면 나중에 binlog_gtid_simple_recovery = FALSE로 서버를 다시 시작하더라도 잘못된 GTID 세트가 계산됩니다.
# 이러한 상황 중 하나가 서버에 적용되는 경우 서버를 시작하거나 다시 시작하기 전에 binlog_gtid_simple_recovery = FALSE를 설정하십시오.
# 두 번째 상황을 확인하려면 MySQL 5.7.7 또는 이전 버전을 사용하는 경우 SET @@ GLOBAL.gtid_purged 문을 실행 한 후 SHOW MASTER STATUS를 사용하여 확인할 수있는 현재 이진 로그 파일 이름을 적어 두십시오.
# 이 파일이 제거되기 전에 서버가 다시 시작되면 binlog_gtid_simple_recovery = FALSE를 설정해야합니다.
# 
# binlog_gtid_simple_recovery = FALSE가 설정되면 gtid_purged 시스템 변수에 설명 된대로 gtid_executed 및 gtid_purged를 계산하는 방법이 다음과 같이 2 진 로그 파일을 반복하도록 변경됩니다.
# + 최신 이진 로그 파일에서 Previous_gtids_log_event 및 GTID 로그 이벤트 값을 사용하는 대신 gtid_executed에 대한 계산은 최신 이진 로그 파일에서 반복되며
#   Previous_gtids_log_event 값과 첫 번째 이진 로그 파일의 모든 GTID 로그 이벤트를 사용합니다. Previous_gtids_log_event 값을 찾습니다.
#   서버의 최신 이진 로그 파일에 GTID 로그 이벤트가없는 경우 (예 : gtid_mode = ON이 사용되었지만 나중에 서버가 gtid_mode = OFF로 변경된 경우)이 프로세스는 시간이 오래 걸릴 수 있습니다.
# + 가장 오래된 이진 로그 파일에서 Previous_gtids_log_event의 값을 사용하는 대신 gtid_purged 계산은 가장 오래된 이진 로그 파일에서 반복되고 비어 있지 않은
#   Previous_gtids_log_event 값 또는 찾은 첫 번째 이진 로그 파일의 Previous_gtids_log_event 값을 사용합니다. 최소한 하나의 GTID 로그 이벤트 (GTID 사용이 해당 시점에서 시작됨을 나타냄).
#   서버의 이전 2 진 로그 파일에 GTID 로그 이벤트가없는 경우 (예 : gtid_mode = ON이 서버에서 최근에 설정된 경우),이 프로세스는 시간이 오래 걸릴 수 있습니다.
# 
# MySQL 버전 5.7.5에서는이 변수가 단순화 _binlog_gtid_recovery로 추가되었고 MySQL 버전 5.7.6에서는 binlog_gtid_simple_recovery로 이름이 변경되었습니다.
#
# * Apply Option
# binlog_gtid_simple_recovery=ON
# 
# --------------------------------------------
# 
# @ enforce_gtid_consistency
# 
# Property : Value
# Command-Line Format : --enforce-gtid-consistency[=value]
# System Variable : enforce_gtid_consistency
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values  : OFF, ON, WARN
# 
# 이 변수의 값에 따라, 서버는 GTID를 사용하여 안전하게 기록 할 수있는 명령문 만 실행하여 GTID 일관성을 강제합니다. GTID 기반 복제를 활성화하기 전에이 변수를 ON으로 설정해야합니다.
# 
# enforce_gtid_consistency가 구성 할 수있는 값은 다음과 같습니다.
# + OFF : 모든 트랜잭션이 GTID 일관성을 위반할 수 있습니다.
# + ON : 트랜잭션이 GTID 일관성을 위반할 수 없습니다.
# + WARN : 모든 트랜잭션이 GTID 일관성을 위반할 수 있지만이 경우 경고가 생성됩니다. WARN은 MySQL 5.7.6에서 추가되었습니다.
# 
# enforce_gtid_consistency가 ON으로 설정되면 GTID 안전 명령문을 사용하여 로그 할 수있는 명령문 만 로그 될 수 있으므로 여기에 나열된 조작을이 옵션과 함께 사용할 수 없습니다.
# + CREATE TABLE ... SELECT 문
# + 트랜잭션 내의 CREATE TEMPORARY TABLE 또는 DROP TEMPORARY TABLE 문
# + 트랜잭션 테이블과 비 트랜잭션 테이블을 모두 업데이트하는 트랜잭션 또는 명령문. 모든 비 트랜잭션 테이블이 임시 인 경우 비 트랜잭션 DML이 트랜잭션 DML과 동일한 트랜잭션 또는 동일한 명령문에서 허용되는 예외가 있습니다.
# 
# --enforce-gtid-consistency는 명령문에 이진 로깅이 발생하는 경우에만 적용됩니다.
# 서버에서 2 진 로깅이 사용 불가능하거나 명령문이 필터에 의해 제거되어 2 진 로그에 작성되지 않은 경우 GTID 일관성은 로그되지 않은 명령문에 대해 점검되거나 적용되지 않습니다.
# 
# 자세한 내용은 16.1.3.6 절“GTID를 사용한 복제 제한 사항”을 참조하십시오.
# 
# MySQL 5.7.6 이전에는 boolean enforce_gtid_consistency의 기본값이 OFF였습니다. 이전 릴리스와의 호환성을 유지하기 위해 MySQL 5.7.6에서는 열거의 기본값이 OFF로 설정되고
# 값없이 --enforce-gtid-consistency를 설정하면 값을 ON으로 설정하는 것으로 해석됩니다. 변수에는 0 = OFF = FALSE, 1 = ON = TRUE, 2 = WARN 값에 대한 여러 텍스트 별칭이 있습니다.
# 이것은 다른 열거 유형과 다르지만 이전 버전에서 사용 된 부울 유형과의 호환성을 유지합니다. 이러한 변경 사항은 변수가 반환하는 내용에 영향을줍니다.
# SELECT @@ ENFORCE_GTID_CONSISTENCY를 사용하여 'ENFORCE_GTID_CONSISTENCY'와 같은 변수를 표시하고
# SELECT * FROM INFORMATION_SCHEMA.VARIABLES WHERE 'VARIABLE_NAME'= 'ENFORCE_GTID_CONSISTENCY'와 같은 SELECT 변수는 모두 숫자 형식이 아닌 텍스트 형식을 반환합니다.
# @@ENFORCE_GTID_CONSISTENCY는 부울의 숫자 형식을 반환하지만 SHOW 및 정보 스키마의 텍스트 형식을 반환하므로 호환되지 않는 변경 사항입니다.
#
# * Apply Option
# enforce_gtid_consistency=OFF
# 
# --------------------------------------------
# 
# @ gtid_executed
# 
# Property : Value
# System Variable : gtid_executed
# System Variable : gtid_executed
# Scope : Global
# Scope : Global, Session
# Dynamic : No
# Dynamic : No
# Type : String
# 
# 글로벌 범위와 함께 사용되는 경우이 변수에는 서버에서 실행 된 모든 트랜잭션 세트와 SET gtid_purged 문으로 설정된 GTID의 표현이 포함됩니다.
# 이것은 SHOW MASTER STATUS 및 SHOW SLAVE STATUS 출력의 Executed_Gtid_Set 열 값과 동일합니다. 이 변수의 값은 GTID 세트입니다. 자세한 정보는 GTID 세트를 참조하십시오.
# 
# 서버가 시작되면 @@ GLOBAL.gtid_executed가 초기화됩니다. 바이너리 로그가 gtid_executed를 채우도록 반복되는 방법에 대한 자세한 정보는 binlog_gtid_simple_recovery를 참조하십시오.
# 그런 다음 트랜잭션이 실행되거나 SET gtid_purged 문이 실행되면 GTID가 세트에 추가됩니다.
# 
# 주어진 시간에 이진 로그에서 찾을 수있는 트랜잭션 세트는 GTID_SUBTRACT (@@ GLOBAL.gtid_executed, @@ GLOBAL.gtid_purged)와 같습니다. 즉, 아직 제거되지 않은 이진 로그의 모든 트랜잭션에 적용됩니다.
# 
# RESET MASTER를 실행하면이 변수의 글로벌 값 (세션 값이 아님)이 빈 문자열로 재설정됩니다. RESET MASTER로 인해 세트가 지워지는 경우 외에는이 세트에서 GTID가 제거되지 않습니다.
# 
# MySQL 5.7.7 이전에는이 ​​변수를 세션 범위와 함께 사용할 수 있었는데, 현재 세션에서 캐시에 기록 된 트랜잭션 세트의 표현이 포함되어있었습니다. 세션 범위는 MySQL 5.7.7에서 더 이상 사용되지 않습니다.
#
# * Apply Option
# gtid_executed=none
# 
# --------------------------------------------
# 
# @ gtid_executed_compression_period
# 
# Property : Value
# Command-Line Format : --gtid-executed-compression-period=#
# System Variable : gtid_executed_compression_period
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1000
# Minimum Value : 0
# Maximum Value : 4294967295
# 
# 이 많은 트랜잭션이 처리 될 때마다 mysql.gtid_executed 테이블을 압축하십시오. 0으로 설정하면이 테이블이 압축되지 않습니다.
# 이진 로그를 사용할 때 테이블 압축이 발생하지 않으므로 이진 로깅을 사용하지 않으면 변수 값을 설정해도 아무런 영향이 없습니다.
# 
# 자세한 정보는 mysql.gtid_executed 테이블 압축을 참조하십시오.
# 
# 이 변수는 MySQL 버전 5.7.5에서 executable_gtids_compression_period로 추가되었고 MySQL 버전 5.7.6에서 gtid_executed_compression_period로 이름이 변경되었습니다.
#
# * Apply Option
# gtid_executed_compression_period=1000
# 
# --------------------------------------------
# 
# @ gtid_mode
# 
# Property : Value
# Command-Line Format : --gtid-mode=MODE
# System Variable : gtid_mode
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values  : OFF, OFF_PERMISSIVE, ON_PERMISSIVE, ON
# 
# GTID 기반 로깅 사용 여부 및 로그에 포함 할 수있는 트랜잭션 유형을 제어합니다. MySQL 5.7.6 이전에는이 ​​변수가 읽기 전용이며 서버 시작시 --gtid-mode를 사용하여 설정되었습니다.
# MySQL 5.7.5 이전에는 --gtid-mode = ON으로 서버를 시작하려면 --log-bin 및 --log-slave-updates 옵션으로 서버를 시작해야했습니다. MySQL 5.7.5부터는 더 이상 필요하지 않습니다. mysql.gtid_executed 테이블을 참조하십시오.
# 
# MySQL 5.7.6에서는이 변수를 동적으로 설정할 수 있습니다. 글로벌 시스템 변수를 설정하기에 충분한 권한이 있어야합니다.
# 5.1.8.1 절.“시스템 변수 권한”을 참조하십시오. gtid_mode = ON을 설정하기 전에 enforce_gtid_consistency가 true 여야합니다. 이 변수를 수정하기 전에 16.1.5 절“온라인 서버에서 복제 모드 변경”을 참조하십시오.
# 
# MySQL 5.7.6 이상에 로그인 된 트랜잭션은 익명이거나 GTID를 사용할 수 있습니다. 익명 트랜잭션은 이진 로그 파일을 사용하여 특정 트랜잭션을 식별하는 위치에 있습니다.
# GTID 트랜잭션에는 트랜잭션을 참조하는 데 사용되는 고유 식별자가 있습니다. MySQL 5.7.6에 추가 된 OFF_PERMISSIVE 및 ON_PERMISSIVE 모드는 토폴로지에서 이러한 트랜잭션 유형의 혼합을 허용합니다. 다른 모드는 다음과 같습니다.
# + OFF : 새 트랜잭션과 복제 된 트랜잭션이 모두 익명이어야합니다.
# + OFF_PERMISSIVE : 새로운 거래는 익명입니다. 복제 된 트랜잭션은 익명 또는 GTID 트랜잭션 일 수 있습니다.
# + ON_PERMISSIVE : 새로운 거래는 GTID 거래입니다. 복제 된 트랜잭션은 익명 또는 GTID 트랜잭션 일 수 있습니다.
# + ON : 새 트랜잭션과 복제 된 트랜잭션 모두 GTID 트랜잭션이어야합니다.
# 
# 한 값에서 다른 값으로 변경하는 것은 한 번에 한 단계 만 가능합니다.
# 예를 들어, gtid_mode가 현재 OFF_PERMISSIVE로 설정되어 있으면 OFF 또는 ON_PERMISSIVE로 변경할 수 있지만 ON으로 변경할 수는 없습니다.
# 
# MySQL 5.7.6 이상에서 gtid_purged 및 gtid_executed의 값은 gtid_mode의 값에 관계없이 영구적입니다. 따라서 gtid_mode의 값을 변경 한 후에도이 변수에는 올바른 값이 포함됩니다.
# MySQL 5.7.5 및 이전 버전에서 gtid_purged 및 gtid_executed의 값은 gtid_mode = OFF 인 동안 지속되지 않습니다.
# 따라서 gtid_mode를 OFF로 변경 한 후 GTID를 포함하는 모든 이진 로그가 제거되면 이러한 변수의 값이 손실됩니다.
#
# * Apply Option
# gtid_mode=OFF
# 
# --------------------------------------------
# 
# @ gtid_next
# 
# Property : Value
# System Variable : gtid_next
# Scope : Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : AUTOMATIC
# Valid Values	AUTOMATIC, ANONYMOUS, UUID:NUMBER
# 
# 이 변수는 다음 GTID의 획득 여부와 방법을 지정하는 데 사용됩니다.
# 
# 이 시스템 변수의 세션 값 설정은 제한된 조작입니다. 세션 사용자에게는 제한된 세션 변수를 설정하기에 충분한 권한이 있어야합니다. 5.1.8.1 절.“시스템 변수 권한”을 참조하십시오.
# 
# gtid_next는 다음 값 중 하나를 사용할 수 있습니다.
# + 자동 : 자동으로 생성 된 다음 글로벌 트랜잭션 ID를 사용하십시오.
# + ANONYMOUS : 트랜잭션에는 전역 식별자가 없으며 파일 및 위치로만 식별됩니다.
# + UUID : NUMBER 형식의 글로벌 트랜잭션 ID
# 
# 위의 옵션 중 어떤 옵션이 유효한지는 gtid_mode 설정에 따라 다릅니다. 자세한 내용은 16.1.5.1 절“복제 모드 개념”을 참조하십시오. gtid_mode가 OFF이면이 변수를 설정해도 아무런 영향이 없습니다.
# 
# 이 변수가 UUID : NUMBER로 설정되고 트랜잭션이 커미트 또는 롤백 된 후 다른 명령문보다 먼저 명시적인 SET GTID_NEXT 문을 발행해야합니다.
# 
# MySQL 5.7.5 이상에서 DROP TABLE 또는 DROP TEMPORARY TABLE은 임시 테이블이있는 비 임시 테이블 또는 트랜잭션이없는 스토리지 엔진을 사용하는 임시 테이블이있는
# 트랜잭션 스토리지 엔진을 사용하는 임시 테이블의 조합에서 사용될 때 명시적인 오류와 함께 실패합니다. MySQL 5.7.5 이전에는 GTID가 활성화되었지만 gtid_next가 AUTOMATIC이 아닌 경우
# 이러한 테이블 조합 중 하나와 함께 사용될 때 DROP TABLE이 올바르게 작동하지 않았습니다. (버그 # 17620053)
# 
# MySQL 5.7.1에서는 CHANGE MASTER TO, START SLAVE, STOP SLAVE, REPAIR TABLE, OPTIMIZE TABLE, ANALYZE TABLE, CHECK TABLE, CREATE SERVER,
# ALTER SERVER, DROP SERVER, CACHE INDEX, LOAD INDEX INTO 문을 실행할 수 없습니다. gtid_next가 AUTOMATIC 이외의 값으로 설정된 경우 CACHE, FLUSH 또는 RESET; 이러한 경우 명령문이 오류와 함께 실패합니다.
# 이러한 진술은 MySQL 5.7.2 이상에서 허용되지 않습니다. (버그 # 16062608, 버그 # 16715809, 버그 # 69045) (버그 # 16062608)
#
# * Apply Option
# gtid_next=AUTOMATIC
# 
# --------------------------------------------
# 
# @ gtid_owned
# 
# Property : Value
# System Variable : gtid_owned
# Scope : Global, Session
# Dynamic : No
# Type : String
# 
# 이 읽기 전용 변수는 주로 내부 용입니다. 내용은 범위에 따라 다릅니다.
# 
# 전역 범위와 함께 사용되는 경우 gtid_owned는 현재 서버에서 사용중인 모든 GTID 목록을 소유하고있는 스레드 ID를 보유합니다.
# 이 변수는 주로 다중 스레드 복제 슬레이브가 트랜잭션이 다른 스레드에 적용되고 있는지 확인하는 데 유용합니다.
# Applier 스레드는 트랜잭션을 처리 할 때마다 트랜잭션의 GTID 소유권을 가져 오므로 @@ global.gtid_owned는 처리 기간 동안 GTID와 소유자를 표시합니다. 트랜잭션이 커밋되거나 롤백되면 Applier 스레드가 GTID의 소유권을 해제합니다.
# 
# 세션 범위와 함께 사용될 때 gtid_owned는 현재이 세션에서 사용 중이고 소유 한 단일 GTID를 보유합니다.
# 이 변수는 클라이언트가 gtid_next를 설정하여 트랜잭션에 대한 GTID를 명시 적으로 할당 한 경우 GTID 사용을 테스트하고 디버깅하는 데 주로 유용합니다.
# 이 경우 @@ session.gtid_owned는 트랜잭션이 커밋되거나 롤백 될 때까지 클라이언트가 트랜잭션을 처리 할 때마다 GTID를 표시합니다.
# 클라이언트가 트랜잭션 처리를 마치면 변수가 지워집니다. 세션에 gtid_next = AUTOMATIC을 사용하는 경우 gtid_owned는 트랜잭션에 대한 커밋 명령문을 실행하는 동안 잠깐만 채워 지므로
# @@global.gtid_owned를 읽을 경우 나열 될지라도 해당 세션에서 볼 수는 없습니다. 올바른 지점. 세션에서 클라이언트가 처리하는 GTID를 추적해야하는 경우 session_track_gtids 시스템 변수로 제어되는 세션 상태 추적기를 사용할 수 있습니다.
#
# * Apply Option
# gtid_owned=none
# 
# --------------------------------------------
# 
# @ gtid_purged
# 
# Property : Value
# System Variable : gtid_purged
# Scope : Global
# Dynamic : Yes
# Type : String
# 
# gtid_purged 시스템 변수 (@@ GLOBAL.gtid_purged)의 전역 값은 서버에서 커밋되었지만 서버의 이진 로그 파일에 존재하지 않는 모든 트랜잭션의 GTID로 구성된 GTID 세트입니다.
# gtid_purged는 gtid_executed의 서브 세트입니다. gtid_purged에는 다음과 같은 GTID 범주가 있습니다.
# + 슬레이브에서 바이너리 로깅이 비활성화 된 상태에서 커밋 된 복제 된 트랜잭션의 GTID
# + 이제 제거 된 이진 로그 파일에 기록 된 트랜잭션의 GTID
# + SET @@ GLOBAL.gtid_purged 문에 의해 세트에 명시 적으로 추가 된 GTID.
# 
# 서버가 시작되거나 다시 시작되면 gtid_purged의 전역 값이 GTID 세트로 초기화됩니다.
# 이 GTID 세트가 계산되는 방법에 대한 정보는 gtid_purged 시스템 변수를 참조하십시오.
# MySQL 5.7.7 이전의 이진 로그가 서버에있는 경우 서버 구성 파일에서 binlog_gtid_simple_recovery = FALSE를 설정하여 올바른 계산을 수행해야 할 수 있습니다.
# 이 설정이 필요한 상황에 대한 자세한 내용은 binlog_gtid_simple_recovery에 대한 설명을 참조하십시오.
# 
# RESET MASTER를 실행하면 gtid_purged의 값이 빈 문자열로 재설정됩니다.
# 
# 서버의 이진 로그에는 존재하지 않지만 특정 GTID 세트의 트랜잭션이 적용된 서버에 기록하기 위해 gtid_purged의 값을 설정할 수 있습니다.
# 이 조치의 사용 사례는 서버에서 하나 이상의 데이터베이스 백업을 복원하지만 서버에서 트랜잭션을 포함하는 관련 2 진 로그가없는 경우입니다.
# 
# MySQL 5.7에서는 gtid_executed가 빈 문자열 인 경우에만 gtid_purged의 값을 업데이트 할 수 있으므로 gtid_purged는 빈 문자열입니다.
# 복제가 이전에 시작되지 않았거나 복제가 이전에 GTID를 사용하지 않은 경우입니다. MySQL 5.7.6 이전에는 gtid_purged는 gtid_mode = ON 인 경우에만 설정할 수있었습니다.
# MySQL 5.7.6 이상에서 gtid_purged는 gtid_mode의 값에 관계없이 설정할 수 있습니다.
# 
# gtid_purged의 값을 지정된 GTID 세트로 바꾸려면 다음 명령문을 사용하십시오.
# SET @@GLOBAL.gtid_purged = 'gtid_set'
# 
# 참고사항
# MySQL 5.7.7 또는 이전 버전을 사용하는 경우 SET @@ GLOBAL.gtid_purged 문을 실행 한 후 서버를 다시 시작하기 전에 서버의 구성 파일에서 binlog_gtid_simple_recovery = FALSE를 설정해야합니다.
# 그렇지 않으면 gtid_purged가 잘못 계산 될 수 있습니다. 이 설정이 필요한 상황에 대한 자세한 내용은 binlog_gtid_simple_recovery에 대한 설명을 참조하십시오.
# 서버의 모든 이진 로그가 MySQL 5.7.8 이상을 사용하여 생성되었고 MySQL 5.7.8 이상을 사용하는 경우 binlog_gtid_simple_recovery = TRUE (MySQL 5.7.7의 기본 설정)는 항상 안전하게 사용할 수 있습니다.
#
# * Apply Option
# gtid_purged=none
# 
# --------------------------------------------