# ===========================================
# ======= Server System Variables  ==========
# ===========================================
# @ avoid_temporal_upgrade
# 
# Command-Line Format : --avoid-temporal-upgrade[={OFF|ON}]
# Deprecated : Yes
# System Variable : avoid_temporal_upgrade
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
#
# 이 변수는 ALTER TABLE이 5.6.4 이전 형식 (분수 초 정밀도를 지원하지 않는 TIME, DATETIME 및 TIMESTAMP 컬럼)인 것으로 확인된 임시 컬럼을 암시 적으로 업그레이드할지 여부를 제어합니다.
# 이러한 컬럼을 업그레이드하려면 테이블을 다시 빌드해야하므로 수행할 작업에 적용할 수 있는 빠른 변경을 사용할 수 없습니다.
# 
# 이 변수는 기본적으로 비활성화되어 있습니다. 이를 활성화하면 ALTER TABLE이 임시 컬럼을 다시 작성하지 않으므로 가능한 빠른 변경을 활용할 수 있습니다.
# 
# 이 변수는 더 이상 사용되지 않습니다. MySQL의 향후 릴리스에서 제거 될 것으로 예상됩니다.
# 
# * Apply Option
# avoid_temporal_upgrade=OFF
# 
# --------------------------------------------
# 
# @ autocommit
# 
# Property : Value
# Command-Line Format : --autocommit[={OFF|ON}]
# System Variable : autocommit
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 자동 커밋 모드 1로 설정하면 테이블에 대한 모든 변경 사항이 즉시 적용됩니다.
# 0으로 설정 COMMIT하면 트랜잭션을 수락하거나 ROLLBACK 취소 하는 데 사용해야 합니다. 경우 autocommit 0과 1로 변경, MySQL은 자동으로 수행 COMMIT열려있는 거래.
# 트랜잭션을 시작하는 또 다른 방법은 START TRANSACTIONor BEGIN 문 을 사용하는 것입니다. 페이지의 섹션 13.3.1, "START TRANSACTION은 COMMIT 및 ROLLBACK 문" .
# 기본적으로 클라이언트 연결은 1로 autocommit설정됩니다. 클라이언트를 기본값 0 autocommit으로 시작하려면 --autocommit=0옵션으로 서버를 시작하여 전역 값을 설정하십시오.
# 
# 옵션 파일을 사용하여 변수를 설정하려면 다음 행을 포함하십시오.
# [mysqld]
# autocommit=0
# 
# * Apply Option
# autocommit=ON
# 
# --------------------------------------------
# 
# @ automatic_sp_privileges
# 
# Command-Line Format	--automatic-sp-privileges[={OFF|ON}]
# System Variable	automatic_sp_privileges
# Scope	Global
# Dynamic	Yes
# Type	Boolean
# Default Value	ON
# 
# 이 변수의 값이 1 (기본값)이면 사용자가 루틴을 이미 실행하고 변경 또는 삭제할 수 없는 경우 서버는 저장 루틴의 작성자에게 EXECUTE 및 ALTER ROUTINE 권한을 자동으로 부여합니다.
# (루틴을 삭제하려면 ALTER ROUTINE 권한이 필요합니다.) 또한 루틴이 삭제될 때 서버는 작성자로부터 해당 권한을 자동으로 삭제합니다.
# automatic_sp_privileges가 0이면 서버는 이러한 권한을 자동으로 추가하거나 삭제하지 않습니다.
# 
# 루틴의 작성자는 CREATE 문을 실행하는데 사용되는 계정입니다. 이것은 루틴 정의에서 DEFINER로 명명된 계정과 동일하지 않을 수 있습니다.
# 
# --skip-new로 mysqld를 시작하면 automatic_sp_privileges는 OFF로 설정됩니다.
#
# * Apply Option
# automatic_sp_privileges=ON
# 
# --------------------------------------------
# 
# @ auto_increment_increment
# 
# Command-Line Format	--auto-increment-increment=#
# System Variable	auto_increment_increment
# Scope	Global, Session
# Dynamic	Yes
# Type	Integer
# Default Value	1
# Minimum Value	1
# Maximum Value	65535

# auto_increment_increment 및 auto_increment_offset은 소스간 복제와 함께 사용하기위한 것이며 AUTO_INCREMENT 열의 작업을 제어하는 데 사용할 수 있습니다.
# 두 변수 모두 전역 및 세션값이 있으며 각각 1에서 65,535 사이의 정수 값을 가정 할 수 있습니다. 이 두 변수중 하나의 값을 0으로 설정하면 값이 대신 1로 설정됩니다.
# 이 두 변수 중 하나의 값을 65,535보다 크거나 0보다 작은 정수로 설정하려고하면 값이 대신 65,535로 설정됩니다.
# auto_increment_increment 또는 auto_increment_offset의 값을 정수가 아닌 값으로 설정하려고 하면 오류가 발생하고 변수의 실제값은 변경되지 않습니다.
# 
# 참고사항
# auto_increment_increment는 NDB 테이블과 함께 사용하도록 지원됩니다.
# 
# 서버에서 그룹 복제가 시작되면 auto_increment_increment 값이 group_replication_auto_increment_increment 값으로 변경되며
# 기본값은 7이며 auto_increment_offset 값은 서버 ID로 변경됩니다. 그룹 복제가 중지되면 변경 사항이 되돌려집니다.
# 이러한 변경 사항은 auto_increment_increment 및 auto_increment_offset의 기본값이 각각 1 인 경우에만 수행되고 되돌려집니다.
# 해당 값이 이미 기본값에서 # 수정 된 경우 그룹 복제는 해당 값을 변경하지 않습니다.
# 
# auto_increment_increment 및 auto_increment_offset은 다음과 같이 AUTO_INCREMENT 컬럼 동작에 영향을줍니다.
# 
# auto_increment_increment는 연속 컬럼값 사이의 간격을 제어합니다. 예를 들면 :
# mysql> SHOW VARIABLES LIKE 'auto_inc%';
# +--------------------------+-------+
# | Variable_name            | Value |
# +--------------------------+-------+
# | auto_increment_increment | 1     |
# | auto_increment_offset    | 1     |
# +--------------------------+-------+
# 2 rows in set (0.00 sec)
# 
# mysql> CREATE TABLE autoinc1
#     -> (col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
#   Query OK, 0 rows affected (0.04 sec)
# 
# mysql> SET @@auto_increment_increment=10;
# Query OK, 0 rows affected (0.00 sec)
# 
# mysql> SHOW VARIABLES LIKE 'auto_inc%';
# +--------------------------+-------+
# | Variable_name            | Value |
# +--------------------------+-------+
# | auto_increment_increment | 10    |
# | auto_increment_offset    | 1     |
# +--------------------------+-------+
# 2 rows in set (0.01 sec)
# 
# mysql> INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);
# Query OK, 4 rows affected (0.00 sec)
# Records: 4  Duplicates: 0  Warnings: 0
# 
# mysql> SELECT col FROM autoinc1;
# +-----+
# | col |
# +-----+
# |   1 |
# |  11 |
# |  21 |
# |  31 |
# +-----+
# 4 rows in set (0.00 sec)
# 
# auto_increment_offset은 AUTO_INCREMENT 컬럼값의 시작점을 결정합니다.
# auto_increment_increment에 대한 설명에 제공된 예제와 동일한 세션동안 이러한 명령문이 실행된다고 가정합니다.
# mysql> SET @@auto_increment_offset=5;
# Query OK, 0 rows affected (0.00 sec)
# 
# mysql> SHOW VARIABLES LIKE 'auto_inc%';
# +--------------------------+-------+
# | Variable_name            | Value |
# +--------------------------+-------+
# | auto_increment_increment | 10    |
# | auto_increment_offset    | 5     |
# +--------------------------+-------+
# 2 rows in set (0.00 sec)
# 
# mysql> CREATE TABLE autoinc2
#     -> (col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
# Query OK, 0 rows affected (0.06 sec)
# 
# mysql> INSERT INTO autoinc2 VALUES (NULL), (NULL), (NULL), (NULL);
# Query OK, 4 rows affected (0.00 sec)
# Records: 4  Duplicates: 0  Warnings: 0
# 
# mysql> SELECT col FROM autoinc2;
# +-----+
# | col |
# +-----+
# |   5 |
# |  15 |
# |  25 |
# |  35 |
# +-----+
# 4 rows in set (0.02 sec)
# auto_increment_offset의 값이 auto_increment_increment의 값보다 크면 auto_increment_offset의 값은 무시됩니다.
# 
# 이러한 변수 중 하나가 변경된 후 AUTO_INCREMENT 열이 포함 된 테이블에 새 행이 삽입되면 일련의 AUTO_INCREMENT 값이 컬럼에 이미 있는 값과 관계없이
# 계산되고 다음 값이 삽입되기 때문에 결과가 직관적이지 않은 것처럼 보일 수 있습니다. AUTO_INCREMENT 컬럼의 기존 최대 값보다 큰 계열의 최소값입니다. 시리즈는 다음과 같이 계산됩니다.
# 
# auto_increment_offset + N × auto_increment_increment
# 
# 여기서 N은 계열 [1, 2, 3, ...]의 양의 정수 값입니다. 예를 들면 :
# mysql> SHOW VARIABLES LIKE 'auto_inc%';
# +--------------------------+-------+
# | Variable_name            | Value |
# +--------------------------+-------+
# | auto_increment_increment | 10    |
# | auto_increment_offset    | 5     |
# +--------------------------+-------+
# 2 rows in set (0.00 sec)
# 
# mysql> SELECT col FROM autoinc1;
# +-----+
# | col |
# +-----+
# |   1 |
# |  11 |
# |  21 |
# |  31 |
# +-----+
# 4 rows in set (0.00 sec)
# 
# mysql> INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);
# Query OK, 4 rows affected (0.00 sec)
# Records: 4  Duplicates: 0  Warnings: 0
# 
# mysql> SELECT col FROM autoinc1;
# +-----+
# | col |
# +-----+
# |   1 |
# |  11 |
# |  21 |
# |  31 |
# |  35 |
# |  45 |
# |  55 |
# |  65 |
# +-----+
# 8 rows in set (0.00 sec)
# 
# auto_increment_increment 및 auto_increment_offset에 대해 표시된 값은 시리즈 5 + N × 10, 즉 [5, 15, 25, 35, 45, ...]를 생성합니다.
# INSERT 이전의 col 열에있는 가장 높은 값은 31이고 AUTO_INCREMENT 시리즈에서 다음으로 사용 가능한 값은 35이므로 col에 대해 삽입된 값은 해당 지점에서
# 시작되고 결과는 SELECT 쿼리에 대해 표시된 것과 같습니다.
# 
# 이 두 변수의 효과를 단일 테이블로 제한하는 것은 불가능합니다. 이러한 변수는 MySQL 서버의 모든 테이블에있는 모든 AUTO_INCREMENT 열의 동작을 제어합니다.
# 두 변수의 전역 값이 설정되면 전역 값이 변경되거나 세션 값을 설정하여 재정의 될때까지 또는 mysqld가 다시 시작될 때까지 그 효과가 지속됩니다.
# 로컬 값이 설정된 경우 해당 세션중에 값이 변경되지 않는한 새 값은 세션 기간 동안 현재 사용자가 새 행을 삽입한 모든 테이블의 AUTO_INCREMENT 열에 영향을줍니다.
# 
# auto_increment_increment의 기본값은 1입니다.
#
# * Apply Option
# auto_increment_increment=1
# 
# --------------------------------------------
#
# @ auto_increment_offset
# 
# Command-Line Format	--auto-increment-offset=#
# System Variable	auto_increment_offset
# Scope	Global, Session
# Dynamic	Yes
# Type	Integer
# Default Value	1
# Minimum Value	1
# Maximum Value	65535
# 
# 이 변수의 기본값은 1입니다. 기본값을 그대로두고 서버에서 그룹 복제를 시작하면 서버 ID로 변경됩니다.
# 
# 참고사항
# auto_increment_offset도 NDB 테이블과 함께 사용할 수 있도록 지원됩니다.
#
# * Apply Option
# auto_increment_increment=1
# 
# --------------------------------------------
# 
# @ back_log :
# 
# Property : Value
# Command-Line Format : --back-log=#
# System Variable : back_log
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : 1
# Maximum Value : 65535
# 
# MySQL이 가질 수있는 미해결 연결 요청 수 이것은 메인 MySQL 스레드가 매우 짧은 시간에 많은 연결 요청을 받으면 작동합니다.
# 그런 다음 주 스레드가 연결을 확인하고 새 스레드를 시작하는 데 약간의 시간이 걸리지만 (아주 적은 시간이 소요됨) 이 back_log값은 MySQL이 일시적으로 새 요청에 대한 응답을 중지하기 전에
# 이 짧은 시간 동안 누적 될 수있는 요청 수를 나타냅니다. 단기간에 많은 수의 연결이 필요한 경우에만이 값을 늘려야합니다.
# 
# 즉,이 값은 들어오는 TCP / IP 연결에 대한 청취 큐의 크기입니다. 운영 체제에는이 큐의 크기에 대한 자체 제한이 있습니다.
# 
# Unix listen()시스템 호출 매뉴얼 페이지에 자세한 내용이 있어야합니다. 이 변수의 최대 값에 대해서는 OS 문서를 확인하십시오. back_log 운영 체제 제한보다 높게 설정할 수 없습니다.
# 기본값은 다음 수식을 기반으로하며 900으로 제한됩니다.
# 
# 50 + (max_connections / 5)
#
# * Apply Option
# back_log=-1
# 
# --------------------------------------------
# 
# @ basedir
# 
# Command-Line Format : --basedir=dir_name
# System Variable : basedir
# Scope : Global
# Dynamic : No
# Type : Directory name
# 
# MySQL 설치 기본 디렉토리
#
# * Apply Option
# basedir=<Directory>
# 
# --------------------------------------------
# 
# @ big_tables :
# 
# Property : Value
# Command-Line Format : --big-tables[={OFF|ON}]
# System Variable : big_tables
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 사용 가능한 경우, 서버는 모든 임시 테이블을 메모리가 아닌 디스크에 저장합니다.
# 이렇게하면 큰 임시 테이블이 필요한 작업의 대부분의 오류를 방지 할 수있을 뿐만 아니라 메모리 내 테이블이 충분한 쿼리 속도도 느려집니다. The table tbl_name is fullSELECT
# 
# 새 연결의 기본값은 OFF (메모리 내 임시 테이블 사용)입니다.
# 일반적으로 서버가 작은 임시 테이블의 메모리를 사용하고 필요에 따라 디스크 기반 테이블로 전환하여 큰 결과 세트를 자동으로 처리 할 수 ​​있으므로이 변수를 사용하지 않아도됩니다.
#
# * Apply Option
# big_tables=OFF
# 
# --------------------------------------------
# 
# @ connect_timeout :
# 
# Property : Value
# Command-Line Format : --connect-timeout=#
# System Variable : connect_timeout
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 10
# Minimum Value : 2
# Maximum Value : 31536000
# 
# mysqld 서버가로 응답하기 전에 연결 패킷을 기다리는 시간 ( 초) Bad handshake. 기본값은 10 초입니다.
# 클라이언트가 'XXX'에서 MySQL 서버에 대한 연결 끊김, 시스템 오류: errno와 같은 오류가 자주 발생하는 경우 connect_timeout 값을 늘리면 도움이 될 수 있습니다.
#
# * Apply Option
# connect_timeout=10
# 
# --------------------------------------------
# 
# bind_address
# 
# Command-Line Format	--bind-address=addr
# System Variable	bind_address
# Scope	Global
# Dynamic	No
# Type	String
# Default Value	*
# 
# MySQL 서버는 TCP / IP 연결을 위해 단일 네트워크 소켓에서 수신합니다. 이 소켓은 단일 주소에 바인딩되지만 주소가 여러 네트워크 인터페이스에 매핑 될 수 있습니다.
# 주소를 지정하려면 서버 시작시 bind_address = addr을 설정하십시오. 여기서 addr은 IPv4 또는 IPv6 주소 또는 호스트 이름입니다.
# addr이 호스트 이름이면 서버는 이름을 IP 주소로 확인하고 해당 주소에 바인딩합니다.
# 호스트 이름이 여러 IP 주소로 확인되는 경우 서버는 첫 번째 IPv4 주소 (있는 경우)를 사용하거나 첫 번째 IPv6 주소를 사용합니다.
# 
# 서버는 다음과 같이 다양한 유형의 주소를 처리합니다.
# 주소가 * 이면 서버는 모든 서버 호스트 IPv4 인터페이스에서 TCP / IP 연결을 허용하고 서버 호스트가 IPv6를 지원하는 경우 모든 IPv6 인터페이스에서 TCP / IP 연결을 허용합니다.
# 이 주소를 사용하여 모든 서버 인터페이스에서 IPv4 및 IPv6 연결을 모두 허용합니다. 이 값이 기본값입니다.
# 
# 주소가 0.0.0.0이면 서버는 모든 서버 호스트 IPv4 인터페이스에서 TCP / IP 연결을 허용합니다. 
# 주소가 ::이면 서버는 모든 서버 호스트 IPv4 및 IPv6 인터페이스에서 TCP / IP 연결을 허용합니다.
# 
# 주소가 IPv4 매핑 주소 인 경우 서버는 IPv4 또는 IPv6 형식의 해당 주소에 대한 TCP / IP 연결을 허용합니다.
# 예를 들어 서버가 :: ffff : 127.0.0.1에 바인딩 된 경우 클라이언트는 --host = 127.0.0.1 또는 --host = :: ffff : 127.0.0.1을 사용하여 연결할 수 있습니다.
# 주소가 "일반"IPv4 또는 IPv6 주소 (예 : 127.0.0.1 또는 :: 1) 인 경우 서버는 해당 IPv4 또는 IPv6 주소에 대해서만 TCP / IP 연결을 허용합니다.
# 주소 바인딩에 실패하면 서버에서 오류가 발생하고 시작되지 않습니다.
# 
# 서버를 특정 주소에 바인딩하려는 경우 mysql.user 시스템 테이블에 해당 주소에 연결하는 데 사용할 수있는 관리 권한이있는 계정이 포함되어 있는지 확인하십시오.
# 그렇지 않으면 서버를 종료 할 수 없습니다. 예를 들어 서버를 *에 바인딩하면 기존의 모든 계정을 사용하여 연결할 수 있습니다.
# 그러나 서버를 :: 1로 바인딩하면 해당 주소에서만 연결을 허용합니다. 이 경우 먼저 mysql.user 테이블에 'root'@ ':: 1'계정이 있는지 확인하여 서버에 계속 연결하여 종료 할 수 있습니다.
# 
# 이 변수는 임베디드 서버 (libmysqld)에 영향을 미치지 않으며 임베디드 서버 내에서 보이지 않습니다.
#
# * Apply Option
# bind_address=*
# 
# --------------------------------------------
# 
# @ block_encryption_mode
# 
# Command-Line Format : --block-encryption-mode=#
# System Variable : block_encryption_mode
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# Default Value : aes-128-ecb
# 
# 이 변수는 AES와 같은 블록 기반 알고리즘에 대한 블록 암호화 모드를 제어합니다. AES_ENCRYPT() 및 AES_DECRYPT()의 암호화에 영향을줍니다.
# 
# block_encryption_mode는 aes-keylen-mode 형식의 값을 취합니다. 여기서 keylen은 비트 단위의 키 길이이고 mode는 암호화 모드입니다.
# 값은 대소 문자를 구분하지 않습니다. 허용되는 keylen 값은 128, 192 및 # 256입니다. 허용되는 암호화 모드는 MySQL이 OpenSSL 또는 yaSSL을 사용하여 컴파일되었는지 여부에 따라 다릅니다.
# 
# OpenSSL의 경우 허용되는 모드 값은 ECB, CBC, CFB1, CFB8, CFB128, OFB입니다.
# 
# yaSSL의 경우 허용되는 모드 값은 ECB, CBC입니다.
# 
# 예를 들어, 다음 명령문은 AES 암호화 함수가 256 비트의 키 길이와 CBC 모드를 사용하도록합니다.
# 
# SET block_encryption_mode = 'aes-256-cbc';
# block_encryption_mode를 지원되지 않는 키 길이를 포함하는 값 또는 SSL 라이브러리가 지원하지 않는 모드로 설정하려고하면 오류가 발생합니다.
#
# * Apply Option
# bind_address=*
# 
# --------------------------------------------
# 
# @ have_crypt
# 
# crypt() 시스템 호출이 서버에서 사용 가능하면 YES, 그렇지 않으면 NO. 그렇지 않으면 ENCRYPT() 함수를 사용할 수 없습니다.
# 
# --------------------------------------------
# 
# @ have_dynamic_loading
# 
# mysqld가 플러그인의 동적 로딩을 지원하면 YES, 그렇지 않으면 NO.
# 값이 NO이면 --plugin-load와 같은 옵션을 사용하여 서버 시작시 플러그인을로드하거나 INSTALL PLUGIN 문을 사용하여 런타임에 플러그인을로드 할 수 없습니다.
# 
# --------------------------------------------
# 
# @ have_geometry
# 
# 서버가 공간 데이터 유형을 지원하면 YES, 그렇지 않으면 NO.
# 
# --------------------------------------------
# 
# @ have_openssl
# 
# 이 변수는 have_ssl의 동의어입니다.
# 
# --------------------------------------------
# 
# @ have_ssl
# 
# System Variable : have_ssl
# Scope : Global
# Dynamic : No
# Type : String
# Valid Values : YES (SSL support available),
                 DISABLED (SSL support was compiled into server, but server was not started with necessary options to enable it)
# 
# mysqld가 SSL 연결을 지원하면 YES, 서버가 SSL 지원으로 컴파일되었지만 적절한 연결 암호화 옵션으로 시작되지 않은 경우 DISABLED입니다.
# 자세한 내용은 2.9.6 절.“SSL 라이브러리 지원 구성”을 참조하십시오.
# 
# 
# --------------------------------------------
# 
# @ have_symlink
# 
# 심볼릭 링크 지원이 활성화 된 경우 YES, 그렇지 않은 경우 NO.
# 이것은 DATA DIRECTORY 및 INDEX DIRECTORY 테이블 옵션을 지원하기 위해 Unix에서 필요합니다.
# 서버가 --skip-symbolic-links 옵션으로 시작된 경우 값은 DISABLED입니다.
# 
# 이 변수는 Windows에서 의미가 없습니다.
# 
# 
# --------------------------------------------
# 
# @ have_statement_timeout
# 
# System Variable : have_statement_timeout
# Scope : Global
# Dynamic : No
# Type : Boolean
# 
# Whether the statement execution timeout feature is available (see Statement Execution Time Optimizer Hints). The value can be NO if the background thread used by this feature could not be initialized.
# 
# 문 실행 시간 제한 기능을 사용할 수 있는지 여부 (명령문 실행 시간 최적화 프로그램 힌트 참조).
# 이 기능에서 사용하는 백그라운드 스레드를 초기화 할 수없는 경우 값은 NO 일 수 있습니다.
# 
# * Apply Option
# have_statement_timeout=<>
# 
# --------------------------------------------
# 
# @ have_profiling
# 
# 명령문 프로파일 링 기능이 있으면 YES, 그렇지 않으면 NO.
# 프로파일 링 시스템 변수가있는 경우이 기능의 활성화 또는 비활성화 여부를 제어합니다. 섹션 13.7.5.31,“SHOW PROFILES 성명서”를 참조하십시오.
# 
# --------------------------------------------
# 
# @ have_query_cache
# 
# mysqld가 쿼리 캐시를 지원하면 YES, 그렇지 않으면 NO.
# 
# --------------------------------------------
# 

# 
# --------------------------------------------
# 
# date_format
# 이 변수는 사용되지 않습니다. 더 이상 사용되지 않으며 MySQL 8.0에서 제거되었습니다.
# 
# datetime_format
# 이 변수는 사용되지 않습니다. 더 이상 사용되지 않으며 MySQL 8.0에서 제거되었습니다.
# 
# --------------------------------------------
# 
# @ default_password_lifetime :
# 
# Property : Value
# Command-Line Format : --default-password-lifetime=#
# System Variable : default_password_lifetime
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : (>= 5.7.11)	0
# Default Value : (<= 5.7.10)	360
# Minimum Value : 0
# Maximum Value : 65535
# 
# 이 변수는 글로벌 자동 비밀번호 만료 정책을 정의합니다. 
# 기본값 default_password_lifetime 은 0이며 자동 암호 만료를 비활성화합니다. 의 값이 default_password_lifetime양의 정수 N이면 허용되는 암호 수명을 나타냅니다.
# 비밀번호는 매일 변경해야합니다 N.
# 
# ALTER USER 명령문 의 비밀번호 만기 옵션을 사용하여 개별 계정에 대해 글로벌 비밀번호 만기 정책을 원하는대로 대체 할 수 있습니다 . 6.2.11 절“비밀번호 관리”를 참조하십시오 .
# 
# 노트
# MySQL 5.7.11 이전의 기본값 default_password_lifetime 은 360입니다 (암호는 약 1 년에 한 번 변경해야 함).
# 해당 버전의 경우 default_password_lifetime 변수 또는 개별 사용자 계정을 변경하지 않으면 360 일 후에 모든 사용자 비밀번호가 만료되고이 경우 모든 사용자 계정이 제한 모드로 실행됩니다.
# 그러면 서버에 연결하는 클라이언트 (실제로 사용자 임)는 암호를 변경해야한다는 오류가 발생합니다.
# ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.
# 
# 그러나 서버에서 자동으로 연결하는 클라이언트 (예 : 스크립트로 만든 연결)에서는 놓치기 쉽습니다.
# 비밀번호 만료로 인해 이러한 클라이언트가 갑자기 작동하지 않게하려면 다음과 같이 해당 클라이언트의 비밀번호 만료 설정을 변경하십시오.
# 
# ALTER USER 'script'@'localhost' PASSWORD EXPIRE NEVER
# 또는 default_password_lifetime 변수를로 설정하여 0모든 사용자에 대해 자동 비밀번호 만료를 비활성화하십시오.
#
# * Apply Option
# default_password_lifetime=0
# 
# --------------------------------------------
# 
# @ disconnect_on_expired_password :
# 
# Property : Value
# Command-Line Format : --disconnect-on-expired-password[={OFF|ON}]
# System Variable : disconnect_on_expired_password
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : ON
# 
# 이 변수는 서버가 만료 된 비밀번호로 클라이언트를 처리하는 방법을 제어합니다.
# - 클라이언트가 만료 된 비밀번호를 처리 할 수 ​​있다고 표시하면 disconnect_on_expired_password 값은 관련이 없습니다. 서버는 클라이언트의 연결을 허용하지만 샌드 박스 모드로 둡니다.
# - 클라이언트가 만료 된 비밀번호를 처리 할 수 ​​있다고 표시하지 않으면 서버는 disconnect_on_expired_password 값에 따라 클라이언트를 처리합니다.
#   = disconnect_on_expired_password :가 활성화 된 경우 서버는 클라이언트 연결을 끊습니다.
#   = disconnect_on_expired_password :가 비활성화 된 경우 서버는 클라이언트의 연결을 허용하지만 샌드 박스 모드로 둡니다.
# 
# 만료 된 암호 처리와 관련된 클라이언트 및 서버 설정의 상호 작용에 대한 자세한 내용은 6.2.12 절“만료 된 암호의 서버 처리”를 참조하십시오.
# 
# * Apply Option
# disconnect_on_expired_password=ON
#
# --------------------------------------------
# 
# default_storage_engine
# 
# Command-Line Format	--default-storage-engine=name
# System Variable	default_storage_engine
# Scope	Global, Session
# Dynamic	Yes
# Type	Enumeration
# Default Value	InnoDB
# 
# 테이블의 기본 저장소 엔진입니다. 15장, 대체 스토리지 엔진을 참조하십시오. 이 변수는 영구 테이블에 대해서만 스토리지 엔진을 설정합니다.
# TEMPORARY 테이블에 대한 스토리지 엔진을 설정하려면 default_tmp_storage_engine 시스템 변수를 설정하십시오.
# 
# 사용 가능하고 활성화 된 스토리지 엔진을 확인하려면 SHOW ENGINES 문을 사용하거나 INFORMATION_SCHEMA ENGINES 테이블을 쿼리합니다.
# 
# 서버 시작시 기본 스토리지 엔진을 비활성화하는 경우 영구 테이블과 TEMPORARY 테이블 모두에 대한 기본 엔진을 다른 엔진으로 설정해야합니다. 그렇지 않으면 서버를 시작할 수 없습니다.
# 
# * Apply Option
# default_storage_engine=InnoDB
#
# --------------------------------------------
# 
# @ default_tmp_storage_engine :
# 
# Property : Value
# Command-Line Format : --default-tmp-storage-engine=name
# System Variable : default_tmp_storage_engine
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : InnoDB
#
# TEMPORARY 테이블의 기본 스토리지 엔진(CREATE TEMPORARY TABLE로 생성됨).
# 영구 테이블에 대한 스토리지 엔진을 설정하려면 default_storage_engine 시스템 변수를 설정하십시오. 또한 가능한 값에 관한 해당 변수에 대한 설명을 참조하십시오.
#
# 서버 시작시 기본 스토리지 엔진을 비활성화하는 경우 영구 및 TEMPORARY 테이블 모두에 대한 기본 엔진을 다른 엔진으로 설정해야 합니다. 그렇지 않으면 서버를 시작할 수 없습니다.
#
# * Apply Option
# default_tmp_storage_engine=InnoDB
# 
# --------------------------------------------
# 
# @ default_week_format
# 
# Command-Line Format : --default-week-format=#
# System Variable : default_week_format
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value	0
# Minimum Value	0
# Maximum Value	7
# 
# WEEK () 함수에 사용할 기본 모드 값입니다. Section 12.7,“날짜 및 시간 함수”를 참조하십시오.
# 
# * Apply Option
# default_week_format=0
# 
# --------------------------------------------
# 
# @ delayed_insert_limit
# 
# Command-Line Format : --delayed-insert-limit=#
# Deprecated : Yes
# System Variable : delayed_insert_limit
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 100
# Minimum Value : 1
# Maximum Value (64-bit platforms) : 18446744073709551615
# Maximum Value (32-bit platforms) : 4294967295
# 
# 
# 이 시스템 변수는 더 이상 사용되지 않습니다 (DELAYED 삽입이 지원되지 않기 때문). 향후 릴리스에서 제거 될 예정입니다.
# 
# * Apply Option
# delayed_insert_limit=100
# 
# --------------------------------------------
# 
# @ delayed_insert_timeout
# 
# Command-Line Format : --delayed-insert-timeout=#
# Deprecated : Yes
# System Variable : delayed_insert_timeout
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 300
# 
# 이 시스템 변수는 더 이상 사용되지 않습니다 (DELAYED 삽입이 지원되지 않기 때문). 향후 릴리스에서 제거 될 예정입니다.
# 
# * Apply Option
# delayed_insert_timeout=300
# 
# --------------------------------------------
# 
# @ delayed_queue_size
# 
# Command-Line Format : --delayed-queue-size=#
# Deprecated : Yes
# System Variable : delayed_queue_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1000
# Minimum Value : 1
# Maximum Value (64-bit platforms) : 18446744073709551615
# Maximum Value (32-bit platforms) : 4294967295
# 
# 이 시스템 변수는 더 이상 사용되지 않습니다 (DELAYED 삽입이 지원되지 않기 때문). 향후 릴리스에서 제거 될 예정입니다.
# 
# * Apply Option
# delayed_queue_size=1000
# 
# --------------------------------------------
# 
# @ disconnect_on_expired_password
# 
# Command-Line Format : --disconnect-on-expired-password[={OFF|ON}]
# System Variable : disconnect_on_expired_password
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : ON
# 
# 이 변수는 서버가 만료 된 암호로 클라이언트를 처리하는 방법을 제어합니다.
# -클라이언트가 만료된 암호를 처리 할 수 있다고 표시하면 disconnect_on_expired_password 값은 관련이 없습니다. 서버는 클라이언트의 연결을 허용하지만 샌드 박스 모드로 설정합니다.
# -클라이언트가 만료된 암호를 처리 할 수 있다고 표시하지 않으면 서버는 disconnect_on_expired_password 값에 따라 클라이언트를 처리합니다.
#    * disconnect_on_expired_password :가 활성화되면 서버는 클라이언트 연결을 끊습니다.
#    * disconnect_on_expired_password :가 비활성화 된 경우 서버는 클라이언트 연결을 허용하지만 샌드 박스 모드로 전환합니다.
# 
# 만료된 암호 처리와 관련된 클라이언트 및 서버 설정의 상호 작용에 대한 자세한 내용은 6.2.12 절“만료 된 암호의 서버 처리”를 참조하십시오.
# 
# * Apply Option
# disconnect_on_expired_password=ON
# 
# --------------------------------------------
# 
# @ div_precision_increment
# 
# Command-Line Format : --div-precision-increment=#
# System Variable : div_precision_increment
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 4
# Minimum Value : 0
# Maximum Value : 30
# 
# 이 변수는 / 연산자로 수행 한 나눗셈 연산 결과의 스케일을 증가시킬 자릿수를 나타냅니다. 기본값은 4입니다. 최소값과 최대 값은 각각 0과 30입니다. 다음 예제는 기본값 증가의 효과를 보여줍니다.
# 
# mysql> SELECT 1/7;
# +--------+
# | 1/7    |
# +--------+
# | 0.1429 |
# +--------+
# 
# mysql> SET div_precision_increment = 12;
# mysql> SELECT 1/7;
# +----------------+
# | 1/7            |
# +----------------+
# | 0.142857142857 |
# +----------------+
# 
# * Apply Option
# div_precision_increment=4
#
# --------------------------------------------
# 
# @ end_markers_in_json
# 
# Command-Line Format : --end-markers-in-json[={OFF|ON}]
# System Variable : end_markers_in_json
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 옵티 마이저 JSON 출력이 종료 마커를 추가해야하는지 여부입니다. MySQL 내부 : end_markers_in_json 시스템 변수를 참조하십시오.
# 
# * Apply Option
# end_markers_in_json=OFF
# 
# --------------------------------------------
# 
# @ event_scheduler :
# 
# Property : Value
# Command-Line Format : --event-scheduler[=value]
# System Variable : event_scheduler
# Scope : Global
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values  : ON, OFF, DISABLED
# 
# 이 변수는 이벤트 스케줄러를 활성화 또는 비활성화하고 시작 또는 중지합니다. 가능한 상태 값은 ON, OFF및 DISABLED이며 기본값은 OFF입니다.
# 이벤트 스케줄러를 켜는 것은 OFF상태를로 설정해야하는 이벤트 스케줄러를 비활성화하는 것과 다릅니다 DISABLED.
# 이 변수와 이벤트 스케줄러 작동에 미치는 영향 은 23.4.2 절.“이벤트 스케줄러 구성” 에서 자세히 설명합니다.
#
# * Apply Option
# event_scheduler=OFF
# 
# --------------------------------------------
# 
# @ foreign_key_checks :
# 
# Property : Value
# System Variable : foreign_key_checks
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 1 (기본값)로 설정하면 외래 키 제약 조건이 검사됩니다. 0으로 설정하면 외래 키 제약 조건이 무시되고 몇 가지 예외가 있습니다.
# 삭제 된 테이블을 재 작성할 때 테이블 정의가 테이블을 참조하는 외부 키 제한 조건을 준수하지 않으면 오류가 리턴됩니다.
# 마찬가지로 ALTER TABLE 외래 키 정의가 잘못 구성된 경우 작업이 오류를 반환합니다. 자세한 내용 은 13.1.18.6 절“FOREIGN 키 제약 조건”을 참조하십시오 .
# 
# 이 변수를 설정하면 NDB테이블과 동일한 효과가 테이블에 적용됩니다 InnoDB. 일반적으로 참조 무결성 을 강화하기 위해 정상 작동 중에이 설정을 활성화 된 상태로 둡니다.
# 외래 키 검사를 비활성화 InnoDB하면 부모 / 자식 관계에 필요한 순서와 다른 순서로 테이블 을 다시로드 할 때 유용 할 수 있습니다 . 13.1.18.6 절.“FOREIGN KEY 제약 조건”을 참조하십시오 .
#
# foreign_key_checks를 0으로 설정하면 데이터 정의 문에도 영향을 미칩니다.
# DROP SCHEMA는 스키마 외부의 테이블에서 참조하는 외래 키가 있는 테이블을 포함하더라도 스키마를 삭제하고, DROP TABLE은 다른 테이블에서 참조하는 외래 키를 가진 테이블을 삭제합니다.
# 
# 노트
# foreign_key_checks를 1로 설정 하면 기존 테이블 데이터의 스캔이 트리거되지 않습니다. 따라서 테이블에 추가 된 행 foreign_key_checks=0은 일관성을 검증하지 않습니다.
# foreign_key_checks = 0 인 경우에도 외래 키 제약 조건에 필요한 인덱스를 삭제할 수 없습니다. 인덱스를 삭제하기 전에 외래 키 제약 조건을 제거해야합니다 (버그 # 70260).
#
# * Apply Option
# foreign_key_checks=ON
# 
# --------------------------------------------
# 
# @ flush
# 
# Command-Line Format : --flush[={OFF|ON}]
# System Variable : flush
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# If ON, the server flushes (synchronizes) all changes to disk after each SQL statement. Normally, MySQL does a write of all changes to disk only after each SQL statement and lets the operating system handle the synchronizing to disk. See Section B.3.3.3, “What to Do If MySQL Keeps Crashing”. This variable is set to ON if you start mysqld with the --flush option.
# 
# Note
# If flush is enabled, the value of flush_time does not matter and changes to flush_time have no effect on flush behavior.
# 
# 
# ON이면 서버는 각 SQL 문 이후에 디스크의 모든 변경 사항을 플러시 (동기화)합니다.
# 일반적으로 MySQL은 각 SQL 문 후에 만 모든 변경 사항을 디스크에 기록하고 운영 체제가 디스크 동기화를 처리하도록합니다.
# B.3.3.3 절.“MySQL이 계속 충돌하는 경우 수행 할 작업”을 참조하십시오. --flush 옵션으로 mysqld를 시작하면이 변수는 ON으로 설정됩니다.
# 
# 노트
# flush가 활성화 된 경우 flush_time의 값은 중요하지 않으며 flush_time의 변경 사항은 플러시 동작에 영향을주지 않습니다.
# 
# * Apply Option
# flush=OFF
# 
# --------------------------------------------
# 
# @ flush_time
# 
# Command-Line Format : --flush-time=#
# System Variable : flush_time
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# 
# 이 값이 0이 아닌 값으로 설정되면 모든 테이블이 flush_time 초마다 닫혀 리소스를 확보하고 플러시되지 않은 데이터를 디스크에 동기화합니다.
# 이 옵션은 최소한의 리소스가있는 시스템에서만 사용하는 것이 가장 좋습니다.
# 
# 노트
# flush가 활성화 된 경우 flush_time의 값은 중요하지 않으며 flush_time의 변경 사항은 플러시 동작에 영향을주지 않습니다.
# 
# * Apply Option
# flush_time=0
# 
# --------------------------------------------
# 
# @ general_log :
# 
# Property : Value
# Command-Line Format : --general-log[={OFF|ON}]
# System Variable : general_log
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 일반 쿼리 로그 사용 여부 OFF로그를 사용하지 않으려면 값을 0 (또는 )으로 설정하고 로그를 사용하려면 1 (또는 ON) 값을 지정할 수 있습니다.
# 로그 출력 대상은 log_output시스템 변수에 의해 제어됩니다 . 해당 값이 NONE인 경우, 로그가 사용 가능하더라도 로그 항목이 기록되지 않습니다.
#
# * Apply Option
# general_log=OFF
# 
# --------------------------------------------
# 
# @ general_log_file :
# 
# Property : Value
# Command-Line Format : --general-log-file=file_name
# System Variable : general_log_file
# Scope : Global
# Dynamic : Yes
# Type : File name
# Default Value : host_name.log
# 
# 일반 쿼리 로그 파일의 이름입니다. 기본값은 host_name.log이지만 --general_log_file옵션을 사용 하여 초기 값을 변경할 수 있습니다 .
# 
# * Apply Option
# general_log_file=host_name.log
# 
# --------------------------------------------
# 
# @ group_concat_max_len :
# 
# Property : Value
# Command-Line Format : --group-concat-max-len=#
# System Variable : group_concat_max_len
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 1024
# Minimum Value : 4
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# 
# GROUP_CONCAT()함수 에 허용되는 최대 결과 길이 (바이트)입니다 . 기본값은 1024입니다.
#
# * Apply Option
# group_concat_max_len=1024
#
# --------------------------------------------
# 
# host_cache_size
# 
# Command-Line Format : --host-cache-size=#
# System Variable : host_cache_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : 0
# Maximum Value : 65536
# 
# 
# MySQL 서버는 클라이언트 호스트 이름과 IP 주소 정보를 포함하는 메모리 내 호스트 캐시를 유지하며 DNS (Domain Name System) 조회를 방지하는 데 사용됩니다.
# 5.1.11.2 절.“DNS 조회 및 호스트 캐시”를 참조하십시오.
# 
# host_cache_size 변수는 호스트 캐시의 크기뿐만 아니라 캐시 내용을 노출하는 성능 스키마 host_cache 테이블의 크기를 제어합니다.
# host_cache_size를 설정하면 다음과 같은 효과가 있습니다.
# - 크기를 0으로 설정하면 호스트 캐시가 비활성화됩니다. 캐시를 비활성화하면 서버는 클라이언트가 연결할 때마다 DNS 조회를 수행합니다.
# - 런타임시 크기를 변경하면 호스트 캐시를 지우고 host_cache 테이블을 자르고 차단 된 호스트의 차단을 해제하는 암시 적 호스트 캐시 플러시 작업이 발생합니다.
# 
# 기본값은 최대 500 개까지의 max_connections 값에 대해 1을 더한 128, max_connections 값에서 500 이상 20 씩 증가 할 때마다 1로 자동 크기가 조정되며 제한은 2000으로 제한됩니다.
# 
# --skip-host-cache 옵션을 사용하는 것은 host_cache_size 시스템 변수를 0으로 설정하는 것과 유사하지만
# host_cache_size는 서버 시작시뿐만 아니라 런타임시 호스트 캐시의 크기를 조정, 활성화 및 비활성화하는 데 사용할 수도 있기 때문에 더 유연합니다.
# --skip-host-cache를 사용하여 서버를 시작해도 host_cache_size 값에 대한 런타임 변경이 방지되지는 않지만 이러한 변경 사항은 적용되지 않으며
# host_cache_size가 0보다 크게 설정 되어도 캐시가 다시 활성화되지 않습니다.
#
# * Apply Option
# host_cache_size=-1
# 
# --------------------------------------------
# 
# @ identity
# 
# 이 변수는 last_insert_id 변수의 동의어입니다. 다른 데이터베이스 시스템과의 호환성을 위해 존재합니다. SELECT @@ identity로 값을 읽고 SET ID를 사용하여 설정할 수 있습니다.
# 
# --------------------------------------------
#
# @ interactive_timeout
# 
# Command-Line Format	--interactive-timeout=#
# System Variable	interactive_timeout
# Scope	Global, Session
# Dynamic	Yes
# Type	Integer
# Default Value	28800
# Minimum Value	1
# 서버가 대화식 연결을 닫기 전에 활동을 기다리는 시간 (초)입니다.
# 대화 형 클라이언트는 mysql_real_connect ()에 CLIENT_INTERACTIVE 옵션을 사용하는 클라이언트로 정의됩니다. wait_timeout도 참조하십시오.
#
# 
# --------------------------------------------
# 
# @ ignore_db_dirs
# 
# Deprecated : 5.7.16
# System Variable : ignore_db_dirs
# Scope : Global
# Dynamic : No
# Type : String
# 
# 데이터 디렉토리에서 데이터베이스 디렉토리로 간주되지 않는 쉼표로 구분 된 이름 목록입니다. 이 값은 서버 시작시 지정된 --ignore-db-dir 인스턴스에서 설정됩니다.
# 
# MySQL 5.7.11부터 --ignore-db-dir은 mysqld --initialize와 함께 데이터 디렉터리 초기화 시간에 사용되어 기존 데이터 디렉터리가 비어 있는지
# 여부를 평가하기 위해 서버가 무시해야하는 디렉터리를 지정할 수 있습니다. 2.10.1 절.“데이터 디렉토리 초기화”를 참조하십시오.
# 
# 이 시스템 변수는 MySQL 5.7에서 더 이상 사용되지 않습니다. MySQL 8.0에 데이터 딕셔너리가 도입되면서 불필요 해졌고 해당 버전에서 제거되었습니다.
# 
# --------------------------------------------
# 
# @ init_file
# 
# Command-Line Format : --init-file=file_name
# System Variable : init_file
# Scope : Global
# Dynamic : No
# Type : File name
# 
# 지정된 경우이 변수는 시작 프로세스 중에 읽고 실행할 SQL 문이 포함 된 파일의 이름을 지정합니다. 각 문은 한 줄에 있어야하며 주석을 포함해서는 안됩니다.
# 
# 서버가 --bootstrap, --initialize 또는 --initialize-insecure 옵션 중 하나로 시작되면 bootstap 모드에서 작동하며
# 파일에서 허용되는 명령문을 제한하는 일부 기능을 사용할 수 없습니다. 여기에는 계정 관리 (예 : CREATE USER 또는 GRANT),
# 복제 및 글로벌 트랜잭션 식별자와 관련된 문이 포함됩니다. 16.1.3 절.“전역 트랜잭션 식별자를 사용한 복제”를 참조하십시오.
#
# * Apply Option
# init_file=262144
# 
# --------------------------------------------
# 
# @ join_buffer_size :
# 
# Property : Value
# Command-Line Format : --join-buffer-size=#
# System Variable : join_buffer_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 262144
# Minimum Value : 128
# Maximum Value : (Other, 64-bit platforms)	18446744073709547520
# Maximum Value : (Other, 32-bit platforms)	4294967295
# Maximum Value : (Windows) - 4294967295
# 
# 일반 인덱스 스캔, 범위 인덱스 스캔 및 인덱스를 사용하지 않으므로 전체 테이블 스캔을 수행하는 조인에 사용되는 버퍼의 최소 크기입니다.
# 일반적으로 빠른 조인을 얻는 가장 좋은 방법은 인덱스를 추가하는 것입니다. join_buffer_size인덱스를 추가 할 수없는 경우 더 빠른 전체 조인을 얻으려면 값을 늘리십시오.
# 두 테이블 사이의 각 전체 결합에 대해 하나의 결합 버퍼가 할당됩니다. 인덱스가 사용되지 않는 여러 테이블 간의 복잡한 조인의 경우 여러 조인 버퍼가 필요할 수 있습니다.
# 블록 중첩 루프 또는 배치 키 액세스 알고리즘을 사용하지 않으면 각 일치하는 행을 보유하는 데 필요한 것보다 큰 버퍼를 설정하면 이득이 없으며
# 모든 조인은 최소 크기를 할당하므로이 변수를 전 세계적으로 큰 가치. 큰 조인을 수행하는 세션에서만 전역 설정을 작게 유지하고 세션 설정을 더 큰 값으로 변경하는 것이 좋습니다.
# 전역 크기가이를 사용하는 대부분의 쿼리에 필요한 것보다 큰 경우 메모리 할당 시간으로 인해 상당한 성능 저하가 발생할 수 있습니다.
# 블록 중첩 루프를 사용하면 첫 번째 테이블의 모든 행에서 필요한 모든 열이 조인 버퍼에 저장 될 때까지 큰 조인 버퍼가 유리할 수 있습니다.
# 이것은 쿼리에 따라 다릅니다. 최적의 크기는 첫 번째 테이블의 모든 행을 보유하는 것보다 작을 수 있습니다.
# 배치 키 액세스를 사용하는 경우 값은 join_buffer_size스토리지 엔진에 대한 각 요청의 키 배치 크기 를 정의합니다.
# 버퍼가 클수록 조인 작업의 오른쪽 테이블에 대한 순차적 액세스가 많아 져 성능이 크게 향상 될 수 있습니다.
# 기본값은 256KB입니다. 최대 허용 설정 join_buffer_size은 4GB-1입니다. 64 비트 플랫폼에는 더 큰 값이 허용됩니다 (64 비트 Windows는 큰 값이 경고와 함께 4GB-1로 잘립니다).
# 조인 버퍼링에 대한 추가 정보는 8.2.1.6 절.“중첩 루프 조인 알고리즘”을 참조하십시오 . 배치 키 액세스에 대한 자세한 내용은 8.2.1.11 절“블록 중첩 루프 및 배치 키 액세스 조인”을 참조하십시오 .
#
# * Apply Option
# join_buffer_size=262144
# 
# --------------------------------------------
# 
# @ large_files_support :
# 
# Property : Value
# System Variable : large_files_support
# Scope : Global
# Dynamic : No
# 
# mysqld가 큰 파일 지원 옵션으로 컴파일되었는지 여부
#
# * Apply Option
# large_files_support=없음. 상태만 확인
# 
# --------------------------------------------
# 
# @ large_pages :
# 
# Property : Value
# Command-Line Format : --large-pages[={OFF|ON}]
# System Variable : large_pages
# Scope : Global
# Dynamic : No
# Platform Specific	Linux
# Type : Boolean
# Default Value : OFF
# 
# 큰 페이지 지원 사용 여부 (--large-pages 옵션 사용) 8.12.4.2 절“대형 페이지 지원 활성화”를 참조하십시오.
#
# * Apply Option
# large_pages=OFF
# 
# --------------------------------------------
# 
# @ large_page_size :
# 
# Property : Value
# System Variable : large_page_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 0
# 
# 큰 페이지 지원이 활성화 된 경우 메모리 페이지 크기가 표시됩니다. 큰 메모리 페이지는 Linux에서만 지원됩니다.
# 다른 플랫폼에서는 이 변수의 값이 항상 0입니다. 8.12.4.2 절“대형 페이지 지원 활성화”를 참조하십시오.
#
# * Apply Option
# large_page_size=0
# 
# --------------------------------------------
# 
# @ last_insert_id :
# 
# LAST_INSERT_ID ()에서 반환 할 값입니다. 테이블을 업데이트하는 명령문에서 LAST_INSERT_ID ()를 사용하면 이진 로그에 저장됩니다.
# 이 변수를 설정해도 mysql_insert_id () C API 함수가 반환 한 값은 업데이트되지 않습니다.
# Auto increment에서 마지막으로 생성한 값을 리턴합니다.
# 
# --------------------------------------------
# 
# @ license
# 
# System Variable : license
# Scope : Global
# Dynamic : No
# Type : String
# Default Value : GPL
# 
# 서버에있는 라이센스 유형입니다.
# 
# --------------------------------------------
# 
# @ local_infile :
# 
# Property : Value
# Command-Line Format : --local-infile[={OFF|ON}]
# System Variable : local_infile
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 이 변수는 LOAD DATA 문에 대한 서버 측 LOCAL 기능을 제어합니다. local_infile 설정에 따라 서버는 클라이언트 측에서 LOCAL이 활성화 된 클라이언트의 로컬 데이터로드를 거부하거나 허용합니다.
# 
# 서버가 LOAD DATA LOCAL 문을 명시 적으로 거부하거나 허용하게하려면 각각 local_infile을 비활성화 또는 활성화하여 mysqld를 시작하십시오.
# (클라이언트 프로그램 및 라이브러리가 빌드 시간 또는 런타임에 구성되는 방식에 관계없이).
# local_infile은 런타임에 설정할 수도 있습니다. 자세한 내용은 6.1.6 절.“LOAD DATA LOCAL에 대한 보안 고려 사항”을 참조하십시오.
#
# * Apply Option
# local_infile=ON
# 
# --------------------------------------------
#
# @ locked_in_memory
# 
# System Variable : locked_in_memory
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : OFF
# 
# Whether mysqld was locked in memory with --memlock.
# mysqld가 --memlock으로 메모리에 잠겨 있는지 여부.
# 
# * Apply Option
# locked_in_memory=OFF
#
# --------------------------------------------
# 
# @ lock_wait_timeout :
# 
# Property : Value
# Command-Line Format : --lock-wait-timeout=#
# System Variable : lock_wait_timeout
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 31536000
# Minimum Value : 1
# Maximum Value : 31536000
# 
# 이 변수는 메타 데이터 잠금 획득 시도에 대한 제한 시간 (초)을 지정합니다. 허용되는 값의 범위는 1-31536000 (1 년)입니다. 기본값은 31536000입니다.
# 
# 이 timeout는 메타 데이터 잠금을 사용하는 모든 명령문에 적용됩니다.
# 여기에는 테이블, 뷰, 저장 프로 시저 및 저장 함수에 대한 DML 및 DDL 작업과 LOCK TABLES, FLUSH TABLES WITH READ LOCK 및 HANDLER 문이 포함됩니다.
# 
# GRANT 또는 REVOKE 문 또는 테이블 로깅 문으로 수정 된 권한 부여 테이블과 같이 mysql 데이터베이스의 시스템 테이블에 대한 암시 적 액세스에는 이 시간 제한이 적용되지 않습니다.
# 시간 종료는 SELECT 또는 UPDATE와 같이 직접 액세스 한 시스템 테이블에 적용됩니다.
# 
# timeout 값은 각 메타 데이터 잠금 시도에 대해 별도로 적용됩니다.
# 주어진 명령문에 둘 이상의 잠금이 필요할 수 있으므로 시간 종료 오류를 보고하기 전에 명령문이 lock_wait_timeout 값보다 길게 차단 될 수 있습니다.
# 잠금 시간 종료가 발생하면 ER_LOCK_WAIT_TIMEOUT이 보고됩니다.
# 
# lock_wait_timeout은 지연된 삽입에는 적용되지 않으며 항상 1 년의 시간 제한으로 실행됩니다.
# 지연된 삽입을 발행하는 세션이 지연된 삽입 제한 시간에 대한 알림을받지 않기 때문에 불필요한 시간 종료를 피하기 위해 수행됩니다.
#
# * Apply Option
# lock_wait_timeout=31536000
# 
# --------------------------------------------
# 
# @ log_error :
# 
# Property : Value
# Command-Line Format : --log-error[=file_name]
# System Variable : log_error
# Scope : Global
# Dynamic : No
# Type : File name
# 
# 오류 로그 출력 대상 대상이 콘솔 인 경우 값은 stderr입니다. 그렇지 않으면 대상은 파일이고 log_error 값은 파일 이름입니다.
# 5.4.2 절.“오류 로그”를 참조하십시오.
#
# * Apply Option
# log_error=/directory/file-name.log
# 
# --------------------------------------------
# 
# @ log_error_verbosity :
# 
# Property : Value
# Command-Line Format : --log-error-verbosity=#
# System Variable : log_error_verbosity
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 3
# Minimum Value : 1
# Maximum Value : 3
# 
# 오류, 경고 및 메모 메시지를 오류 로그에 기록 할 때 서버의 자세한 정보입니다. 다음 표는 허용되는 값을 보여줍니다. 기본값은 3입니다.
# 
# Desired Log Filtering	log_error_verbosity Value
# Error messages	1
# Error and warning messages	2
# Error, warning, and information messages	3
# 
# log_error_verbosity는 MySQL 5.7.2에서 추가되었습니다. 이전 log_warnings 시스템 변수보다 선호되며 대신 사용해야 합니다.
# 해당 변수가 log_error_verbosity와 어떤 관련이 있는지에 대한 정보는 log_warnings에 대한 설명을 참조하십시오.
# 특히, log_warnings에 값을 할당하면 log_error_verbosity에 값이 할당되고 그 반대도 마찬가지입니다.
#
# * Apply Option
# log_error_verbosity=3
# 
# --------------------------------------------
# 
# @ log_output :
# 
# Property : Value
# Command-Line Format : --log-output=name
# System Variable : log_output
# Scope : Global
# Dynamic : Yes
# Type : Set
# Default Value : FILE
# Valid Values  : TABLE, FILE, NONE
# 
# 일반 쿼리 로그 및 느린 쿼리 로그 출력의 대상입니다. 값은 TABLE, FILE 및 NONE에서 선택한 하나 이상의 쉼표로 구분된 단어 목록입니다.
# TABLE은 mysql 시스템 데이터베이스에서 general_log 및 slow_log 테이블에 로깅을 선택합니다. FILE은 로그 파일에 로깅을 선택합니다.
# NONE은 로깅을 비활성화합니다. 값에 NONE이 있으면 존재하는 다른 단어보다 우선합니다.
# TABLE 및 FILE 모두 로그 출력 대상을 모두 선택하도록 제공 될 수 있습니다.
# 
# 이 변수는 로그 출력 대상을 선택하지만 로그 출력을 활성화하지는 않습니다. 그렇게하려면 general_log 및 slow_query_log 시스템 변수를 활성화하십시오.
# FILE 로깅의 경우 general_log_file 및 slow_query_log_file 시스템 변수가 로그 파일 위치를 결정합니다.
# 자세한 내용은 5.4.1 절“일반 쿼리 로그 및 느린 쿼리 로그 출력 대상 선택”을 참조하십시오.
#
# * Apply Option
# log_output=FILE
# 
# --------------------------------------------
# 
# @ log_syslog :
# 
# Property : Value
# Command-Line Format : --log-syslog[={OFF|ON}]
# System Variable : log_syslog
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : (Windows) - ON
# Default Value : (Unix) - OFF
# 오류 로그 출력을 시스템 로그에 쓸지 여부. 이것은 Windows의 이벤트 로그이고 Unix 및 Unix 계열 시스템의 syslog입니다. 기본값은 플랫폼마다 다릅니다.
# 
# - Windows에서는 기본적으로 이벤트 로그 출력이 사용됩니다.
# - Unix 및 Unix 계열 시스템에서 syslog 출력은 기본적으로 비활성화되어 있습니다.
# 
# 기본값에 관계없이 지원되는 모든 플랫폼에서 출력을 제어하도록 log_syslog를 명시적으로 설정할 수 있습니다.
# 시스템 로그 출력 제어는 파일이나 콘솔로 오류 출력을 보내는 것과 다릅니다.
# 원하는대로 시스템 로그와 함께 또는 시스템 로그 대신 파일이나 콘솔로 오류 출력을 보낼 수 있습니다. 5.4.2 절.“오류 로그”를 참조하십시오.
#
# * Apply Option
# log_syslog=ON
# 
# --------------------------------------------
# 
# @ log_syslog_tag :
# 
# Property : Value
# Command-Line Format : --log-syslog-tag=tag
# System Variable : log_syslog_tag
# Scope : Global
# Dynamic : Yes
# Type : String
# Default Value : empty string
# syslog에 기록 된 오류 로그 출력에서 ​​서버 식별자에 추가 할 태그입니다.
# log_syslog 시스템 변수가 사용 가능하지 않으면이 변수가 적용되지 않습니다.
# 5.4.2.3 절.“시스템 로그에 오류 기록”을 참조하십시오.
# 
# 기본적으로 서버 식별자는 태그가없는 mysqld입니다.
# 태그의 태그 값이 지정되면, 앞에 하이픈이있는 서버 식별자에 추가되어 mysqld-tag의 식별자가됩니다.
# 
# Windows에서 아직 존재하지 않는 태그를 사용하려면 태그에 대한 레지스트리 항목을 작성할 수 있도록 관리자 권한이있는 계정에서 서버를 실행해야합니다.
# 태그가 이미 존재하면 높은 권한이 필요하지 않습니다.
#
# * Apply Option
# log_syslog_tag=tag_name
# 
# --------------------------------------------
# 
# @ log_warnings
# 
# Command-Line Format : --log-warnings[=#]
# Deprecated : Yes
# System Variable : log_warnings
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 2
# Minimum Value : 0
# Maximum Value (64-bit platforms) : 18446744073709551615
# Maximum Value (32-bit platforms) : 4294967295
# 
# 오류 로그에 추가 경고 메시지를 생성할지 여부입니다.
# MySQL 5.7.2부터 이전에 log_warnings에 의해 관리되는 정보 항목은 log_error_verbosity에 의해 관리되며,
# 이는 이전 log_warnings 시스템 변수보다 선호되며 대신 사용해야합니다.
# (log_warnings 시스템 변수 및 --log-warnings 명령 줄 옵션은 더 이상 사용되지 않으며 향후 MySQL 릴리스에서 제거 될 예정입니다.)
# 
# log_warnings는 기본적으로 활성화되어 있습니다 (기본값은 MySQL 5.7.2 이전 1, 5.7.2 기준 2). 비활성화하려면 0으로 설정합니다.
# 값이 0보다 크면 서버는 문 기반 로깅에 안전하지 않은 문에 대한 메시지를 기록합니다.
# 값이 1보다 크면 서버는 새 연결 시도에 대해 중단 된 연결 및 액세스 거부 오류를 기록합니다.
# B.3.2.9 절.“통신 오류 및 연결 중단”을 참조하십시오.
# 
# 복제를 사용하는 경우 네트워크 실패 및 재 연결에 대한 메시지와 같은 발생 상황에 대한
# 자세한 정보를 얻으려면 0보다 크게 설정하여이 변수를 활성화하는 것이 좋습니다.
# 
# log_warnings가 활성화된 상태에서 복제본 서버가 시작되면 복제본은 다른 릴레이 로그로 전환할 때 작업을 시작하는
# 이진 로그 및 릴레이 로그 좌표와 같은 상태에 대한 정보를 제공하기 위해 오류 로그에 메시지를 인쇄합니다. 연결이 끊어진 후 다시 연결됩니다.
# 
# log_warnings에 값을 할당하면 log_error_verbosity에 값이 할당되고 그 반대의 경우도 마찬가지입니다. 변수는 다음과 같이 관련됩니다.
# -log_warnings = 0으로 달성 된 모든 log_warnings 항목의 억제는 log_error_verbosity = 1로 달성됩니다 (오류 만 해당).
# -log_warnings = 1 이상으로 인쇄 된 항목은 경고로 간주되며 log_error_verbosity = 2 이상으로 인쇄됩니다.
# -log_warnings = 2에 대해 인쇄 된 항목은 메모로 간주되고 log_error_verbosity = 3에 대해 인쇄됩니다.
# 
# MySQL 5.7.2부터 기본 로그 수준은 기본값이 3 인 log_error_verbosity에 의해 제어됩니다.
# 또한 log_warnings의 기본값이 1에서 2로 변경되어 log_error_verbosity = 3에 해당합니다.
# 이전 기본값과 유사한 로깅 수준을 얻으려면 log_error_verbosity = 2를 설정합니다.
# 
# MySQL 5.7.2 이상에서는 log_warnings 사용이 여전히 허용되지만 다음과 같이 log_error_verbosity 사용에 매핑됩니다.
# -log_warnings = 0 설정은 log_error_verbosity = 1 (오류 만 해당)과 동일합니다.
# -log_warnings = 1 설정은 log_error_verbosity = 2 (오류, 경고)와 동일합니다.
# -log_warnings = 2 (또는 그 이상) 설정은 log_error_verbosity = 3 (오류, 경고, 참고)과 동일하며 더 큰 값이 지정되면 서버는 log_warnings를 2로 설정합니다.
# 
# * Apply Option
# log_warnings=tag_name
# 
# --------------------------------------------
#  
# @ low_priority_updates
# 
# Command-Line Format : --low-priority-updates[={OFF|ON}]
# System Variable : low_priority_updates
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value: OFF
# 
# 1로 설정하면 모든 INSERT, UPDATE, DELETE 및 LOCK TABLE WRITE 문은 영향을받는 테이블에 보류중인 SELECT 또는 LOCK TABLE READ가 없을 때까지 대기합니다.
# 동일한 효과를 얻으려면 {INSERT | REPLACE | DELETE | UPDATE} LOW_PRIORITY...를 사용하여 하나의 쿼리만 우선 순위를 낮출 수 있습니다.
# 이 변수는 테이블 수준 잠금 (예 : MyISAM, MEMORY 및 MERGE) 만 사용하는 스토리지 엔진에만 영향을줍니다. 8.11.2 절“테이블 잠금 문제”를 참조하십시오.
# 
# * Apply Option
# low_priority_updates=tag_name
# 
# --------------------------------------------
# 
# @ lower_case_table_names :
# 
# Property : Value
# Command-Line Format : --lower-case-table-names[=#]
# System Variable : lower_case_table_names
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 2
# 
# 0으로 설정하면 테이블 이름이 지정된대로 저장되고 비교는 대소 문자를 구분합니다.
# 1로 설정하면 테이블 이름이 디스크에서 소문자로 저장되며 비교는 대소 문자를 구분하지 않습니다. 2로 설정하면 테이블 이름이 주어진대로 저장되지만 소문자로 비교됩니다.
# 이 옵션은 데이터베이스 이름 및 테이블 별명에도 적용됩니다. 자세한 내용은 9.2.3 절“식별자 대 / 소문자 구분”을 참조하십시오.
# 
# Windows에서 기본값은 1입니다. macOS에서 기본값은 2입니다. Linux에서 값 2는 지원되지 않습니다. 서버는 대신 값을 0으로 설정합니다.
# 
# 데이터 디렉토리가 대소 문자를 구분하지 않는 파일 시스템 (예 : Windows 또는 macOS)에있는 시스템에서 MySQL을 실행중인 경우 lower_case_table_names를 0으로 설정하지 않아야합니다.
# tbl_name 소문자가 잘못된 tbl_name 소문자로 INSERT INTO ... SELECT ... FROM tbl_name 작업을 실행할 때 정지 상태가 될 수있는 지원되지 않는 조합입니다.
# MyISAM을 사용하면 다른 소문자를 사용하여 테이블 이름에 액세스하면 인덱스가 손상 될 수 있습니다.
# 
# 대소 문자를 구분하지 않는 파일 시스템에서 --lower_case_table_names = 0으로 서버를 시작하려고하면 오류 메시지가 인쇄되고 서버가 종료됩니다.
# 
# InnoDB 테이블을 사용하는 경우 모든 플랫폼에서이 변수를 1로 설정하여 이름을 소문자로 강제 변환해야합니다.
# 
# 이 변수의 설정은 대소 문자 구분과 관련하여 복제 필터링 옵션의 동작에 영향을줍니다. 자세한 내용은 16.2.5 절“서버가 복제 필터링 규칙을 평가하는 방법”을 참조하십시오.
#
# * Apply Option
# lower_case_table_names=0
# 
# --------------------------------------------
# 
# @ lower_case_file_system
# 
# System Variable : lower_case_file_system
# Scope : Global
# Dynamic : No
# Type : Boolean
# 
# 이 변수는 데이터 디렉토리가 있는 파일 시스템에서 파일 이름의 대소 문자 구분을 설명합니다.
# OFF는 파일 이름이 대소 문자를 구분 함을 의미하고 ON은 대소 문자를 구분하지 않음을 의미합니다.
# 이 변수는 파일 시스템 속성을 반영하고 설정하면 파일 시스템에 영향을주지 않기 때문에 읽기 전용입니다.
# 
# * Apply Option
# lower_case_file_system=<>
# 
# --------------------------------------------
# 
# @ max_allowed_packet :
# 
# Property : Value
# Command-Line Format : --max-allowed-packet=#
# System Variable : max_allowed_packet
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 4194304
# Minimum Value : 1024
# Maximum Value : 1073741824
# 하나의 패킷 또는 생성 / 중간 문자열 또는 mysql_stmt_send_long_data () C API 함수가 전송 한 매개 변수의 최대 크기입니다. 기본값은 4MB입니다.
# 
# 패킷 메시지 버퍼는 net_buffer_length 바이트로 초기화되지만 필요한 경우 max_allowed_packet 바이트까지 커질 수 있습니다. 큰 (아마도 잘못된) 패킷을 포착하기 위해이 값은 기본적으로 작습니다.
# 
# 큰 BLOB 열 또는 긴 문자열을 사용하는 경우이 값을 늘려야합니다. 사용하려는 최대 BLOB만큼 커야합니다.
# max_allowed_packet의 프로토콜 제한은 1GB입니다. 값은 1024의 배수 여야합니다. 비다 중은 가장 가까운 배수로 내림됩니다.
# 
# max_allowed_packet 변수의 값을 변경하여 메시지 버퍼 크기를 변경할 때 클라이언트 프로그램이 허용하는 경우 클라이언트 측의 버퍼 크기도 변경해야합니다.
# 클라이언트 라이브러리에 내장 된 기본 max_allowed_packet 값은 1GB이지만 개별 클라이언트 프로그램이이를 무시할 수 있습니다. 예를 들어, mysql 및 mysqldump의 기본값은 각각 16MB 및 24MB입니다.
# 또한 명령 행 또는 옵션 파일에서 max_allowed_packet을 설정하여 클라이언트 측 값을 변경할 수 있습니다.
# 
# 이 변수의 세션 값은 읽기 전용입니다. 클라이언트는 세션 값만큼 많은 바이트를 수신 할 수 있습니다. 그러나 서버는 현재 전역 max_allowed_packet 값보다 많은 바이트를 클라이언트에 보내지 않습니다.
# (클라이언트가 연결 한 후 전역 값이 변경되면 전역 값이 세션 값보다 작을 수 있습니다.)
#
# * Apply Option
# max_allowed_packet=4194304
# 
# --------------------------------------------
# 
# @ max_connect_errors :
# 
# Property : Value
# Command-Line Format : --max-connect-errors=#
# System Variable : max_connect_errors
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 100
# Minimum Value : 1
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# max_connect_errors 성공적인 연결없이 호스트의 연속 연결 요청이 중단 된 후 서버는 해당 호스트가 추가 연결을 차단합니다.
# 이전 연결이 중단 된 후 max_connect_errors 시도 미만으로 호스트의 연결이 성공적으로 설정되면 호스트의 오류 수가 0으로 지워집니다.
# 그러나 일단 호스트가 차단되면 호스트 캐시를 비우는 것이 호스트를 차단 해제하는 유일한 방법입니다. 호스트 캐시를 비우려면 FLUSH HOSTS 문,
# 성능 스키마 host_cache 테이블을 자르는 TRUNCATE TABLE 문 또는 mysqladmin flush-hosts 명령을 실행하십시오.
# 
# 호스트 캐시 작동 방법에 대한 자세한 내용은 8.12.5.2 절“DNS 조회 최적화 및 호스트 캐시”를 참조하십시오.
#
# * Apply Option
# max_connect_errors=100
# 
# --------------------------------------------
# 
# @ max_connections :
# 
# Property : Value
# Command-Line Format : --max-connections=#
# System Variable : max_connections
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 151
# Minimum Value : 1
# Maximum Value : 100000
# 허용되는 최대 동시 클라이언트 연결 수입니다. 자세한 내용은 8.12.5.1 절 "MySQL이 클라이언트 연결을 처리하는 방법" 을 참조하십시오.
#
# * Apply Option
# max_connections=151
# 
# --------------------------------------------
# 
# @ max_delayed_threads
# 
# Command-Line Format : --max-delayed-threads=#
# Deprecated : Yes
# System Variable : max_delayed_threads
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 20
# Minimum Value : 0
# Maximum Value : 16384
# 
# 이 시스템 변수는 더 이상 사용되지 않습니다 (DELAYED 삽입이 지원되지 않기 때문). 향후 릴리스에서 제거 될 예정입니다.
#
# * Apply Option
# max_delayed_threads=20
# 
# --------------------------------------------
# 
# @ max_digest_length :
# 
# Property : Value
# Command-Line Format : --max-digest-length=#
# System Variable : max_digest_length
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 1024
# Minimum Value : 0
# Maximum Value : 1048576
#
# 정규화된 명령문 다이제스트 계산을 위해 세션당 예약된 메모리의 최대 바이트 수입니다. 다이제스트 계산 중에 해당 공간이 사용되면 잘림이 발생합니다.
# 구문 분석된 명령문의 토큰이 더 이상 수집되거나 다이제스트 값으로 계산되지 않습니다. 구문 분석된 토큰의 많은 바이트 후에만 다른 명령문은 동일한 정규화된 명령문 요약을 생성하고 비교하거나 요약 통계를 위해 집계되는 경우 동일한 것으로 간주됩니다.
# 
# 경고
# max_digest_length를 0으로 설정하면 다이제스트 생성이 비활성화되고, MySQL 엔터프라이즈 방화벽과 같이 다이제스트가 필요한 서버 기능도 비활성화됩니다.
# max_digest_length 값을 줄이면 메모리 사용량이 줄어들지만 끝에만 다를 경우 더 많은 문의 다이제스트 값을 구별할 수 없게 됩니다.
# 값을 늘리면 더 긴 명령문을 구별할 수 있지만 특히 많은 수의 동시 세션이 포함된 작업 부하의 경우 메모리 사용량이 늘어납니다(서버는 세션당 max_digest_length 바이트를 할당함).
# 
# 구문 분석기는 이 시스템 변수를 계산하는 정규화된 명령문 요약의 최대 길이에 대한 제한으로 사용합니다.
# 성능 스키마는 명령문 요약을 추적하는 경우 performance_schema_max_digest_length를 사용하여 요약값의 복사본을 만듭니다.
# 시스템 변수를 저장하는 다이제스트의 최대 길이에 대한 제한으로 사용합니다.
# 따라서 performance_schema_max_digest_length가 max_digest_length보다 작으면 성능 스키마에 저장된 다이제스트 값이 원래 다이제스트 값에 비해 잘립니다.
# 
# 명령문 요약에 대한 자세한 내용은 25.10절. “성능 스키마 명령문 요약”에서 참조하십시오.
#
# * Apply Option
# max_digest_length=1024
# 
# --------------------------------------------
# 
# @ max_error_count :
# 
# Property : Value
# Command-Line Format : --max-error-count=#
# System Variable : max_error_count
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 64
# Minimum Value : 0
# Maximum Value : 65535
# SHOW ERRORS 및 SHOW WARNINGS 문으로 표시하기 위해 저장할 최대 오류, 경고 및 정보 메시지 수. 이는 진단 영역의 조건 영역 수와 동일하므로 GET DIAGNOSTICS로 검사 할 수있는 조건 수와 동일합니다.
#
# * Apply Option
# max_error_count=64
# 
# --------------------------------------------
# 
# @ max_execution_time :
# 
# Property : Value
# Command-Line Format : --max-execution-time=#
# System Variable : max_execution_time
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# SELECT 문의 실행 시간 초과 (밀리 초) 값이 0이면 시간 초과가 활성화되지 않습니다.
# 
# max_execution_time은 다음과 같이 적용됩니다.
# 
# - 글로벌 max_execution_time 값은 새 연결의 세션 값에 대한 기본값을 제공합니다.
# 세션 값은 MAX_EXECUTION_TIME (N) 옵티 마이저 힌트가 없거나 N이 0인 세션 내에서 실행 된 SELECT 실행에 적용됩니다.
# - max_execution_time은 읽기 전용 SELECT 문에 적용됩니다. 읽기 전용이 아닌 명령문은 데이터를 부작용으로 수정하는 저장 함수를 호출하는 명령문입니다.
# - 저장된 프로그램의 SELECT 문에 대해 max_execution_time이 무시됩니다.
#
# * Apply Option
# join_buffemax_execution_timer_size=0
# 
# --------------------------------------------
# 
# @ max_length_for_sort_data :
# 
# Property : Value
# Command-Line Format : --max-length-for-sort-data=#
# System Variable : max_length_for_sort_data
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 1024
# Minimum Value : 4
# Maximum Value : 8388608
# 
# 사용할 파일 정렬 알고리즘을 결정하는 인덱스 값 크기의 컷오프입니다. 8.2.1.14 절“ORDER BY 최적화”를 참조하십시오.
#
# * Apply Option
# max_length_for_sort_data=1024
# 
# --------------------------------------------
# 
# 
# @ max_insert_delayed_threads
# 
# Deprecated : Yes
# System Variable : max_insert_delayed_threads
# Scope ; Global, Session
# Dynamic : Yes
# Type : Integer
#
# 이 변수는 max_delayed_threads의 동의어입니다.
# 
# 이 시스템 변수는 더 이상 사용되지 않습니다 (DELAYED 삽입이 지원되지 않기 때문). 향후 릴리스에서 제거 될 예정입니다.
#
# * Apply Option
# max_insert_delayed_threads=<>
# 
# --------------------------------------------
# 
# @ max_join_size
# 
# Command-Line Format : --max-join-size=#
# System Variable : max_join_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 18446744073709551615
# Minimum Value : 1
# Maximum Value : 18446744073709551615
# 
# max_join_size 행 (단일 테이블 명령문의 경우) 또는 행 조합 (다중 테이블 명령문의 경우) 이상을 검사해야하거나
# max_join_size 디스크 탐색보다 더 많이 수행 할 가능성이있는 명령문은 허용하지 마십시오.
# 이 값을 설정하면 키가 제대로 사용되지 않고 시간이 오래 걸리는 명령문을 포착 할 수 있습니다.
# 사용자가 WHERE 절이 없거나 시간이 오래 걸리거나 수백만 개의 행을 반환하는 조인을 수행하는 경향이있는 경우 설정하십시오.
# 자세한 내용은 안전 업데이트 모드 (--safe-updates) 사용을 참조하십시오.
# 
# 이 변수를 DEFAULT 이외의 값으로 설정하면 sql_big_selects 값이 0으로 재설정됩니다.
# sql_big_selects 값을 다시 설정하면 max_join_size 변수가 무시됩니다.
# 
# 쿼리 결과가 쿼리 캐시에있는 경우 결과가 이전에 계산되어 서버가 클라이언트에 전송하는 데 부담을주지 않으므로 결과 크기 확인이 수행되지 않습니다.
#
# * Apply Option
# max_join_size=18446744073709551615
# 
# --------------------------------------------
# 
# @ max_prepared_stmt_count :
# 
# Property : Value
# Command-Line Format : --max-prepared-stmt-count=#
# System Variable : max_prepared_stmt_count
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 16382
# Minimum Value : 0
# Maximum Value : 1048576
# 이 변수는 서버에서 준비된 명령문의 총 수를 제한합니다. 서버는 많은 수의 명령문을 준비하여 메모리 부족 서버를 실행하여 서비스 거부 공격이 발생할 수있는 환경에서 사용할 수 있습니다.
# 값이 현재 준비된 명령문 수보다 낮게 설정되면 기존 명령문은 영향을받지 않고 사용할 수 있지만 현재 수가 한계 아래로 떨어질 때까지 새 명령문을 준비 할 수 없습니다.
# 값을 0으로 설정하면 준비된 명령문이 비활성화됩니다.
#
# * Apply Option
# max_prepared_stmt_count=16382
# 
# --------------------------------------------
# 
# @ max_seeks_for_key
# 
# Command-Line Format : --max-seeks-for-key=#
# System Variable : max_seeks_for_key
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value (Windows) : 4294967295
# Default Value (Other, 64-bit platforms) : 18446744073709551615
# Default Value (Other, 32-bit platforms) : 4294967295
# Minimum Value : 1
# Maximum Value (Windows) : 4294967295
# Maximum Value (Other, 64-bit platforms) : 18446744073709551615
# Maximum Value (Other, 32-bit platforms) : 4294967295
# 
# Limit the assumed maximum number of seeks when looking up rows based on a key. The MySQL optimizer assumes that no more than this number of key seeks are required when searching for matching rows in a table by scanning an index, regardless of the actual cardinality of the index (see Section 13.7.5.22, “SHOW INDEX Statement”). By setting this to a low value (say, 100), you can force MySQL to prefer indexes instead of table scans.
# 
# 키를 기반으로 행을 찾을 때 가정되는 최대 탐색 수를 제한하십시오.
# MySQL 옵티마이 저는 인덱스의 실제 카디널리티에 관계없이 인덱스를 스캔하여 테이블에서 일치하는 행을 검색할 때
# 이 키 검색 횟수 이상이 필요하지 않다고 가정합니다 (섹션 13.7.5.22,“SHOW INDEX 문”참조).
# 이것을 낮은 값 (예 : 100)으로 설정하면 MySQL이 테이블 스캔 대신 인덱스를 선호하도록 강제 할 수 있습니다.
#
# * Apply Option
# max_seeks_for_key=4294967295
# 
# --------------------------------------------
# 
# @ max_sort_length :
# 
# Property : Value
# Command-Line Format : --max-sort-length=#
# System Variable : max_sort_length
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 1024
# Minimum Value : 4
# Maximum Value : 8388608
# 
# 데이터 값을 정렬 할 때 사용할 바이트 수입니다. 서버는 각 값의 첫 번째 max_sort_length 바이트 만 사용하고 나머지는 무시합니다.
# 결과적으로, 첫 번째 max_sort_length 바이트 이후에만 다른 값은 GROUP BY, ORDER BY 및 DISTINCT 조작에서 동일한 것으로 비교됩니다.
# 
# max_sort_length의 값을 늘리려면 sort_buffer_size의 값을 늘려야 할 수도 있습니다. 자세한 내용은 8.2.1.14 절“ORDER BY 최적화”를 참조하십시오.
#
# * Apply Option
# max_sort_length=1024
# 
# --------------------------------------------
# 
# @ max_sp_recursion_depth
# 
# Command-Line Format : --max-sp-recursion-depth[=#]
# System Variable : max_sp_recursion_depth
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Maximum Value : 255
# 
# 지정된 저장 프로 시저가 재귀적으로 호출될 수 있는 횟수입니다. 이 옵션의 기본값은 0이며 저장 프로 시저에서 재귀를 완전히 비활성화합니다.
# 최대 값은 255입니다.
# 
# 저장 프로 시저 재귀는 스레드 스택 공간에 대한 요구를 증가시킵니다.
# max_sp_recursion_depth 값을 늘리면 서버 시작시 thread_stack 값을 늘려 스레드 스택 크기를 늘려야 할 수 있습니다.
#
# * Apply Option
# max_sp_recursion_depth=0
# 
# --------------------------------------------
# 
# @ max_tmp_tables
# 
# 이 변수는 사용되지 않습니다. 더 이상 사용되지 않으며 MySQL 8.0에서 제거되었습니다.
#
# * Apply Option
# max_tmp_tables=<>
# 
# --------------------------------------------
# 
# @ max_user_connections :
# 
# Property : Value
# Command-Line Format : --max-user-connections=#
# System Variable : max_user_connections
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value : 4294967295
#
# 지정된 MySQL 사용자 계정에 허용되는 최대 동시 연결 수 값 0 (기본값)은 "제한 없음"을 의미합니다.
# 이 변수에는 서버 시작 또는 런타임시 설정할 수있는 전역 값이 있습니다. 또한 현재 세션과 연결된 계정에 적용되는 유효 동시 연결 제한을 나타내는 읽기 전용 세션 값이 있습니다.
# 세션 값은 다음과 같이 초기화됩니다.
# - 사용자 계정에 MAX_USER_CONNECTIONS 리소스 제한이 0이 아닌 경우 max_user_connections 세션 값이 해당 제한으로 설정됩니다.
# - 그렇지 않으면 세션 max_user_connections 값이 글로벌 값으로 설정됩니다.
# 계정 자원 한계는 CREATE USER 또는 ALTER USER 문을 사용하여 지정됩니다. 6.2.16 절“계정 자원 제한 설정”을 참조하십시오.
#
# * Apply Option
# max_user_connections=0
# 
# --------------------------------------------
# 
# @ max_write_lock_count
# 
# Command-Line Format : --max-write-lock-count=#
# System Variable : max_write_lock_count
# Scope : Global
# Dynamic : Yes
# Type  ;Integer
# Default Value (Windows) : 4294967295
# Default Value (Other, 64-bit platforms) : 18446744073709551615
# Default Value (Other, 32-bit platforms) : 4294967295
# Minimum Value : 1
# Maximum Value (Windows) : 4294967295
# Maximum Value (Other, 64-bit platforms) : 18446744073709551615
# Maximum Value (Other, 32-bit platforms) : 4294967295
# 
# 이 많은 쓰기 잠금 후에는 보류중인 일부 읽기 잠금 요청이 그 사이에 처리되도록 허용하십시오. 쓰기 잠금 요청은 읽기 잠금 요청보다 우선 순위가 높습니다.
# 그러나 max_write_lock_count가 낮은 값 (예 : 10)으로 설정된 경우 읽기 잠금 요청이 이미 10 개의 쓰기 잠금 요청을 위해
# 전달된 경우 보류중인 쓰기 잠금 요청보다 읽기 잠금 요청이 선호 될 수 있습니다.
# 기본적으로 max_write_lock_count의 값이 매우 크기 때문에 일반적으로이 동작이 발생하지 않습니다.
#
# * Apply Option
# max_write_lock_count=18446744073709551615
# 
# --------------------------------------------
# 
# @ metadata_locks_cache_size
# 
# Command-Line Format : --metadata-locks-cache-size=#
# Deprecated : Yes
# System Variable : metadata_locks_cache_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 1024
# Minimum Value : 1
# Maximum Value : 1048576
# 
# The size of the metadata locks cache. The server uses this cache to avoid creation and destruction of synchronization objects. This is particularly helpful on systems where such operations are expensive, such as Windows XP.
# 
# In MySQL 5.7.4, metadata locking implementation changes make this variable unnecessary, and so it is deprecated; expect it to be removed in a future release of MySQL.
# 
# 메타 데이터 잠금 캐시의 크기입니다. 서버는이 캐시를 사용하여 동기화 개체의 생성 및 삭제를 방지합니다.
# 이는 Windows XP와 같이 이러한 작업에 비용이 많이 드는 시스템에서 특히 유용합니다.
# 
# MySQL 5.7.4에서 메타 데이터 잠금 구현 변경으로 인해이 변수가 불필요하므로 더 이상 사용되지 않습니다.
# MySQL의 향후 릴리스에서 제거 될 것으로 예상됩니다.
# 
# * Apply Option
# metadata_locks_cache_size=1024
#
# --------------------------------------------
# 
# @ metadata_locks_hash_instances
# 
# Command-Line Format : --metadata-locks-hash-instances=#
# Deprecated : Yes
# System Variable : metadata_locks_hash_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 8
# Minimum Value : 1
# Maximum Value ; 1024
# 
# 메타 데이터 잠금 집합을 별도의 해시로 분할하여 서로 다른 개체에 액세스하는 연결이 서로 다른 잠금 해시를 사용하고 경합을 줄일 수 있습니다.
# metadata_locks_hash_instances 시스템 변수는 해시 수를 지정합니다 (기본값 8).
# 
# MySQL 5.7.4에서 메타 데이터 잠금 구현 변경으로 인해이 변수가 불필요하므로 더 이상 사용되지 않습니다.
# MySQL의 향후 릴리스에서 제거 될 것으로 예상됩니다.
# 
# * Apply Option
# metadata_locks_hash_instances=8
# 
# --------------------------------------------
# 
# @ multi_range_count
# 
# Command-Line Format : --multi-range-count=#
# Deprecated : Yes
# System Variable : multi_range_count
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 256
# Minimum Value : 1
# Maximum Value : 4294967295
# 
# 이 변수는 효과가 없습니다. 더 이상 사용되지 않으며 MySQL 8.0에서 제거되었습니다.
#
# * Apply Option
# multi_range_count=256
# 
# --------------------------------------------
# 
# @ net_buffer_length :
# 
# Property : Value
# Command-Line Format : --net-buffer-length=#
# System Variable : net_buffer_length
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 16384
# Minimum Value : 1024
# Maximum Value : 1048576
#
# 각 클라이언트 스레드는 연결 버퍼 및 결과 버퍼와 연결됩니다. 둘 다 net_buffer_length에 의해 주어진 크기로 시작하지만 필요에 따라 max_allowed_packet 바이트까지 동적으로 확장됩니다.
# 결과 버퍼는 각 SQL 문 후에 net_buffer_length로 축소됩니다.
# 이 변수는 일반적으로 변경되지 않아야하지만 메모리가 매우 적은 경우 클라이언트가 보낸 예상 명령문 길이로 설정할 수 있습니다. 명령문이이 길이를 초과하면 연결 버퍼가 자동으로 확대됩니다.
# net_buffer_length를 설정할 수있는 최대 값은 1MB입니다.
# 이 변수의 세션 값은 읽기 전용입니다.
#
# * Apply Option
# net_buffer_length=16384
# 
# --------------------------------------------
# 
# @ net_read_timeout :
# 
# Property : Value
# Command-Line Format : --net-read-timeout=#
# System Variable : net_read_timeout
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 30
# Minimum Value : 1
# 
# 읽기를 중단하기 전에 연결에서 더 많은 데이터를 기다리는 시간 (초)입니다. 서버가 클라이언트에서 읽을 때 net_read_timeout은 중단시기를 제어하는 ​​시간 초과 값입니다.
# 서버가 클라이언트에 쓸 때 net_write_timeout은 중단시기를 제어하는 ​​시간 초과 값입니다. slave_net_timeout도 참조하십시오.
#
# * Apply Option
# net_read_timeout=30
# 
# --------------------------------------------
# 
# @ net_retry_count :
# 
# Property : Value
# Command-Line Format : --net-retry-count=#
# System Variable : net_retry_count
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 10
# Minimum Value : 1
# Maximum Value : (64-bit platforms)- 18446744073709551615
# Maximum Value : (32-bit platforms)- 4294967295
# 통신 포트의 읽기 또는 쓰기가 중단 된 경우 포기하기 전에이 작업을 여러 번 다시 시도하십시오. 내부 인터럽트가 모든 스레드로 전송되므로이 값은 FreeBSD에서 상당히 높게 설정되어야합니다.
#
# * Apply Option
# net_retry_count=10
# 
# --------------------------------------------
# 
# @ net_write_timeout :
# 
# Property : Value
# Command-Line Format : --net-write-timeout=#
# System Variable : net_write_timeout
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 60
# Minimum Value : 1
# 쓰기를 중단하기 전에 블록이 연결에 쓰여질 때까지 대기하는 시간 (초)입니다. net_read_timeout도 참조하십시오.
#
# * Apply Option
# net_write_timeout=60
# 
# --------------------------------------------
# 
# @ new
# 
# Command-Line Format : --new[={OFF|ON}]
# System Variable : new
# Scope : Global, Session
# Dynamic : Yes
# Disabled by : skip-new
# Type : Boolean
# Default Value : OFF
# 
# 이 변수는 MySQL 4.0에서 일부 4.1 동작을 설정하는 데 사용되었으며 이전 버전과의 호환성을 위해 유지됩니다. 그 값은 항상 OFF입니다.
# 
# NDB 클러스터에서이 변수를 ON으로 설정하면 NDB 테이블에서 KEY 또는 LINEAR KEY 이외의 분할 유형을 사용할 수 있습니다.
# 이 기능은 시험용이며 프로덕션에서는 지원되지 않습니다. 추가 정보는 사용자 정의 파티셔닝 및 NDB 스토리지 엔진 (NDB 클러스터)을 참조하십시오.
#
# * Apply Option
# new=OFF
#
# --------------------------------------------
# 
# @ old
# 
# Command-Line Format : --old[={OFF|ON}]
# System Variable : old
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : OFF
# 
# old는 호환성 변수입니다. 기본적으로 비활성화되어 있지만 시작시 활성화하여 서버를 이전 버전의 동작으로 되돌릴 수 있습니다.
# 
# old가 활성화되면 인덱스 힌트의 기본 범위가 MySQL 5.1.17 이전에 사용 된 범위로 변경됩니다.
# 즉, FOR 절이없는 인덱스 힌트는 인덱스가 행 검색에 사용되는 방식에만 적용되고 ORDER BY 또는 GROUP BY 절의 확인에는 적용되지 않습니다.
# (섹션 8.9.4,“인덱스 힌트”를 참조하십시오.) 복제 설정에서 활성화 할 때주의하십시오.
# 문 기반 바이너리 로깅을 사용하면 소스와 복제본에 대해 서로 다른 모드를 사용하면 복제 오류가 발생할 수 있습니다.
#
# * Apply Option
# old=OFF
#
# --------------------------------------------
# @ old_alter_table
# 
# Command-Line Format : --old-alter-table[={OFF|ON}]
# System Variable : old_alter_table
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 이 변수가 활성화되면 서버는 ALTER TABLE 작업을 처리하는 최적화 된 방법을 사용하지 않습니다.
# 임시 테이블을 사용하여 데이터를 복사 한 다음 MySQL 5.0 및 이전 버전에서 사용 된 것처럼 임시 테이블의 이름을 원본으로 되돌립니다.
# ALTER TABLE의 작동에 대한 자세한 내용은 Section 13.1.8,“ALTER TABLE 문”을 참조하십시오.
# 
# * Apply Option
# old_alter_table=OFF
# 
# --------------------------------------------
# 
# @ old_passwords
# 
# Command-Line Format : --old-passwords=value
# Deprecated : Yes
# System Variable : old_passwords
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : 0
# Valid Values : 0, 2
# 
# 노트---
# 이 시스템 변수는 MySQL 5.7에서 더 이상 사용되지 않습니다. MySQL의 향후 릴리스에서 제거 될 것으로 예상됩니다.
--------
#
# 이 변수는 PASSWORD () 함수에서 사용하는 암호 해싱 방법을 제어합니다.
# 또한 IDENTIFIED BY 절을 사용하여 암호를 지정하는 CREATE USER 및 GRANT 문에 의해 수행되는 암호 해싱에 영향을줍니다.
# 
# 다음 표는 각 암호 해싱 방법에 대해 old_passwords의 허용 값과 해싱 방법을 사용하는 인증 플러그인을 보여줍니다.
# 
# https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html
# Password Hashing Method    |    old_passwords Value   |   Associated Authentication Plugin
# MySQL 4.1 native hashing	 |              0           |       mysql_native_password
# SHA-256 hashing            |              2           |           sha256_password
# 
# old_passwords = 2를 설정한 경우 6.4.1.5 절.“SHA-256 플러그 가능 인증”에서 sha256_password 플러그인 사용 지침을 따르십시오.
# 
# 서버는 시작시 전역 old_passwords 값을 default_authentication_plugin 시스템 변수에 표시된 인증 플러그인에 필요한 암호 해싱 방법과 일치하도록 설정합니다.
# 
# 클라이언트가 서버에 성공적으로 연결되면 서버는 계정 인증 방법에 대해 세션 old_passwords 값을 적절하게 설정합니다.
# 예를 들어 계정이 sha256_password 인증 플러그인을 사용하는 경우 서버는 old_passwords = 2를 설정합니다.
# 
# 인증 플러그인 및 해싱 형식에 대한 추가 정보는 섹션 6.2.13,“Pluggable 인증”및 섹션 6.1.2.4,“MySQL의 암호 해싱”을 참조하십시오.
# 
# * Apply Option
# old_passwords=0
# 
# --------------------------------------------
# 
# @ offline_mode :
# 
# Property : Value
# Command-Line Format : --offline-mode[={OFF|ON}]
# System Variable : offline_mode
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
#
# 서버가 "오프라인 모드"에 있는지 여부는 다음과 같은 특징이 있습니다.
# - SUPER 권한이없는 연결된 클라이언트 사용자는 다음 오류시 연결이 끊어지며 적절한 오류가 발생합니다. 연결 해제에는 실행 명령문 종료 및 잠금 해제가 포함됩니다.
# 이러한 클라이언트는 새 연결을 시작할 수 없으며 적절한 오류를 수신합니다.
# - SUPER 권한이있는 연결된 클라이언트 사용자는 연결이 끊어지지 않으며 새 연결을 시작하여 서버를 관리 할 수 ​​있습니다.
# - 복제 슬레이브 스레드는 서버에 데이터를 계속 적용 할 수 있습니다.
# 
# SUPER 권한이있는 사용자 만 오프라인 모드를 제어 할 수 있습니다. 서버를 오프라인 모드로 설정하려면 offline_mode 시스템 변수의 값을 OFF에서 ON으로 변경하십시오.
# 정상 작동을 재개하려면 offline_mode를 ON에서 OFF로 변경하십시오. 오프라인 모드에서 액세스가 거부 된 클라이언트는 ER_SERVER_OFFLINE_MODE 오류를 수신합니다.
#
# * Apply Option
# offline_mode=OFF
# 
# --------------------------------------------
# 
# @ open_files_limit :
# 
# Property : Value
# Command-Line Format : --open-files-limit=#
# System Variable : open_files_limit
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 5000, with possible adjustment
# Minimum Value : 0
# Maximum Value : platform dependent
#
# 운영 체제에서 mysqld에 사용 가능한 파일 디스크립터 수 mysqld는이 변수를 직접 설정하거나 --open-files-limit 옵션을 mysqld_safe로 설정하여
# 시작시 요청 된 값을 사용하여 setrlimit ()를 사용하여 설명자를 예약합니다.
# mysqld에서 Too many open files 오류가 발생하면 open_files_limit 값을 늘리십시오. 내부적으로이 변수의 최대 값은 부호없는 최대 정수 값이지만 실제 최대 값은 플랫폼에 따라 다릅니다.
# 
# 런타임시 open_files_limit 값은 운영 체제에서 mysqld에 실제로 허용 된 파일 디스크립터 수를 나타내며 시작시 요청 된 값과 다를 수 있습니다.
# 시작하는 동안 요청 된 파일 디스크립터 수를 할당 할 수없는 경우 mysqld는 오류 로그에 경고를 씁니다.
# 
# 유효한 open_files_limit 값은 다음 공식을 사용하여 시스템 시작시 지정된 값 (있는 경우)과 max_connections 및 table_open_cache의 값을 기반으로합니다.
# - 10 + max_connections + (table_open_cache * 2)
# - max_connections * 5
# - 한계가 양수이지만 무한대가 아닌 경우 운영 체제 한계
# - 운영 체제 한계가 무한대 인 경우 : 시작시 지정된 경우 open_files_limit 값, 그렇지 않은 경우 5000
# 
# 서버는 최대 값을 사용하여 파일 디스크립터 수를 얻으려고 시도합니다. 해당 디스크립터를 확보 할 수없는 경우, 서버는 시스템이 허용하는 수만큼을 확보하려고 시도합니다.
# 
# MySQL이 열린 파일 수를 변경할 수 없는 시스템에서는 유효 값이 0입니다.
# 
# Unix에서는 값을 ulimit -n보다 크게 설정할 수 없습니다.
#
# * Apply Option
# open_files_limit=5000
# 
# --------------------------------------------
# 
# @ plugin_dir :
# 
# Property : Value
# Command-Line Format : --plugin-dir=dir_name
# System Variable : plugin_dir
# Scope : Global
# Dynamic : No
# Type : Directory name
# Default Value : BASEDIR/lib/plugin
# 플러그인 디렉토리의 경로 이름입니다.
# 
# 플러그인 디렉토리가 서버에 의해 쓰기 가능한 경우, 사용자는 SELECT ... INTO DUMPFILE을 사용하여 디렉토리의 파일에 실행 가능 코드를 쓸 수 있습니다.
# 이는 plugin_dir을 서버로만 읽도록하거나 secure_file_priv를 SELECT 쓰기가 안전하게 수행 될 수있는 디렉토리로 설정하여 방지 할 수 있습니다.
#
# * Apply Option
# plugin_dir=BASEDIR/lib/plugin
# 
# --------------------------------------------
#
# @ port
# 
# Command-Line Format : --port=port_num
# System Variable ; port
# Scope : Global
# Dynamic : No
# Type	Integer
# Default Value : 3306
# Minimum Value : 0
# Maximum Value : 65535
# 
# 서버가 TCP / IP 연결을 인식하는 포트 번호입니다. 이 변수는 --port 옵션으로 설정할 수 있습니다.
# 
# * Apply Option
# port=3306
# 
# --------------------------------------------
# 
# @ preload_buffer_size :
# 
# Property : Value
# Command-Line Format : --preload-buffer-size=#
# System Variable : preload_buffer_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 32768
# Minimum Value : 1024
# Maximum Value : 1073741824
# 
# 인덱스를 사전로드 할 때 할당되는 버퍼의 크기입니다.
#
# * Apply Option
# preload_buffer_size=32768
# 
# --------------------------------------------
# 
# @ profiling
# 
# 0 또는 OFF (기본값)로 설정하면 문 프로파일 링이 비활성화됩니다.
# 1 또는 ON으로 설정하면 명령문 프로파일 링이 활성화되고 SHOW PROFILE 및 SHOW PROFILES 명령문은 프로파일 링 정보에 대한 액세스를 제공합니다.
# 섹션 13.7.5.31,“SHOW PROFILES 성명서”를 참조하십시오.
# 
# 이 변수는 더 이상 사용되지 않습니다. MySQL의 향후 릴리스에서 제거 될 것으로 예상됩니다.
# 
# * Apply Option
# profiling=<>
# 
# --------------------------------------------
# 
# @ profiling_history_size
# 
# 프로파일링이 활성화 된 경우 프로파일링 정보를 유지할 명령문 수입니다. 기본값은 15입니다. 최대 값은 100입니다.
# 값을 0으로 설정하면 프로파일 링이 효과적으로 비활성화됩니다. 섹션 13.7.5.31,“SHOW PROFILES 성명서”를 참조하십시오.
# 
# 이 변수는 더 이상 사용되지 않습니다. MySQL의 향후 릴리스에서 제거 될 것으로 예상됩니다.
# 
# * Apply Option
# profiling_history_size=<>
# 
# --------------------------------------------
# 
# @ protocol_version
# 
# System Variable	protocol_version
# Scope	Global
# Dynamic	No
# Type	Integer
# 
# MySQL 서버에서 사용하는 클라이언트 / 서버 프로토콜의 버전입니다.
# 
# * Apply Option
# protocol_version=<>
# 
# --------------------------------------------
# 
# @ range_alloc_block_size :
# 
# Property : Value
# Command-Line Format : --range-alloc-block-size=#
# System Variable : range_alloc_block_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 4096
# Minimum Value : 4096
# Maximum Value : (64-bit platforms) - 18446744073709547520
# Maximum Value : 4294967295
# Block Size	1024
# 
# 범위 최적화를 수행 할 때 할당되는 블록의 크기입니다.
#
# * Apply Option
# range_alloc_block_size=4096
# 
# --------------------------------------------
# 
# @ range_optimizer_max_mem_size :
# 
# Property : Value
# Command-Line Format : --range-optimizer-max-mem-size=#
# System Variable : range_optimizer_max_mem_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : (≥ 5.7.12) - 8388608
# Default Value : (≤ 5.7.11) - 1536000
# Minimum Value : 0
# Maximum Value : 18446744073709551615
# 
# 범위 최적화 프로그램의 메모리 소비 한도. 값이 0이면 "제한 없음"을 의미합니다.
# 옵티마이 저가 고려한 실행 계획이 범위 액세스 방법을 사용하지만 옵티마이 저는이 방법에 필요한 메모리 양이 한계를 초과 할 것으로 예상하면 계획을 포기하고 다른 계획을 고려합니다.
# 자세한 내용은 범위 최적화를위한 메모리 사용 제한을 참조하십시오.
#
# * Apply Option
# range_optimizer_max_mem_size=1536000
# 
# --------------------------------------------
# 
# @ rbr_exec_mode :
# 
# Property : Value
# System Variable : rbr_exec_mode
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : STRICT
# Valid Values  : IDEMPOTENT, STRICT
# 
# mysqlbinlog에 의한 내부 용. 이 변수는 서버를 IDEMPOTENT 모드와 STRICT 모드 사이에서 전환합니다.
# IDEMPOTENT 모드는 mysqlbinlog에 의해 생성 된 BINLOG 문에서 중복 키 및 키가없는 오류를 억제합니다.
# 이 모드는 기존 데이터와 충돌을 일으키는 서버에서 행 기반 이진 로그를 재생할 때 유용합니다. mysqlbinlog는 다음을 출력에 써서 --idempotent 옵션을 지정할 때이 모드를 설정합니다.
# 
# SET SESSION RBR_EXEC_MODE=IDEMPOTENT;
#
# * Apply Option
# rbr_exec_mode=STRICT
# 
# --------------------------------------------
# 
# @ require_secure_transport :
# 
# Property : Value
# Command-Line Format : --require-secure-transport[={OFF|ON}]
# System Variable : require_secure_transport
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 서버에 대한 클라이언트 연결이 특정 형태의 보안 전송을 사용해야하는지 여부 이 변수를 사용하면 서버는 SSL을 사용하는 TCP/IP 연결 또는 소켓 파일(Unix)
# 또는 공유 메모리 (Windows)를 사용하는 연결 만 허용합니다.
# 서버는 비보안 연결 시도를 거부하며 ER_SECURE_TRANSPORT_REQUIRED 오류로 실패합니다.
# 
# 이 기능은 계정 별 SSL 요구 사항을 보완하며 우선 순위가 높습니다.
# 예를 들어, 계정이 REQUIRE SSL로 정의 된 경우 require_secure_transport를 활성화해도 계정을 사용하여 Unix 소켓 파일을 사용하여 연결할 수 없습니다.
# 
# 서버에 사용 가능한 보안 전송이 없을 수 있습니다. 예를 들어, Windows의 서버는 SSL 인증서 또는 키 파일을 지정하지 않고
# shared_memory 시스템 변수를 사용하지 않고 시작한 경우 보안 전송을 지원하지 않습니다.
# 이러한 조건에서 시작시 require_secure_transport를 사용 가능하게하면 서버가 오류 로그에 메시지를 작성하고 종료합니다.
# 런타임시 변수를 활성화하려고하면 ER_NO_SECURE_TRANSPORTS_CONFIGURED 오류와 함께 실패합니다.
# 
# 암호화 된 연결을 필수로 하는 구성을 참조하십시오.
#
# * Apply Option
# require_secure_transport=OFF
# 
# --------------------------------------------
# 
# @ secure_auth
# 
# Command-Line Format : --secure-auth[={OFF|ON}]
# Deprecated : Yes
# System Variable : secure_auth
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# Valid Values : ON
# 
# 이 변수가 활성화되면 서버는 이전 (4.1 이전) 형식으로 저장된 암호가있는 계정을 사용하려는 클라이언트의 연결을 차단합니다.
# 이 변수를 활성화하여 이전 형식을 사용하는 모든 암호 사용 (따라서 네트워크를 통한 안전하지 않은 통신)을 방지합니다.
# 
# 이 변수는 더 이상 사용되지 않습니다. MySQL의 향후 릴리스에서 제거 될 것으로 예상됩니다.
# 항상 활성화되어 있으며 비활성화하려고하면 오류가 발생합니다.
# 
# 이 변수가 활성화되고 권한 테이블이 4.1 이전 형식 인 경우 서버 시작이 오류와 함께 실패합니다.
# 6.4.1.3 절.“4.1 이전 암호 해싱 및 mysql_old_password 플러그인에서 마이그레이션”을 참조하십시오.
# 
# 노트
# 4.1 이전 해싱 방법을 사용하는 암호는 기본 암호 해싱 방법을 사용하는 암호보다 덜 안전하므로 피해야합니다.
# 4.1 이전 비밀번호는 더 이상 사용되지 않으며 MySQL 5.7.5에서 지원이 제거되었습니다.
# 계정 업그레이드 지침은 6.4.1.3 절.“4.1 이전 암호 해싱 및 mysql_old_password 플러그인에서 마이그레이션”을 참조하십시오.
# 
# * Apply Option
# secure_auth=ON
# 
# --------------------------------------------
# 
# @ secure_file_priv :
# 
# Property : Value
# Command-Line Format : --secure-file-priv=dir_name
# System Variable : secure_file_priv
# Scope : Global
# Dynamic : No
# Type : String
# Default Value : platform specific
# Valid Values  : empty string, dirname, NULL
# 
# 이 변수는 LOAD DATA 및 SELECT ... INTO OUTFILE 문 및 LOAD_FILE () 함수에 의해 수행되는 것과 같은 데이터 가져 오기 및 내보내기 조작의 영향을 제한하는 데 사용됩니다.
# 이 작업은 FILE 권한이있는 사용자에게만 허용됩니다.
# 
# secure_file_priv는 다음과 같이 설정 될 수 있습니다.
# 
# - 비어 있으면 변수가 적용되지 않습니다. 이것은 안전한 설정이 아닙니다.
# - 디렉토리 이름으로 설정된 경우, 서버는 가져 오기 및 내보내기 조작이 해당 디렉토리의 파일에 대해서만 작동하도록 제한합니다. 디렉토리가 존재해야합니다. 서버는 서버를 만들지 않습니다.
# - NULL로 설정하면 서버가 가져 오기 및 내보내기 작업을 비활성화합니다.
#
# * Apply Option
# secure_file_priv=platform specific
# 
# --------------------------------------------
# 
# @ server_id_bits
# 
# Command-Line Format : --server-id-bits=#
# System Variable : server_id_bits
# Scope : Global
# Dynamic : No
# Type ; Integer
# Default Value : 32
# Minimum Value ; 7
# Maximum Value : 32
# 
# 이 변수는 실제로 서버를 식별하는 32 비트 server_id 내의 최하위 비트 수를 나타냅니다.
# 서버가 실제로 32 비트 미만으로 식별됨을 나타내면 나머지 비트 중 일부를 OperationOptions 구조의 AnyValue 내에서
# NDB API의 이벤트 API를 사용하여 애플리케이션에서 생성 한 사용자 데이터를 저장하는 등 다른 용도로 사용할 수 있습니다 ( NDB 클러스터는 AnyValue를 사용하여 서버 ID를 저장합니다).
# 
# 복제 루프 감지와 같은 목적으로 server_id에서 유효 서버 ID를 추출 할 때 서버는 나머지 비트를 무시합니다.
# server_id_bits 변수는 서버 ID를 기반으로 이벤트를 무시할지 여부를 결정할 때 I/O 및 SQL 스레드에서 server_id의 관련없는 비트를 마스킹하는 데 사용됩니다.
# 
# 이 데이터는 자체 server_id_bits 변수가 32 (기본값)로 설정된 상태로 실행되는 경우 mysqlbinlog에 의해 바이너리 로그에서 읽을 수 있습니다.
# 
# server_id의 값이 2보다 크거나 같은 경우 server_id_bits의 제곱; 그렇지 않으면 mysqld가 시작을 거부합니다.
# 
# 이 시스템 변수는 NDB 클러스터에서만 지원됩니다. 표준 MySQL 5.7 서버에서는 지원되지 않습니다.
#
# * Apply Option
# server_id_bits=32
# 
# --------------------------------------------
# 
# @ sha256_password_private_key_path
# 
# Command-Line Format : --sha256-password-private-key-path=file_name
# System Variable : sha256_password_private_key_path
# Scope : Global
# Dynamic : No
# Type : File name
# Default Value : private_key.pem
# 
# 이 변수는 MySQL이 OpenSSL을 사용하여 컴파일 된 경우 사용할 수 있습니다 (섹션 6.3.4,“SSL 라이브러리 종속 기능”참조).
# 해당 값은 sha256_password 인증 플러그인에 대한 RSA 개인 키 파일의 경로 이름입니다.
# 파일 이름이 상대 경로로 지정되면 서버 데이터 디렉토리를 기준으로 해석됩니다. 파일은 PEM 형식이어야합니다.
# 
# 중대한
# 이 파일은 개인 키를 저장하기 때문에 MySQL 서버 만 읽을 수 있도록 액세스 모드를 제한해야합니다.
# 
# sha256_password에 대한 자세한 내용은 6.4.1.5 절.“SHA-256 플러그 가능 인증”을 참조하십시오.
# 
# * Apply Option
# sha256_password_private_key_path=private_key.pem
# 
# --------------------------------------------
# 
# @ sha256_password_proxy_users
# 
# Command-Line Format : --sha256-password-proxy-users[={OFF|ON}]
# System Variable : sha256_password_proxy_users
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 이 변수는 sha256_password 내장 인증 플러그인이 프록시 사용자를 지원하는지 여부를 제어합니다.
# check_proxy_users 시스템 변수가 활성화되어 있지 않으면 효과가 없습니다. 사용자 프록시에 대한 정보는 6.2.14 절.“프록시 사용자”를 참조하십시오.
# 
# * Apply Option
# sha256_password_proxy_users=OFF
# 
# --------------------------------------------
# 
# @ sha256_password_public_key_path
# 
# Command-Line Format : --sha256-password-public-key-path=file_name
# System Variable : sha256_password_public_key_path
# Scope ; Global
# Dynamic : No
# Type : File name
# Default Value : public_key.pem
# 
# 이 변수는 MySQL이 OpenSSL을 사용하여 컴파일 된 경우 사용할 수 있습니다 (섹션 6.3.4,“SSL 라이브러리 종속 기능”참조).
# 해당 값은 sha256_password 인증 플러그인에 대한 RSA 공개 키 파일의 경로 이름입니다.
# 파일 이름이 상대 경로로 지정되면 서버 데이터 디렉토리를 기준으로 해석됩니다. 파일은 PEM 형식이어야합니다.
# 이 파일은 공개 키를 저장하기 때문에 사본을 클라이언트 사용자에게 자유롭게 배포 할 수 있습니다.
# (RSA 암호 암호화를 사용하여 서버에 연결할 때 공개 키를 명시 적으로 지정하는 클라이언트는 서버에서 사용하는 것과 동일한 공개 키를 사용해야합니다.)
# 
# 클라이언트가 RSA 공개 키를 지정하는 방법에 대한 정보를 포함하여 sha256_password에 대한 정보는 Section 6.4.1.5,“SHA-256 Pluggable Authentication”을 참조하십시오.
# 
# * Apply Option
# sha256_password_public_key_path=public_key.pem
# 
# --------------------------------------------
# 
# @ show_create_table_verbosity :
# 
# Property : Value
# Command-Line Format : --show-create-table-verbosity[={OFF|ON}]
# Introduced	5.7.22
# System Variable : show_create_table_verbosity
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 행 형식이 기본 형식인 경우 SHOW CREATE TABLE은 일반적으로 ROW_FORMAT 테이블 옵션을 표시하지 않습니다. 이 변수를 활성화하면 기본 형식인지 여부에 관계없이 SHOW CREATE TABLE에 ROW_FORMAT이 표시됩니다.
#
# * Apply Option
# show_create_table_verbosity=OFF
# 
# --------------------------------------------
# 
# @ show_old_temporals
# 
# Command-Line Format : --show-old-temporals[={OFF|ON}]
# Deprecated : Yes
# System Variable : show_old_temporals
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# SHOW CREATE TABLE 출력에 5.6.4 이전 형식(분수 초 정밀도를 지원하지 않는 TIME, DATETIME 및 TIMESTAMP 열)에 있는것으로 확인된 임시 열에 플래그를
# 지정하는 주석이 포함되는지 여부. 이 변수는 기본적으로 비활성화되어 있습니다. 활성화 된 경우 SHOW CREATE TABLE 출력은 다음과 같습니다.
# 
# CREATE TABLE `mytbl` (
#   `ts` timestamp /* 5.5 binary format */ NOT NULL DEFAULT CURRENT_TIMESTAMP,
#   `dt` datetime /* 5.5 binary format */ DEFAULT NULL,
#   `t` time /* 5.5 binary format */ DEFAULT NULL
# ) DEFAULT CHARSET=latin1
# 
# INFORMATION_SCHEMA.COLUMNS 테이블의 COLUMN_TYPE 열에 대한 출력도 비슷하게 영향을받습니다.
# 
# 이 변수는 더 이상 사용되지 않습니다. MySQL의 향후 릴리스에서 제거 될 것으로 예상됩니다.
#
# * Apply Option
# show_old_temporals=OFF
# 
# --------------------------------------------
# 
# @ skip_external_locking
# 
# Command-Line Format : --skip-external-locking[={OFF|ON}]
# System Variable : skip_external_locking
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : ON
# 
# mysqld가 외부 잠금 (시스템 잠금)을 사용하면 OFF이고, 외부 잠금이 비활성화되어 있으면 ON입니다. 이는 MyISAM 테이블 액세스에만 영향을줍니다.
# 
# 이 변수는 --external-locking 또는 --skip-external-locking 옵션으로 설정됩니다. 외부 잠금은 기본적으로 비활성화되어 있습니다.
# 
# 외부 잠금은 MyISAM 테이블 액세스에만 영향을줍니다. 사용할 수있는 조건과 사용할 수없는 조건을 포함한 자세한 내용은 섹션 8.11.5,“외부 잠금”을 참조하십시오.
#
# * Apply Option
# skip_external_locking=ON
# 
# --------------------------------------------
# 
# @ skip_name_resolve :
# 
# Property : Value
# Command-Line Format : --skip-name-resolve[={OFF|ON}]
# System Variable : skip_name_resolve
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : OFF
# 
# 클라이언트 연결을 확인할 때 호스트 이름을 확인할지 여부입니다. 이 변수가 OFF이면 클라이언트 연결을 확인할 때 mysqld가 호스트 이름을 확인합니다. ON이면 mysqld는 IP 번호 만 사용합니다.
# 이 경우 권한 부여 테이블의 모든 호스트 열 값은 IP 주소 여야합니다. 8.12.5.2 절“DNS 조회 최적화 및 호스트 캐시”를 참조하십시오.
# 
# 시스템의 네트워크 구성 및 계정의 호스트 값에 따라 --host = 127.0.0.1 또는 --host = :: 1과 같은 명시적인 --host 옵션을 사용하여 클라이언트를 연결해야 할 수도 있습니다.
# 
# 호스트 127.0.0.1에 대한 연결 시도는 일반적으로 localhost 계정으로 해결됩니다. 그러나 skip_name_resolve를 사용하여 서버를 실행하면 실패합니다.
# 그렇게 하려면 연결을 수락 할 수있는 계정이 있는지 확인하십시오. 예를 들어 --host = 127.0.0.1 또는 --host = :: 1을 사용하여 루트로 연결하려면 다음 계정을 만드십시오.
# CREATE USER 'root'@'127.0.0.1' IDENTIFIED BY 'root-password';
# CREATE USER 'root'@'::1' IDENTIFIED BY 'root-password';
#
# * Apply Option
# skip_name_resolve=OFF
# 
# --------------------------------------------
# 
# @ skip_networking :
# 
# Property : Value
# Command-Line Format : --skip-networking[={OFF|ON}]
# System Variable : skip_networking
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : OFF
# 
# 이 변수는 서버가 TCP / IP 연결을 허용하는지 여부를 제어합니다. 기본적으로 비활성화되어 있습니다 (TCP 연결 허용).
# 활성화 된 경우 서버는 로컬 (TCP / IP가 아닌) 연결 만 허용하며 mysqld와의 모든 상호 작용은 명명 된 파이프 또는 공유 메모리 (Windows) 또는 Unix 소켓 파일 (Unix)을 사용하여 이루어져야합니다.
# 이 옵션은 로컬 클라이언트 만 허용되는 시스템에 권장됩니다. 8.12.5.2 절“DNS 조회 최적화 및 호스트 캐시”를 참조하십시오.
#
# * Apply Option
# skip_networking=OFF
# 
# --------------------------------------------
# 
# @ skip_show_database :
# 
# Property : Value
# Command-Line Format : --skip-show-database
# System Variable : skip_show_database
# Scope : Global
# Dynamic : No
# 
# 이것은 사람들이 SHOW DATABASES 권한이 없는 경우 SHOW DATABASES 문을 사용하지 못하게합니다. 사용자가 다른 사용자에게 속한 데이터베이스를 볼 수 있다는 우려가있는 경우 보안을 향상시킬 수 있습니다.
# 그 효과는 SHOW DATABASES 권한에 따라 다릅니다. 변수 값이 ON이면 SHOW DATABASES 권한이있는 사용자에게만 SHOW DATABASES 문이 허용되며 명령문은 모든 데이터베이스 이름을 표시합니다.
# 값이 OFF이면 SHOW DATABASES가 모든 사용자에게 허용되지만 SHOW DATABASES 또는 기타 권한이있는 데이터베이스의 이름만 표시합니다.
#
# * Apply Option
# skip_show_database=none
# 
# --------------------------------------------
# 
# @ sort_buffer_size :
# 
# Property : Value
# Command-Line Format : --sort-buffer-size=#
# System Variable : sort_buffer_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 262144
# Minimum Value : 32768
# Maximum Value : (Other, 64-bit platforms) - 18446744073709551615
# Maximum Value : (Other, 32-bit platforms) - 4294967295
# Maximum Value : (Windows) - 4294967295
# 
# 
# 정렬을 수행해야하는 각 세션은이 크기의 버퍼를 할당합니다. sort_buffer_size는 스토리지 엔진에만 국한되지 않으며 일반적인 최적화 방법으로 적용됩니다.
# 최소한 sort_buffer_size 값은 정렬 버퍼에서 15 개의 튜플을 수용 할 수있을만큼 커야합니다. 
# 또한 max_sort_length의 값을 늘리려면 sort_buffer_size의 값을 늘려야 할 수 있습니다. 자세한 내용은 8.2.1.14 절“ORDER BY 최적화”를 참조하십시오.
# 
# SHOW GLOBAL STATUS 출력에 초당 많은 Sort_merge_passes가 표시되면 sort_buffer_size 값을 늘려서 쿼리 최적화나 향상된 인덱싱으로 개선할 수 없는
# ORDER BY 또는 GROUP BY 작업의 속도를 높일 수 있습니다.
# 
# 옵티마이 저는 필요한 공간을 계산하려고 시도하지만 한계까지 더 많이 할당 할 수 있습니다. 전역 적으로 필요한 것보다 크게 설정하면 정렬하는 대부분의 쿼리 속도가 느려집니다.
# 세션 설정으로 늘리고 더 큰 크기가 필요한 세션에 대해서만 늘리는 것이 가장 좋습니다. Linux에는 256KB 및 2MB의 임계 값이 있으며,
# 이 값이 클수록 메모리 할당 속도가 크게 느려질 수 있으므로 해당 값 중 하나보다 낮게 유지해야합니다. 워크로드에 가장 적합한 가치를 찾기 위해 실험하십시오.
# B.4.3.5 절.“MySQL이 임시 파일을 저장하는 곳”을 참조하십시오.
# 
# sort_buffer_size의 최대 허용 설정은 4GB입니다. 64 비트 플랫폼에는 더 큰 값이 허용됩니다 (64 비트 Windows는 큰 값이 경고와 함께 4GB로 잘립니다).
#
# * Apply Option
# sort_buffer_size=262144
# 
# --------------------------------------------
# 
# @ sql_auto_is_null
# 
# System Variable : sql_auto_is_null
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 이 변수가 활성화 된 경우 자동 생성 된 AUTO_INCREMENT 값을 성공적으로 삽입하는 문 다음에 다음 형식의 문을 실행하여 해당 값을 찾을 수 있습니다.
# 
# SELECT * FROM tbl_name WHERE auto_col IS NULL
# 
# 문이 행을 반환하면 반환 된 값은 LAST_INSERT_ID() 함수를 호출 한 것과 같습니다.
# 다중 행 삽입 후 반환 값을 포함한 자세한 내용은 Section 12.16,“정보 함수”를 참조하십시오.
# AUTO_INCREMENT 값이 성공적으로 삽입되지 않은 경우 SELECT 문은 행을 반환하지 않습니다.
# 
# IS NULL 비교를 사용하여 AUTO_INCREMENT 값을 검색하는 동작은 Access와 같은 일부 ODBC 프로그램에서 사용됩니다.
# 자동 증가 값 얻기를 참조하십시오. 이 동작은 sql_auto_is_null을 OFF로 설정하여 비활성화 할 수 있습니다.
# 
# sql_auto_is_null의 기본값은 OFF입니다.
#
# * Apply Option
# sql_auto_is_null=OFF
# 
# --------------------------------------------
# 
# @ sql_big_selects
# 
# System Variable : sql_big_selects
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# OFF로 설정하면 MySQL은 실행하는 데 매우 오래 걸릴 가능성이있는 SELECT문(즉, 최적화 프로그램이 검사 된 행 수가 max_join_size 값을 초과한다고 추정하는 문)을 중단합니다.
# 이것은 바람직하지 않은 WHERE 문이 발행되었을 때 유용합니다. 새 연결의 기본값은 모든 SELECT 문을 허용하는 ON입니다.
# 
# max_join_size 시스템 변수를 DEFAULT 이외의 값으로 설정하면 sql_big_selects가 OFF로 설정됩니다.
#
# * Apply Option
# sql_big_selects=ON
# 
# --------------------------------------------
# 
# @ sql_buffer_result
# 
# System Variable : sql_buffer_result
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 활성화 된 경우 sql_buffer_result는 SELECT 문의 결과를 임시 테이블에 강제로 넣습니다.
# 이는 MySQL이 테이블 잠금을 조기에 해제하는 데 도움이되며 클라이언트에 결과를 보내는 데 시간이 오래 걸리는 경우에 유용 할 수 있습니다. 기본값은 OFF입니다.
#
# * Apply Option
# sql_buffer_result=OFF
# 
# --------------------------------------------
# 
# @ sql_log_off :
# 
# Property : Value
# System Variable : sql_log_off
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# Valid Values	
# OFF (enable logging)
# ON (disable logging)
# 
# 이 변수는 현재 세션에서 일반 쿼리 로그에 대한 로깅을 비활성화할지 여부를 제어합니다 (일반 쿼리 로그 자체가 활성화되어 있다고 가정).
# 기본값은 OFF입니다 (즉, 로깅 사용). 현재 세션에 대한 일반 쿼리 로깅을 비활성화하거나 활성화하려면 session sql_log_off 변수를 ON 또는 OFF로 설정하십시오.
# 이 시스템 변수의 세션 값 설정은 제한된 조작입니다. 세션 사용자에게는 제한된 세션 변수를 설정하기에 충분한 권한이 있어야합니다. 5.1.8.1 절.“시스템 변수 권한”을 참조하십시오.
#
# * Apply Option
# sql_log_off=OFF
# 
# --------------------------------------------
# 
# @ sql_mode :
# 
# Property : Value
# Command-Line Format : --sql-mode=name
# System Variable : sql_mode
# Scope : Global, Session
# Dynamic : Yes
# Type : Set
# Default Value : | ONLY_FULL_GROUP_BY STRICT_TRANS_TABLES NO_ZERO_IN_DATE NO_ZERO_DATE ERROR_FOR_DIVISION_BY_ZERO NO_AUTO_CREATE_USER NO_ENGINE_SUBSTITUTION
# Valid Values
# ALLOW_INVALID_DATES
# ANSI_QUOTES
# ERROR_FOR_DIVISION_BY_ZERO
# HIGH_NOT_PRECEDENCE
# IGNORE_SPACE
# NO_AUTO_CREATE_USER
# NO_AUTO_VALUE_ON_ZERO
# NO_BACKSLASH_ESCAPES
# NO_DIR_IN_CREATE
# NO_ENGINE_SUBSTITUTION
# NO_FIELD_OPTIONS
# NO_KEY_OPTIONS
# NO_TABLE_OPTIONS
# NO_UNSIGNED_SUBTRACTION
# NO_ZERO_DATE
# NO_ZERO_IN_DATE
# ONLY_FULL_GROUP_BY
# PAD_CHAR_TO_FULL_LENGTH
# PIPES_AS_CONCAT
# REAL_AS_FLOAT
# STRICT_ALL_TABLES
# STRICT_TRANS_TABLES
# 
# The current server SQL mode, which can be set dynamically. For details, see Section 5.1.10, “Server SQL Modes”.
# https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html
#
# * Apply Option
# sql_mode=ONLY_FULL_GROUP_BY STRICT_TRANS_TABLES NO_ZERO_IN_DATE NO_ZERO_DATE ERROR_FOR_DIVISION_BY_ZERO NO_AUTO_CREATE_USER NO_ENGINE_SUBSTITUTION
# 
# --------------------------------------------
# 
# @ stored_program_cache :
# 
# Property : Value
# Command-Line Format : --stored-program-cache=#
# System Variable : stored_program_cache
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 256
# Minimum Value : 16
# Maximum Value : 524288
# 
# 연결 당 캐시 된 저장 루틴 수에 대한 소프트 상한을 설정합니다.
# 이 변수의 값은 각각 스토어드 프로 시저 및 스토어드 함수에 대해 MySQL 서버가 유지 보수하는 두 개의 캐시 각각에 보유 된 스토어드 루틴의 수로 지정됩니다.
# 
# 저장된 루틴이 실행될 때마다 루틴의 첫 번째 또는 최상위 레벨 명령문이 구문 분석되기 전에이 캐시 크기가 점검됩니다.
# 동일한 유형의 루틴 (저장 프로 시저 또는 실행중인 저장 함수)이이 변수에 의해 지정된 한계를 초과하면 해당 캐시가 플러시되고 캐시 된 오브젝트에 대해 이전에 할당 된 메모리가 해제됩니다.
# 이를 통해 저장된 루틴간에 종속성이있는 경우에도 캐시를 안전하게 플러시 할 수 있습니다.
#
# * Apply Option
# stored_program_cache=256
# 
# --------------------------------------------
# 
# @ table_definition_cache :
# 
# Property : Value
# Command-Line Format : --table-definition-cache=#
# System Variable : table_definition_cache
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : 400
# Maximum Value : 524288
# 
# 정의 캐시에 저장할 수있는 테이블 정의 (.frm 파일의) 수입니다. 많은 수의 테이블을 사용하는 경우 테이블을 빠르게 열 수 있도록 큰 테이블 정의 캐시를 작성할 수 있습니다.
# 테이블 정의 캐시는 일반 테이블 캐시와 달리 공간을 덜 차지하고 파일 디스크립터를 사용하지 않습니다. 최소값은 400입니다. 기본값은 다음 수식을 기반으로하며 한계는 2000입니다.
# 400 + (table_open_cache / 2)
# 
# InnoDB의 경우 table_definition_cache는 InnoDB 데이터 사전 캐시에서 열린 테이블 인스턴스 수에 대한 소프트 한계로 작동합니다.
# 열린 테이블 인스턴스 수가 table_definition_cache 설정을 초과하면 LRU 메커니즘은 테이블 인스턴스를 제거하도록 표시하고 결국 데이터 사전 캐시에서 제거합니다.
# 이 제한은 다음 서버가 다시 시작될 때까지 거의 사용되지 않는 테이블 인스턴스를 캐시하는 데 상당한 양의 메모리가 사용되는 상황을 해결하는 데 도움이됩니다.
# 캐시 된 메타 데이터가있는 테이블 인스턴스의 수는 InnoDB 시스템 테이블 인스턴스와 외래 키 관계가있는 부모 및 자식 테이블 인스턴스가 LRU 목록에 배치되지 않고 메모리에서 제거되지 않으므로
# table_definition_cache에 의해 정의 된 한계보다 클 수 있습니다.
# 
# 또한 table_definition_cache는 한 번에 열 수있는 InnoDB 테이블 당 테이블 스페이스 수에 대한 소프트 제한을 정의하며 innodb_open_files에 의해 제어됩니다.
# table_definition_cache 및 innodb_open_files가 모두 설정되면 가장 높은 설정이 사용됩니다. 변수를 설정하지 않으면 기본값이 더 높은 table_definition_cache가 사용됩니다.
# 열린 테이블 스페이스 파일 핸들 수가 table_definition_cache 또는 innodb_open_files에 의해 정의 된 한계를 초과하면 LRU 메커니즘은 테이블 스페이스 파일 LRU 목록에서
# 완전히 플러시되고 현재 확장되고 있지 않은 파일을 검색합니다.
# 이 프로세스는 새 테이블 스페이스가 열릴 때마다 수행됩니다. "비활성"테이블 스페이스가없는 경우 테이블 스페이스 파일이 닫히지 않습니다.
#
# * Apply Option
# table_definition_cache=-1
# 
# --------------------------------------------
# 
# @ table_open_cache :
# 
# Property : Value
# Command-Line Format : --table-open-cache=#
# System Variable : table_open_cache
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 2000
# Minimum Value : 1
# Maximum Value : 524288
#
# 모든 스레드에 대한 열린 테이블 수입니다. 이 값을 늘리면 mysqld에 필요한 파일 디스크립터 수가 증가합니다.
# Opened_tables 상태 변수를 확인하여 테이블 캐시를 늘려야하는지 여부를 확인할 수 있습니다.
# 5.1.9 절.“서버 상태 변수”를 참조하십시오.
# Opened_tables의 값이 크고 FLUSH TABLES를 자주 사용하지 않는 경우 (모든 테이블을 닫았다가 다시 열어야 함) table_open_cache 변수의 값을 늘려야합니다.
# 테이블 캐시에 대한 자세한 내용은 8.4.3.1 절“MySQL에서 테이블을 열고 닫는 방법”을 참조하십시오.
#
# * Apply Option
# table_open_cache=2000
# 
# --------------------------------------------
# 
# @ table_open_cache_instances :
# 
# Property : Value
# Command-Line Format : --table-open-cache-instances=#
# System Variable : table_open_cache_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 16
# Minimum Value : 1
# Maximum Value : 64
#
# 열린 테이블 캐시 인스턴스 수입니다. 세션 간 경합을 줄임으로써 확장 성을 향상시키기 위해 열린 테이블 캐시를 table_open_cache/table_open_cache_instances 크기의
# 여러 작은 캐시 인스턴스로 분할할 수 있습니다.
# 세션은 DML 문에 액세스하기 위해 하나의 인스턴스 만 잠그면됩니다. 이는 인스턴스간에 캐시 액세스를 세그먼트 화하여 테이블에 액세스하는 세션이 많은 경우 캐시를 사용하는 조작의 성능을 향상시킵니다.
# (DDL 문은 여전히 ​​전체 캐시에 대한 잠금이 필요하지만 이러한 문은 DML 문보다 훨씬 덜 빈번합니다.)
# 
# 16 개 이상의 코어를 일상적으로 사용하는 시스템에서는 8 또는 16의 값이 권장됩니다.
#
# * Apply Option
# table_open_cache_instances=16
# 
# --------------------------------------------
# 
# @ thread_cache_size :
# 
# Property : Value
# Command-Line Format : --thread-cache-size=#
# System Variable : thread_cache_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : 0
# Maximum Value : 16384
#
# 재사용을 위해 서버가 캐시해야하는 스레드 수 클라이언트가 연결을 끊을 때 thread_cache_size 스레드보다 적은 수의 클라이언트 스레드가 있으면 캐시에 저장됩니다.
# 가능한 경우 캐시에서 가져온 스레드를 재사용하여 스레드 요청이 충족되며 캐시가 비어있는 경우에만 새 스레드가 작성됩니다.
# 새로운 연결이 많은 경우 성능을 향상시키기 위해이 변수를 늘릴 수 있습니다. 일반적으로 스레드 구현이 양호하면 성능이 크게 향상되지 않습니다.
# 그러나 서버에 초당 수백 개의 연결이 표시되는 경우 일반적으로 대부분의 새 연결이 캐시된 스레드를 사용하도록 thread_cache_size를 충분히 높게 설정해야합니다.
# Connections 및 Threads_created 상태 변수의 차이점을 검사하여 스레드 캐시의 효율성을 확인할 수 있습니다. 자세한 내용은 5.1.9 절.“서버 상태 변수”를 참조하십시오.
# 
# 기본값은 다음 수식을 기반으로하며 100으로 제한됩니다.
# 8 + (최대 연결 수 / 100)
# 
# 이 변수는 내장 서버 (libmysqld)에 영향을 미치지 않으며 MySQL 5.7.2부터 내장 서버에서 더 이상 볼 수 없습니다.
#
# * Apply Option
# thread_cache_size=-1
# 
# --------------------------------------------
# 
# @ thread_pool_size :
# 
# Property : Value
# Command-Line Format : --thread-pool-size=#
# System Variable : thread_pool_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 16
# Minimum Value : 1
# Maximum Value : 64
# 
# 스레드 풀의 스레드 그룹 수 스레드 풀 성능을 제어하는 ​​가장 중요한 매개 변수입니다. 동시에 실행할 수있는 명령문 수에 영향을줍니다.
# 기본값은 16이며 허용 가능한 값의 범위는 1-64입니다. 이 범위를 벗어난 값을 지정하면 스레드 풀 플러그인이로드되지 않고 서버가 오류 로그에 메시지를 씁니다.
# 
# 이 변수는 스레드 풀 플러그인이 사용 가능한 경우에만 사용 가능합니다. 5.5.3 절“MySQL Enterprise 스레드 풀”을 참조하십시오.
#
# * Apply Option
# thread_pool_size=16
# 
# --------------------------------------------
# 
# @ thread_stack :
# 
# Property : Value
# Command-Line Format : --thread-stack=#
# System Variable : thread_stack
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : (64-bit platforms)- 262144
# Default Value : (32-bit platforms) - 196608
# Minimum Value : 131072
# Maximum Value : (64-bit platforms) - 18446744073709551615
# Maximum Value : (32-bit platforms) - 4294967295
# Block Size	1024
# 
# 각 스레드의 스택 크기입니다. 기본값은 정상 작동에 충분한 크기입니다.
# 스레드 스택 크기가 너무 작 으면 서버가 처리 할 수있는 SQL 문의 복잡성, 저장 프로 시저의 재귀 깊이 및 기타 메모리 소비 작업이 제한됩니다.
#
# * Apply Option
# thread_stack=262144
# 
# --------------------------------------------
# 
# @ tmp_table_size :
# 
# Property : Value
# Command-Line Format : --tmp-table-size=#
# System Variable : tmp_table_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 16777216
# Minimum Value : 1024
# Maximum Value : 18446744073709551615
# 
# 내부 메모리 내 임시 테이블의 최대 크기입니다. 이 변수는 사용자가 만든 MEMORY 테이블에는 적용되지 않습니다.
# 
# 실제 한계는 tmp_table_size 및 max_heap_table_size 값 중 작은 값으로 결정됩니다. 메모리 내 임시 테이블이 한도를 초과하면 MySQL은 자동으로 디스크상의 임시 테이블로 변환합니다.
# internal_tmp_disk_storage_engine 옵션은 온 디스크 임시 테이블에 사용되는 스토리지 엔진을 정의합니다.
# 
# 고급 GROUP BY 쿼리를 많이 수행하고 메모리가 많은 경우 tmp_table_size (필요한 경우 max_heap_table_size)의 값을 늘리십시오.
# 
# Created_tmp_disk_tables 및 Created_tmp_tables 변수의 값을 비교하여 작성된 내부 온 디스크 임시 테이블 수와 작성된 총 내부 임시 테이블 수를 비교할 수 있습니다.
#
# * Apply Option
# tmp_table_size=16777216
# 
# --------------------------------------------
# 
# @ max_heap_table_size
# 
# Command-Line Format	--max-heap-table-size=#
# System Variable	max_heap_table_size
# Scope	Global, Session
# Dynamic	Yes
# Type	Integer
# Default Value	16777216
# Minimum Value	16384
# Maximum Value (64-bit platforms)	1844674407370954752
# Maximum Value (32-bit platforms)	4294967295
#
# 이 변수는 사용자가 생성한 MEMORY 테이블이 사용할 수 있는 최대 크기를 설정합니다. 변수 값은 MEMORY 테이블 MAX_ROWS 값을 계산하는 데 사용됩니다.
# 이 변수를 설정해도 테이블이 CREATE TABLE과 같은 명령문으로 다시 작성되거나 ALTER TABLE 또는 TRUNCATE TABLE로 변경되지 않는 한 기존 MEMORY 테이블에 영향을 미치지 않습니다.
# 서버를 다시 시작하면 기존 MEMORY 테이블의 최대 크기도 전역 max_heap_table_size 값으로 설정됩니다.
#
# 이 변수는 내부 메모리 테이블의 크기를 제한하기 위해 tmp_table_size와 함께 사용됩니다. 8.4.4 절.“MySQL에서 내부 임시 테이블 사용”을 참조하십시오.
#
# max_heap_table_size는 복제되지 않습니다.
# 자세한 내용은 Section 16.4.1.20,“Replication and MEMORY Tables”및 Section 16.4.1.37,“Replication and Variables”를 참조하십시오.
# 
# * Apply Option
# max_heap_table_size=16777216
#
# # --------------------------------------------
# 
# @ tmpdir :
# 
# Property : Value
# Command-Line Format : --tmpdir=dir_name
# System Variable : tmpdir
# Scope : Global
# Dynamic : No
# Type : Directory name
# 
# 임시 파일 작성에 사용할 디렉토리의 경로입니다. 기본 / tmp 디렉토리가 임시 테이블을 보유하기에는 너무 작은 파티션에있는 경우 유용 할 수 있습니다.
# 이 변수는 라운드 로빈 방식으로 사용되는 여러 경로 목록으로 설정할 수 있습니다. 경로는 Unix에서는 콜론 문자 (:)로, Windows에서는 세미콜론 문자 (;)로 구분해야합니다.
# 
# tmpdir은 메모리 기반 파일 시스템의 디렉토리 또는 서버 호스트가 다시 시작될 때 지워지는 디렉토리와 같은 비 영구적 위치 일 수 있습니다.
# MySQL 서버가 복제 슬레이브로 작동하고 tmpdir에 비 영구적 위치를 사용하는 경우 slave_load_tmpdir 변수를 사용하여 슬레이브에 대해 다른 임시 디렉토리를 설정하십시오.
# 복제 슬레이브의 경우 LOAD DATA 문을 복제하는데 사용된 임시 파일이이 디렉토리에 저장되므로 영구 위치를 사용하면 임시 파일이 제거된 경우
# 다시 시작한 후에도 복제를 계속할 수 있지만 영구적 인 위치에서 머신을 다시 시작해도 살아남을 수 있습니다.
# 
# 임시 파일의 저장 위치에 대한 자세한 내용은 B.4.3.5 절“MySQL이 임시 파일을 저장하는 위치”를 참조하십시오.
#
# * Apply Option
# tmpdir=directory name
# 
# --------------------------------------------
# 
# @ transaction_isolation :
# 
# Property : Value
# Command-Line Format : --transaction-isolation=name
# System Variable (≥ 5.7.20)	transaction_isolation
# Scope (≥ 5.7.20)	Global, Session
# Dynamic (≥ 5.7.20)	Yes
# Type : Enumeration
# Default Value : REPEATABLE-READ
# Valid Values  : READ-UNCOMMITTED , READ-COMMITTED , REPEATABLE-READ , SERIALIZABLE
# 
# 트랜잭션 격리 수준 기본값은 REPEATABLE-READ입니다.
# 트랜잭션 격리 수준에는 전역, 세션 및 다음 트랜잭션의 세 가지 범위가 있습니다. 이 3 가지 범위의 구현은 후술하는 바와 같이 일부 비표준 격리 레벨 할당 의미론으로 이어진다.
# 
# + 시작시 전역 트랜잭션 격리 수준을 설정하려면 --transaction-isolation server 옵션을 사용하십시오.
# 
# 런타임시, 격리 레벨은 SET 문을 사용하여 직접 설정하여 transaction_isolation 시스템 변수에 값을 지정하거나 간접적으로 SET TRANSACTION 문을 사용하여 설정할 수 있습니다.
# transaction_isolation을 공백이 포함 된 격리 수준 이름으로 직접 설정 한 경우 이름은 따옴표로 묶어야하며 공백은 대시로 대체해야합니다. 예를 들어이 SET 문을 사용하여 전역 값을 설정하십시오.
# 
# SET GLOBAL transaction_isolation = 'READ-COMMITTED';
# global transaction_isolation 값을 설정하면 모든 후속 세션에 대한 격리 수준이 설정됩니다. 기존 세션은 영향을받지 않습니다.
# 
# 세션 또는 다음 레벨 transaction_isolation 값을 설정하려면 SET 문을 사용하십시오. 대부분의 세션 시스템 변수에서이 명령문은 값을 설정하는 동등한 방법입니다.
# SET @@SESSION.var_name = value;
# SET SESSION var_name = value;
# SET var_name = value;
# SET @@var_name = value;
# 앞에서 언급했듯이 트랜잭션 격리 수준에는 전역 및 세션 범위 외에 다음 트랜잭션 범위가 있습니다.
# 다음 트랜잭션 범위를 설정하려면 세션 시스템 변수 값을 지정하기위한 SET 구문에 transaction_isolation에 대한 비표준 의미가 있습니다.
# 
# + 세션 격리 수준을 설정하려면 다음 구문 중 하나를 사용하십시오.
# SET @@SESSION.transaction_isolation = value;
# SET SESSION transaction_isolation = value;
# SET transaction_isolation = value;
# For each of those syntaxes, these semantics apply:
# 
# - 세션 내에서 수행 된 모든 후속 트랜잭션에 대한 격리 수준을 설정합니다.
# - 거래 내에서 허용되지만 현재 진행중인 거래에는 영향을 미치지 않습니다.
# - 트랜잭션 사이에서 실행되면 다음 트랜잭션 격리 레벨을 설정하는 이전 명령문을 대체합니다.
# - SET SESSION TRANSACTION ISOLATION LEVEL (SESSION 키워드 사용)에 해당합니다.
# 
# + 다음 트랜잭션 격리 레벨을 설정하려면 다음 구문을 사용하십시오.
# SET @@transaction_isolation = value;
# 
# 이 구문에는 다음과 같은 의미가 적용됩니다.
# - 세션 내에서 수행 된 다음 단일 트랜잭션에 대해서만 격리 수준을 설정합니다.
# - 후속 트랜잭션은 세션 격리 수준으로 돌아갑니다.
# - 거래 내에서 허용되지 않습니다.
# - SET TRANSACTION ISOLATION LEVEL (SESSION 키워드없이)에 해당합니다.
# 
# SET TRANSACTION 및 transaction_isolation 시스템 변수와의 관계에 대한 자세한 내용은 13.3.6 절“SET TRANSACTION 문”을 참조하십시오.
# 
# 노트
# transaction_isolation은 MySQL 5.7.20에서 tx_isolation의 별칭으로 추가되었으며, 이제 더 이상 사용되지 않으며 MySQL 8.0에서 제거됩니다.
# tx_isolation보다 transaction_isolation을 사용하도록 응용 프로그램을 조정해야합니다.
#
# * Apply Option
# transaction_isolation=REPEATABLE-READ
# 
# --------------------------------------------
# 
# @ transaction_read_only :
# 
# Property : Value
# Command-Line Format : --transaction-read-only[={OFF|ON}]
# System Variable (≥ 5.7.20)	transaction_read_only
# Scope (≥ 5.7.20)	Global, Session
# Dynamic (≥ 5.7.20)	Yes
# Type : Boolean
# Default Value : OFF
#
# 트랜잭션 액세스 모드 값은 OFF (읽기 / 쓰기; 기본값) 또는 ON (읽기 전용) 일 수 있습니다.
# 트랜잭션 액세스 모드에는 전역, 세션 및 다음 트랜잭션의 세 가지 범위가 있습니다. 이 3 가지 범위의 구현은 후술하는 바와 같이 일부 비표준 액세스 모드 할당 시맨틱으로 이어진다.
# 시작시 전역 트랜잭션 액세스 모드를 설정하려면 --transaction-read-only server 옵션을 사용하십시오.
# 
# 런타임시, 액세스 모드는 SET 문을 사용하여 직접 설정하여 transaction_read_only 시스템 변수에 값을 지정하거나 간접적으로
# SET TRANSACTION 문을 사용하여 설정할 수 있습니다. 예를 들어이 SET 문을 사용하여 전역 값을 설정하십시오.
# 
# SET GLOBAL transaction_read_only = ON;
# 전역 transaction_read_only 값을 설정하면 모든 후속 세션에 대한 액세스 모드가 설정됩니다. 기존 세션은 영향을받지 않습니다.
# 
# 세션 또는 다음 레벨 transaction_read_only 값을 설정하려면 SET 문을 사용하십시오. 대부분의 세션 시스템 변수에서이 명령문은 값을 설정하는 동등한 방법입니다.
# 
# SET @@SESSION.var_name = value;
# SET SESSION var_name = value;
# SET var_name = value;
# SET @@var_name = value;
# 앞에서 언급했듯이 트랜잭션 액세스 모드에는 전역 및 세션 범위 외에 다음 트랜잭션 범위가 있습니다.
# 다음 트랜잭션 범위를 설정하려면 세션 시스템 변수 값을 지정하기위한 SET 구문에 transaction_read_only에 대한 비표준 의미가 있습니다.
# 
# + 세션 액세스 모드를 설정하려면 다음 구문 중 하나를 사용하십시오.
# SET @@SESSION.transaction_read_only = value;
# SET SESSION transaction_read_only = value;
# SET transaction_read_only = value;
# For each of those syntaxes, these semantics apply:
# 
# - Sets the access mode for all subsequent transactions performed within the session.
# - Permitted within transactions, but does not affect the current ongoing transaction.
# - If executed between transactions, overrides any preceding statement that sets the next-transaction access mode.
# - Corresponds to SET SESSION TRANSACTION {READ WRITE | READ ONLY} (with the SESSION keyword).
# 
# 다음 트랜잭션 액세스 모드를 설정하려면 다음 구문을 사용하십시오.
# SET @@transaction_read_only = value;
# 
# 이 구문에는 다음과 같은 의미가 적용됩니다.
# -세션 내에서 수행 된 다음 단일 트랜잭션에 대해서만 액세스 모드를 설정합니다.
# -후속 트랜잭션은 세션 액세스 모드로 돌아갑니다.
# -거래 내에서 허용되지 않습니다.
# -SET TRANSACTION {READ WRITE | READ ONLY} (SESSION 키워드없이).
# 
# SET TRANSACTION 및 transaction_read_only 시스템 변수와의 관계에 대한 자세한 내용은 13.3.6 절“SET TRANSACTION 문”을 참조하십시오.
# 
# 노트
# transaction_read_only는 MySQL 5.7.20에서 tx_read_only의 별칭으로 추가되었으며, 이제 더 이상 사용되지 않으며 MySQL 8.0에서 제거됩니다.
# tx_read_only보다 transaction_read_only를 사용하도록 애플리케이션을 조정해야합니다.
#
# * Apply Option
# transaction_read_only=OFF
# 
# --------------------------------------------
#
# @ completion_type
# https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_bind_address
# 
# Command-Line Format : --completion-type=#
# System Variable : completion_type
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : NO_CHAIN
# Valid Values : NO_CHAIN(0), CHAIN(1), RELEASE(2)
# 
# 트랜잭션 완료 유형입니다. 이 변수는 다음 표에 표시된 값을 사용할 수 있습니다. 변수는 이름값 또는 해당 정수값을 사용하여 할당할 수 있습니다.
# 
# 값 설명
# NO_CHAIN ​​(또는 0) COMMIT 및 ROLLBACK은 영향을받지 않습니다. 이것이 기본값입니다.
# CHAIN ​​(또는 1) COMMIT 및 ROLLBACK은 각각 COMMIT AND CHAIN ​​및 ROLLBACK AND CHAIN과 동일합니다.
# (새 트랜잭션은 방금 종료 된 트랜잭션과 동일한 격리 수준으로 즉시 시작됩니다.)
# 
# RELEASE (또는 2) COMMIT 및 ROLLBACK은 각각 COMMIT RELEASE 및 ROLLBACK RELEASE와 동일합니다. (트랜잭션 종료 후 서버 연결이 끊어집니다.)
# complete_type은 START TRANSACTION 또는 BEGIN으로 시작하고 COMMIT 또는 ROLLBACK으로 끝나는 트랜잭션에 영향을줍니다.
# 13.3.3 절.“암시 적 커밋을 유발하는 문”에 나열된 명령문을 실행하여 발생하는 암시 적 커밋에는 적용되지 않습니다.
# XA COMMIT, XA ROLLBACK 또는 autocommit = 1 인 경우에도 적용되지 않습니다.
# 
# * Apply Option
# completion_type=NO_CHAIN
#
# --------------------------------------------
# 
# @ unique_checks :
# 
# Property : Value
# System Variable : unique_checks
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 1 (기본값)로 설정하면 InnoDB 테이블에서 보조 인덱스에 대한 고유성 검사가 수행됩니다. 0으로 설정하면 스토리지 엔진은 입력 데이터에 중복 키가 없다고 가정 할 수 있습니다.
# 데이터에 고유성 위반이 포함되어 있지 않다는 것을 알고 있다면이 테이블을 0으로 설정하여 큰 테이블 가져 오기를 InnoDB로 가속화 할 수 있습니다.
# 
# 이 변수를 0으로 설정하면 스토리지 엔진이 중복 키를 무시하지 않아도됩니다. 엔진은 여전히 ​​엔진을 점검하고 감지되면 중복 키 오류를 발행 할 수 있습니다.
#
# * Apply Option
# unique_checks=ON
# 
# --------------------------------------------
# 
# @ wait_timeout :
# 
# Property : Value
# Command-Line Format : --wait-timeout=#
# System Variable : wait_timeout
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 28800
# Minimum Value : 1
# Maximum Value : (Other)	31536000
# Maximum Value : (Windows) - 2147483
# 
# 비 대화식 연결에서 서버가 활동을 닫기 전에 서버가 대기하는 시간 (초)입니다.
# 
# 스레드 시작시 세션 유형 wait_timeout 값은 클라이언트 유형에 따라 전역 wait_timeout 값 또는 전역 interactive_timeout 값에서 초기화됩니다
# (CLIENT_INTERACTIVE 연결 옵션으로 mysql_real_connect()에 정의 됨).
# interactive_timeout도 참조하십시오.
#
# * Apply Option
# wait_timeout=28800
# 
# --------------------------------------------
# 
# @ pid_file
# 
# Command-Line Format : --pid-file=file_name
# System Variable : pid_file
# Scope	: Global
# Dynamic : No
# Type : File name
# 
# 서버가 프로세스 ID를 쓰는 파일의 경로 이름입니다. 다른 디렉토리를 지정하기 위해 절대 경로 이름이 제공되지 않는 한 서버는 데이터 디렉토리에 파일을 작성합니다.
# 이 변수를 지정하는 경우 값을 지정해야합니다. 이 변수를 지정하지 않으면 MySQL은 host_name.pid의 기본값을 사용합니다. 여기서 host_name은 호스트 시스템의 이름입니다.
# 
# 
# 프로세스 ID 파일은 mysqld_safe와 같은 다른 프로그램에서 서버의 프로세스 ID를 결정하는 데 사용됩니다.
# Windows에서이 변수는 기본 오류 로그 파일 이름에도 영향을줍니다. 5.4.2 절.“오류 로그”를 참조하십시오.
#
# * Apply Option
# pid_file=경로/filename.pid
#
# -------------------------------------------------------
# -------------character set과 문자집합 관련 변수들.----------
# -------------------------------------------------------
# 
# @ character_set_client
# 
# System Variable : character_set_client
# Scope L Global, Session
# Dynamic : Yes
# Type : String
# Default Value : utf8
# 
# 클라이언트에서 도착하는 문에 대한 문자 집합입니다. 이 변수의 세션 값은 클라이언트가 서버에 연결할 때 클라이언트가 요청한 문자 집합을 사용하여 설정됩니다.
# (많은 클라이언트가 --default-character-set 옵션을 지원하여이 문자 집합이 명시 적으로 지정되도록합니다. 10.4 절.“연결 문자 집합 및 데이터 정렬”도 참조하십시오.)
# 변수의 전역 값은 세션 값을 설정하는 데 사용됩니다. 클라이언트 요청 값을 알 수 없거나 사용할 수 없거나 서버가 클라이언트 요청을 무시하도록 구성된 경우 :
#  -클라이언트가 서버에 알려지지 않은 문자 집합을 요청합니다. 예를 들어, 일본어 사용 가능 클라이언트는 sjis 지원으로 구성되지 않은 서버에 연결할 때 sji를 요청합니다.
#  -클라이언트는 MySQL 4.1 이전 버전의 MySQL이므로 문자 집합을 요청하지 않습니다.
#  -mysqld는 --skip-character-set-client-handshake 옵션으로 시작되어 클라이언트 문자 세트 구성을 무시합니다.
#   이는 MySQL 4.0 동작을 재현하며 모든 클라이언트를 업그레이드하지 않고 서버를 업그레이드하려는 경우 유용합니다.
# 
# 일부 문자 집합은 클라이언트 문자 집합으로 사용할 수 없습니다. character_set_client 값으로 사용하려고하면 오류가 발생합니다. 허용되지 않는 클라이언트 문자 집합을 참조하십시오.
# 
# * Apply Option
# character_set_client=utf8
# 
# # --------------------------------------------
# 
# @ character_set_connection
# 
# System Variable : character_set_connection
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# Default Value : utf8
# 
# 문자 세트 소개없이 지정된 리터럴 및 숫자-문자열 변환에 사용되는 문자 세트입니다. 소개 자에 대한 정보는 10.3.8 절.“문자 집합 소개 자”를 참조하십시오.
#
# * Apply Option
# character_set_connection=utf8
#
# # --------------------------------------------
# 
# @ character_set_database
# 
# System Variable : character_set_database
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# Default Value : latin1
# Footnote : 이 옵션은 동적이지만 서버에서만 설정해야합니다. 이 변수를 수동으로 설정하면 안됩니다.
# 
# 기본 데이터베이스에서 사용하는 문자 집합입니다. 서버는 기본 데이터베이스가 변경 될 때마다이 변수를 설정합니다. 기본 데이터베이스가없는 경우 변수는 character_set_server와 동일한 값을 갖습니다.
# 전역 character_set_database 및 collation_database 시스템 변수는 MySQL 5.7에서 더 이상 사용되지 않습니다. 향후 버전의 MySQL에서 제거 될 것으로 예상됩니다.
# 세션 character_set_database 및 collation_database 시스템 변수에 값을 할당하는 것은 MySQL 5.7에서 더 이상 사용되지 않으며 할당시 경고가 생성됩니다.
# 세션 변수는 MySQL의 차기 버전에서 읽기 전용이되고 할당은 오류를 생성하는 반면 세션 변수에 액세스하여 기본 데이터베이스에 대한 데이터베이스 문자 집합과 데이터 정렬을 결정할 수 있도록해야합니다.
# 
# * Apply Option
# character_set_database=latin1
#
# --------------------------------------------
# 
# @ character_set_filesystem
# 
# Command-Line Format	--character-set-filesystem=name
# System Variable	character_set_filesystem
# Scope	Global, Session
# Dynamic	Yes
# Type	String
# Default Value	binary
# 
# 
# 파일 시스템 문자 세트. 이 변수는 LOAD DATA 및 SELECT ... INTO OUTFILE 문 및 LOAD_FILE () 함수와 같이 파일 이름을 참조하는 문자열 리터럴을 해석하는 데 사용됩니다.
# 이러한 파일 이름은 파일 열기 시도가 발생하기 전에 character_set_client에서 character_set_filesystem으로 변환됩니다. 기본값은 2 진이며 변환이 발생하지 않음을 의미합니다.
# 멀티 바이트 파일 이름이 허용되는 시스템의 경우 다른 값이 더 적절할 수 있습니다.
# 예를 들어 시스템이 UTF-8을 사용하여 파일 이름을 나타내는 경우 character_set_filesystem을 'utf8mb4'로 설정합니다.
# 
# * Apply Option
# character_set_database=binary
#
# --------------------------------------------
# 
# @ character_set_results
# 
# System Variable	character_set_results
# Scope	Global, Session
# Dynamic	Yes
# Type	String
# Default Value	utf8
# 
# 클라이언트에 쿼리 결과를 반환하는 데 사용되는 문자 집합입니다. 여기에는 열 값과 같은 결과 데이터, 열 이름과 같은 결과 메타 데이터 및 오류 메시지가 포함됩니다.
# 
#
# * Apply Option
# character_set_results=utf8
#
# --------------------------------------------
# 
# @ character_set_server
# 
# Command-Line Format	--character-set-server=name
# System Variable	character_set_server
# Scope	Global, Session
# Dynamic	Yes
# Type	String
# Default Value	latin1
# 
# 서버 기본 문자 집합입니다. 10.15 절.“문자 집합 구성”을 참조하십시오. 이 변수를 설정하는 경우 문자 집합에 대한 데이터 정렬을 지정하려면 collation_server도 설정해야합니다.
# 
# * Apply Option
# character_set_server=latin1
#
# # --------------------------------------------
# 
# @ character_set_system
# 
# System Variable : character_set_system
# Scope : Global
# Dynamic : No
# Type : String
# Default Value : utf8
# 
# 식별자를 저장하기 위해 서버에서 사용하는 문자 집합입니다. 값은 항상 utf8입니다.
# 
# * Apply Option
# character_set_system=utf8
#
# --------------------------------------------
# 
# @ character_sets_dir
# 
# Command-Line Format : --character-sets-dir=dir_name
# System Variable : character_sets_dir
# Scope : Global
# Dynamic : No
# Type : Directory name
# 
# 문자 세트가 설치된 디렉토리입니다. 10.15 절.“문자 집합 구성”을 참조하십시오.
#
# * Apply Option
# character_sets_dir=Directory name
# 
# --------------------------------------------
# 
# @ collation_connection
# 
# System Variable : collation_connection
# Scope : Global, Session
# Dynamic : Yes
# Type : String
#  
# 연결 문자 집합의 데이터 정렬입니다. collation_connection은 리터럴 문자열 비교에 중요합니다. 
# 열 값이있는 문자열을 비교하는 경우 열에는 고유 한 데이터 정렬이 있고 데이터 정렬 우선 순위가 더 높기 때문에 collation_connection은 중요하지 않습니다.
# (섹션 10.8.4,“식의 데이터 정렬 강제성”참조).
# 
# * Apply Option
# collation_connection=<String>
#
# --------------------------------------------
# 
# @ collation_database
# 
# System Variable : collation_database
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# Default Value : latin1_swedish_ci
# Footnote(각주) : 이 옵션은 동적이지만 서버에서만 설정해야 합니다. 이 변수를 수동으로 설정하면 안 됩니다.
# 
# 기본 데이터베이스에서 사용하는 데이터 정렬입니다. 서버는 기본 데이터베이스가 변경될 때마다 이 변수를 설정합니다.
$ 기본 데이터베이스가 없는 경우 변수는 collation_server와 동일한 값을 갖습니다.
# 전역 character_set_database 및 collation_database 시스템 변수는 MySQL 5.7에서 더 이상 사용되지 않습니다.
# 향후 버전의 MySQL에서 제거 될 것으로 예상됩니다.
# 세션 character_set_database 및 collation_database 시스템 변수에 값을 할당하는 것은 MySQL 5.7에서 더 이상 사용되지 않으며 할당시 경고가 생성됩니다.
# 세션 변수는 MySQL의 차기 버전에서 읽기 전용이되고 할당은 오류를 생성하는 반면 세션 변수에 액세스하여 기본 데이터베이스에 대한 데이터베이스 문자 집합과 데이터 정렬을 결정할 수 있습니다.
# 
# * Apply Option
# collation_database=latin1_swedish_ci
#
# --------------------------------------------
# 
# @ collation_server
# 
# Command-Line Format : --collation-server=name
# System Variable : collation_server
# Scope ; Global, Session
# Dynamic : Yes
# Type : String
# Default Value : latin1_swedish_ci
# 
# 서버의 기본 데이터 정렬입니다. 10.15 절.“문자 집합 구성”을 참조하십시오.
# 
# * Apply Option
# collation_server=latin1_swedish_ci
#
# --------------------------------------------
# 
# @ lc_messages
# 
# Command-Line Format : --lc-messages=name
# System Variable : lc_messages
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# Default Value : en_US
# 
# 오류 메시지에 사용할 로케일입니다. 기본값은 en_US입니다. 서버는 인수를 언어 이름으로 변환하고이를 lc_messages_dir 값과 결합하여 오류 메시지 파일의 위치를 생성합니다.
# 10.12 절“오류 메시지 언어 설정”을 참조하십시오.
#
# * Apply Option
# lc_messages=en_US
#
# --------------------------------------------
# 
# @ lc_messages_dir
# 
# Command-Line Format : --lc-messages-dir=dir_name
# System Variable : lc_messages_dir
# Scope : Global
# Dynamic : No
# Type : Directory name
# 
# 오류 메시지가있는 디렉토리입니다. 서버는 lc_messages 값과 함께 값을 사용하여 오류 메시지 파일의 위치를 생성합니다.
# 10.12 절“오류 메시지 언어 설정”을 참조하십시오.
# 
# * Apply Option
# lc_messages_dir=<directory name>
# 
# --------------------------------------------
# 
# 
# @ lc_time_names
# 
# Command-Line Format : --lc-time-names=value
# System Variable : lc_time_names
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# 
# 이 변수는 일 및 월 이름과 약어를 표시하는 데 사용되는 언어를 제어하는 로케일을 지정합니다.
# 이 변수는 DATE_FORMAT (), DAYNAME () 및 MONTHNAME () 함수의 출력에 영향을줍니다.
# 로케일 이름은 'ja_JP'또는 'pt_BR'과 같은 POSIX 스타일 값입니다. 기본값은 시스템의 로케일 설정에 관계없이 'en_US'입니다.
# 자세한 내용은 Section 10.16,“MySQL Server 로케일 지원”을 참조하십시오.
# 
# * Apply Option
# lc_time_names=<String>
#
# ----------------------------------------------------
# -------------Slow Query, Index 관련 변수들.----------
# ----------------------------------------------------
# 
# @ slow_launch_time
# 
# Command-Line Format : --slow-launch-time=#
# System Variable : slow_launch_time
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 2
# 
# 스레드를 만드는 데이 시간보다 오래 걸리는 경우 서버는 Slow_launch_threads 상태 변수를 증가시킵니다.
#
# * Apply Option
# slow_launch_time=2
# 
# --------------------------------------------
# @ slow_query_log
# 
# Property : Value
# Command-Line Format : --slow-query-log[={OFF|ON}]
# System Variable : slow_query_log
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
#
# Slow Query 로그 사용 여부입니다. 로그를 비활성화하려면 값을 0 (또는 OFF)으로 설정하고, 로그를 활성화하려면 1 (또는 ON) 값을 지정할 수 있습니다.
# 로그 출력 대상은 log_output 시스템 변수에 의해 제어됩니다. 해당 값이 NONE이면 로그가 사용 가능하더라도 로그 항목이 기록되지 않습니다.
# 
# "느린"은 long_query_time 변수의 값에 의해 결정됩니다. 5.4.5 절.“느린 쿼리 로그”를 참조하십시오.
#
# * Apply Option
# slow_query_log=OFF
# 
# --------------------------------------------
# 
# @ slow_query_log_file
# 
# Property : Value
# Command-Line Format : --slow-query-log-file=file_name
# System Variable : slow_query_log_file
# Scope : Global
# Dynamic : Yes
# Type : File name
# Default Value : host_name-slow.log
# 
# Slow Query 로그 파일의 이름입니다. 기본값은 host_name-slow.log이지만 초기 값은 --slow_query_log_file 옵션을 사용하여 변경할 수 있습니다.
#
# * Apply Option
# slow_query_log_file=host_name-slow.log
# 
# --------------------------------------------
# 
# @ long_query_time
# 
# Property : Value
# Command-Line Format : --long-query-time=#
# System Variable : long_query_time
# Scope : Global, Session
# Dynamic : Yes
# Type : Numeric
# Default Value : 10
# Minimum Value : 0
#
# 쿼리가 설정된 시간(초단위)보다 오래 걸리면 서버는 Slow_queries 상태 변수를 증가시킵니다. 느린 쿼리 로그가 활성화되면 쿼리가 Slow Query Log 파일에 기록됩니다.
# 이 값은 CPU 시간이 아닌 실시간으로 측정되므로로드가 적은 시스템에서 임계 값 미만인 쿼리는로드가 많은 시스템의 임계 값보다 높을 수 있습니다.
# long_query_time의 최소값과 기본값은 각각 0과 10입니다. 이 값은 마이크로 초의 해상도로 지정할 수 있습니다. 5.4.5 절.“느린 쿼리 로그”를 참조하십시오.
#
# * Apply Option
# long_query_time=10
# 
# --------------------------------------------
# 
# @ log_throttle_queries_not_using_indexes
# 
# Property : Value
# Command-Line Format : --log-throttle-queries-not-using-indexes=#
# System Variable : log_throttle_queries_not_using_indexes
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 0
#
# log_queries_not_using_indexes가 사용 가능한 경우 log_throttle_queries_not_using_indexes 변수는 분당 느린 쿼리 로그에 쓸 수있는 분당 쿼리 수를 제한합니다.
# 값 0 (기본값)은 "제한 없음"을 의미합니다. 자세한 내용은 5.4.5 절“느린 쿼리 로그”를 참조하십시오.
#
# * Apply Option
# log_throttle_queries_not_using_indexes=0
# 
# --------------------------------------------
# 
# @ log_slow_admin_statements
# 
# Property : Value
# Command-Line Format : --log-slow-admin-statements[={OFF|ON}]
# System Variable : log_slow_admin_statements
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 느린 쿼리 로그에 작성된 명령문에 느린 관리 명령문을 포함하십시오.
# 관리 문에는 ALTER TABLE, ANALYZE TABLE, CHECK TABLE, CREATE INDEX, DROP INDEX, OPTIMIZE TABLE 및 REPAIR TABLE이 포함됩니다.
#
# * Apply Option
# log_slow_admin_statements=2621OFF44
# 
# --------------------------------------------
# 
# @ log_queries_not_using_indexes
# 
# Property : Value
# Command-Line Format : --log-queries-not-using-indexes[={OFF|ON}]
# System Variable : log_queries_not_using_indexes
# Scope : Global
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 느린 쿼리 로그가 활성화 된 상태에서이 변수를 활성화하면 모든 행을 검색 할 것으로 예상되는 쿼리가 기록됩니다. 5.4.5 절.“느린 쿼리 로그”를 참조하십시오.
# 이 옵션이 반드시 인덱스가 사용되지 않음을 의미하지는 않습니다. 예를 들어 전체 인덱스 스캔을 사용하는 쿼리는 인덱스를 사용하지만 인덱스가 행 수를 제한하지 않기 때문에 기록됩니다.
#
# * Apply Option
# log_queries_not_using_indexes=OFF 
#
# --------------------------------------------
#
# @ min_examined_row_limit
# 
# Command-Line Format : --min-examined-row-limit=#
# System Variable : min_examined_row_limit
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 0
# Minimum Value : 0
# Maximum Value (64-bit platforms) : 18446744073709551615
# Maximum Value (32-bit platforms) ; 4294967295
# 
# 이 행 수보다 적은 수를 검사하는 쿼리는 느린 쿼리 로그에 기록되지 않습니다.
#
# * Apply Option
# min_examined_row_limit=0
#
# ----------------------------------------------------
# -------------Query Cache 관련 변수들.------------------
# ----------------------------------------------------
# 
# @ query_alloc_block_size
# 
# Command-Line Format : --query-alloc-block-size=#
# System Variable : query_alloc_block_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 8192
# Minimum Value : 1024
# Maximum Value : 4294967295
# Unit : bytes
# Block Size : 1024
# 
# 명령문 구문 분석 및 실행중에 생성된 개체에 할당되는 메모리 블록의 할당 크기 (바이트)입니다.
# 메모리 조각화에 문제가있는 경우이 매개 변수를 늘리는 것이 도움이 될 수 있습니다.
#
# * Apply Option
# query_alloc_block_size=8192
# 
# --------------------------------------------
# 
# @ query_cache_limit
# 
# Command-Line Format : --query-cache-limit=#
# Deprecated : 5.7.20
# System Variable : query_cache_limit
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1048576
# Minimum Value : 0
# Maximum Value (64-bit platforms) : 18446744073709551615
# Maximum Value (32-bit platforms) : 4294967295
# 
# 설정된된 바이트 수보다 큰 결과를 캐시하지 않습니다. 기본값은 1MB입니다.
# 
# 노트
# 쿼리 캐시는 MySQL 5.7.20에서 더 이상 사용되지 않으며 MySQL 8.0에서 제거되었습니다. 지원 중단에는 query_cache_limit가 포함됩니다.
#
# * Apply Option
# query_cache_limit=1048576
# 
# --------------------------------------------
#
# @ query_cache_min_res_unit
# 
# Command-Line Format : --query-cache-min-res-unit=#
# Deprecated : 5.7.20
# System Variable  :query_cache_min_res_unit
# Scope ; Global
# Dynamic : Yes
# Type : Integer
# Default Value : 4096
# Minimum Value : 512
# Maximum Value (64-bit platforms) : 18446744073709551615
# Maximum Value (32-bit platforms) : 4294967295
# 
# 쿼리 캐시에서 할당 한 블록의 최소 크기 (바이트)입니다. 기본값은 4096 (4KB)입니다. 이 변수에 대한 조정 정보는 8.10.3.3 절.“쿼리 캐시 구성”에 나와 있습니다.
# 
# 참고사항
# 쿼리 캐시는 MySQL 5.7.20에서 더 이상 사용되지 않으며 MySQL 8.0에서 제거되었습니다. 지원 중단에는 query_cache_min_res_unit이 포함됩니다.
#
# * Apply Option
# query_cache_min_res_unit=4096
#
# --------------------------------------------
# 
# @ query_cache_size
# 
# Command-Line Format : --query-cache-size=#
# Deprecated : 5.7.20
# System Variable : query_cache_size
# Scope : Global
# Dynamic : Yes
# Type : Integer
# Default Value : 1048576
# Minimum Value : 0
# Maximum Value (64-bit platforms) : 18446744073709551615
# Maximum Value (32-bit platforms) : 4294967295
# 
# 쿼리 결과를 캐싱하기 위해 할당 된 메모리 양입니다. 기본적으로 쿼리 캐시는 비활성화되어 있습니다.
# 이것은 query_cache_type의 기본값이 0 인 기본값 인 1M을 사용하여 수행됩니다.
# (크기를 0으로 설정 한 경우 오버 헤드를 크게 줄이려면 query_cache_type = 0으로 서버를 시작해야합니다.)
# 
# 허용되는 값은 1024의 배수입니다. 다른 값은 가장 가까운 배수로 내림됩니다.
# query_cache_size의 0이 아닌 값의 경우 query_cache_type = 0 인 경우에도 많은 바이트의 메모리가 할당됩니다.
# 자세한 내용은 섹션 8.10.3.3,“쿼리 캐시 구성”을 참조하십시오.
# 
# 쿼리 캐시는 구조를 할당하기 위해 약 40KB의 최소 크기가 필요합니다. (정확한 크기는 시스템 아키텍처에 따라 다릅니다.)
# query_cache_size 값을 너무 작게 설정하면 8.10.3.3 절.“쿼리 캐시 구성”에 설명 된대로 경고가 발생합니다.
# 
# 노트
# 쿼리 캐시는 MySQL 5.7.20에서 더 이상 사용되지 않으며 MySQL 8.0에서 제거되었습니다. 지원 중단에는 query_cache_size가 포함됩니다.
#
# * Apply Option
# query_cache_size=1048576
# 
# --------------------------------------------
#
# @ query_cache_type
# Command-Line Format : --query-cache-type=#
# Deprecated : 5.7.20
# System Variable : query_cache_type
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : 0
# Valid Values : 0, 1, 2
# 
# 쿼리 캐시 유형을 설정합니다. GLOBAL 값을 설정하면 이후에 연결하는 모든 클라이언트의 유형이 설정됩니다.
# 개별 클라이언트는 쿼리 캐시의 자체 사용에 영향을 미치도록 SESSION 값을 설정할 수 있습니다. 가능한 값은 다음 표에 나와 있습니다.
# 
# https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html
# Option         |   Description
# 0 or OFF       |   쿼리 캐시에서 결과를 캐시하거나 검색하지 마십시오. 이것은 쿼리 캐시 버퍼를 할당 해제하지 않습니다. 그렇게 하려면 query_cache_size를 0으로 설정해야 합니다.
# 1 or ON        |   SELECT SQL_NO_CACHE로 시작하는 결과를 제외한 모든 캐시 가능한 쿼리 결과를 캐시합니다.
# 2 or DEMAND    |   SELECT SQL_CACHE로 시작하는 캐시 가능한 쿼리에 대해서만 결과를 캐시합니다.
# 
# 이 변수의 기본값은 OFF입니다.
# 
# 서버가 query_cache_type이 0으로 설정된 상태에서 시작되면 쿼리 캐시 뮤텍스를 전혀 획득하지 못합니다.
# 즉, 쿼리 캐시를 런타임에 활성화 할 수없고 쿼리 실행시 오버 헤드가 줄어 듭니다.
# 
# 참고사항
# 쿼리 캐시는 MySQL 5.7.20에서 더 이상 사용되지 않으며 MySQL 8.0에서 제거되었습니다. 지원 중단에는 query_cache_type이 포함됩니다.
#
# * Apply Option
# query_cache_type=0
# 
# --------------------------------------------
# 
# @ query_cache_wlock_invalidate
# 
# Command-Line Format : --query-cache-wlock-invalidate[={OFF|ON}]
# Deprecated : 5.7.20
# System Variable : query_cache_wlock_invalidate
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 일반적으로 한 클라이언트가 MyISAM 테이블에 대한 WRITE 잠금을 획득 할 때 쿼리 결과가 쿼리 캐시에있는 경우
# 다른 클라이언트는 테이블에서 읽은 문을 발행하지 못하도록 차단되지 않습니다.
# 이 변수를 1로 설정하면 테이블에 대한 WRITE 잠금을 획득하여 테이블을 참조하는 쿼리 캐시의 모든 쿼리가 무효화됩니다.
# 이렇게하면 잠금이 적용되는 동안 테이블에 액세스하려는 다른 클라이언트가 대기하게됩니다.
# 
# 노트
# 쿼리 캐시는 MySQL 5.7.20에서 더 이상 사용되지 않으며 MySQL 8.0에서 제거되었습니다.
# 지원 중단에는 query_cache_wlock_invalidate가 포함됩니다.
#
# * Apply Option
# query_cache_wlock_invalidate=OFF
# 
# --------------------------------------------
# 
# @ query_prealloc_size
# 
# Command-Line Format : --query-prealloc-size=#
# System Variable : query_prealloc_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 8192
# Minimum Value : 8192
# Maximum Value (64-bit platforms) : 18446744073709547520
# Maximum Value (32-bit platforms) : 4294967295
# Block Size : 1024
# 
# 명령문 구문 분석 및 실행에 사용되는 영구 버퍼의 크기 (바이트)입니다. 이 버퍼는 문 사이에서 해제되지 않습니다.
# 복잡한 쿼리를 실행하는 경우 더 큰 query_prealloc_size 값은 쿼리 실행 작업 중에 서버가 메모리 할당을 수행해야하는 필요성을 줄일 수 있으므로 성능 향상에 도움이 될 수 있습니다.
# 
# * Apply Option
# query_prealloc_size=8192
#
# 
# ----------------------------------------------------
# -------------Optimizer 관련 변수들.------------------
# ----------------------------------------------------
# 
# @ optimizer_prune_level
# 
# Property : Value
# Command-Line Format : --optimizer-prune-level=#
# System Variable : optimizer_prune_level
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 1
# Minimum Value : 0
# Maximum Value : 1
#
# 쿼리 최적화 중에 적용된 휴리스틱을 제어하여 옵티 마이저 검색 공간에서 덜 유망한 부분 계획을 제거합니다. 값이 0이면 휴리스틱이 비활성화되어 옵티마이 저가 철저한 검색을 수행합니다.
# 값이 1이면 최적화 프로그램이 중간 계획에서 검색 한 행 수를 기반으로 계획을 정리합니다.
#
# * Apply Option
# optimizer_prune_level=1
# 
# --------------------------------------------
# 
# @ optimizer_search_depth
# 
# Property : Value
# Command-Line Format : --optimizer-search-depth=#
# System Variable : optimizer_search_depth
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 62
# Minimum Value : 0
# Maximum Value : 62
#
# 쿼리 최적화 프로그램이 수행하는 최대 검색 깊이입니다. 쿼리의 관계 수보다 큰 값을 사용하면 쿼리 계획이 향상되지만 쿼리에 대한 실행 계획을 생성하는 데 시간이 더 걸립니다.
# 쿼리의 관계 수보다 작은 값은 실행 계획을 더 빨리 반환하지만 결과 계획은 최적이 아닙니다. 0으로 설정하면 시스템이 자동으로 합리적인 값을 선택합니다.
#
# * Apply Option
# optimizer_search_depth=62
# 
# --------------------------------------------
# 
# @ optimizer_switch
# 
# Property : Value
# Command-Line Format : --optimizer-switch=value
# System Variable : optimizer_switch
# Scope : Global, Session
# Dynamic : Yes
# Type : Set
# Valid Values	
# batched_key_access={on|off}
# block_nested_loop={on|off}
# condition_fanout_filter={on|off}
# derived_merge={on|off}
# duplicateweedout={on|off}
# engine_condition_pushdown={on|off}
# firstmatch={on|off}
# index_condition_pushdown={on|off}
# index_merge={on|off}
# index_merge_intersection={on|off}
# index_merge_sort_union={on|off}
# index_merge_union={on|off}
# loosescan={on|off}
# materialization={on|off}
# mrr={on|off}
# mrr_cost_based={on|off}
# semijoin={on|off}
# subquery_materialization_cost_based={on|off}
# use_index_extensions={on|off}
# 
# optimizer_switch 시스템 변수를 사용하면 옵티 마이저 동작을 제어 할 수 있습니다.
# 이 변수의 값은 플래그 세트이며, 각 플래그는 해당 옵티 마이저 동작이 사용 가능한지 여부를 표시하기 위해 on 또는 off 값을 갖습니다.
# 이 변수는 글로벌 및 세션 값을 가지며 런타임시 변경 될 수 있습니다. 서버 시작시 전역 기본값을 설정할 수 있습니다.
# 
# 현재 옵티 마이저 플래그 세트를 보려면 변수 값을 선택하십시오.
# mysql> SELECT @@optimizer_switch\G
# *************************** 1. row ***************************
# @@optimizer_switch: index_merge=on,index_merge_union=on,
#                     index_merge_sort_union=on,
#                     index_merge_intersection=on,
#                     engine_condition_pushdown=on,
#                     index_condition_pushdown=on,
#                     mrr=on,mrr_cost_based=on,
#                     block_nested_loop=on,batched_key_access=off,
#                     materialization=on,semijoin=on,loosescan=on,
#                     firstmatch=on,duplicateweedout=on,
#                     subquery_materialization_cost_based=on,
#                     use_index_extensions=on,
#                     condition_fanout_filter=on,derived_merge=on
# 
# 이 변수의 구문과 변수가 제어하는 ​​옵티 마이저 동작에 대한 자세한 내용은 8.9.2 절.“전환 가능한 최적화”를 참조하십시오.
#
# * Apply Option
# optimizer_switch=none
# 
# --------------------------------------------
# 
# @ optimizer_trace
# 
# Property : Value
# Command-Line Format : --optimizer-trace=value
# System Variable : optimizer_trace
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# 이 변수는 옵티 마이저 추적을 제어합니다. 자세한 내용은 MySQL 내부 : 최적화 프로그램 추적을 참조하십시오.
#
# * Apply Option
# optimizer_trace=none
# 
# --------------------------------------------
# 
# @ optimizer_trace_features
# 
# Property : Value
# Command-Line Format : --optimizer-trace-features=value
# System Variable : optimizer_trace_features
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# 
# 이 변수는 선택된 최적화 프로그램 추적 기능을 활성화 또는 비활성화합니다. 자세한 내용은 MySQL 내부 : 최적화 프로그램 추적을 참조하십시오.
#
# * Apply Option
# optimizer_trace_features=none
# 
# --------------------------------------------
# 
# @ optimizer_trace_limit
# 
# Property : Value
# Command-Line Format : --optimizer-trace-limit=#
# System Variable : optimizer_trace_limit
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 1
# 표시 할 최대 옵티 마이저 추적 수입니다. 자세한 내용은 MySQL 내부 : 최적화 프로그램 추적을 참조하십시오.
#
# * Apply Option
# optimizer_trace_limit=1
# 
# --------------------------------------------
# 
# @ optimizer_trace_max_mem_size
# 
# Property : Value
# Command-Line Format : --optimizer-trace-max-mem-size=#
# System Variable : optimizer_trace_max_mem_size
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : 16384
# 저장된 옵티 마이저 추적의 최대 누적 크기입니다. 자세한 내용은 MySQL 내부 : 최적화 프로그램 추적을 참조하십시오.
#
# * Apply Option
# optimizer_trace_max_mem_size=16384
# 
# --------------------------------------------
# 
# @ optimizer_trace_offset
# 
# Property : Value
# Command-Line Format : --optimizer-trace-offset=#
# System Variable : optimizer_trace_offset
# Scope : Global, Session
# Dynamic : Yes
# Type : Integer
# Default Value : -1
# 표시 할 옵티 마이저 추적의 오프셋입니다. 자세한 내용은 MySQL 내부 : 최적화 프로그램 추적을 참조하십시오.
#
# * Apply Option
# optimizer_trace_offset=none
#
# --------------------------------------------
# 
# @ eq_range_index_dive_limit
# 
# Command-Line Format	--eq-range-index-dive-limit=#
# System Variable	eq_range_index_dive_limit
# Scope	Global, Session
# Dynamic	Yes
# Type	Integer
# Default Value	200
# Minimum Value	0
# Maximum Value	4294967295
# 
# 이 변수는 옵티마이 저가 정규화 행수를 추정할 때 인덱스 다이빙 사용에서 인덱스 통계로 전환해야할때 동등 비교 조건에서 동등 범위수를 나타냅니다.
# 이는 최적화 프로그램이 고유하지 않은 인덱스를 사용하여 col_name 값을 조회하는 다음과 같은 동등한 형식중 하나를 갖는 표현식의 평가에 적용됩니다.
# 
# col_name IN(val1, ..., valN)
# col_name = val1 OR ... OR col_name = valN
# 
# 두 경우 모두 표현식에 N 개의 같음 범위가 포함됩니다. 옵티마이 저는 인덱스 다이빙 또는 인덱스 통계를 사용하여 행을 추정 할 수 있습니다.
# eq_range_index_dive_limit가 0보다 크면 옵티마이저는 # eq_range_index_dive_limit 이상의 동일 범위가있는 경우 인덱스 다이빙 대신 기존 인덱스 통계를 사용합니다.
# 따라서 최대 N 개의 동일 범위에 대한 인덱스 다이빙 사용을 허용하려면 eq_range_index_dive_limit를 N + 1로 설정합니다.
# 인덱스 통계 사용을 비활성화하고 N에 관계없이 항상 인덱스 다이빙을 사용하려면 eq_range_index_dive_limit를 0으로 설정합니다.
# 
# 자세한 내용은 다값 비교의 동등 범위 최적화 단원을 참조하십시오.
# 
# 최상의 추정치를 위해 테이블 인덱스 통계를 업데이트하려면 ANALYZE TABLE을 사용하십시오.
# 
# * Apply Option
# eq_range_index_dive_limit=200
# 
# --------------------------------------------
# 
# 
# ===================================================================================
# ================== Performance Schema System Variables 관련 옵션들  ==================
# ===================================================================================
#
# @ performance_schema
# 
# Property : Value
# Command-Line Format : --performance-schema[={OFF|ON}]
# System Variable : performance_schema
# Scope : Global
# Dynamic : No
# Type : Boolean
# Default Value : ON
# 이 변수의 값은 ON 또는 OFF이며 성능 스키마가 사용 가능한지 여부를 나타냅니다. 기본적으로 값은 ON입니다.
# 서버 시작시이 변수를 값이나 ON 또는 1로 설정하여 사용 가능하게하거나 OFF 또는 0으로 설정하여 사용 불가능하게 할 수 있습니다.
# 
# 성능 스키마가 비활성화 된 경우에도 global_variables, session_variables, global_status 및 session_status 테이블을 계속 채 웁니다.
# show_compatibiliy_56 시스템 변수의 설정에 따라 SHOW VARIABLES 및 SHOW STATUS 문에 대한 결과를 해당 테이블에서 가져올 수 있도록 필요한 경우에 발생합니다.
#
# * Apply Option
# performance_schema=ON
# 
# --------------------------------------------
# 
# @ performance_schema_accounts_size
# 
# Property : Value
# Command-Line Format : --performance-schema-accounts-size=#
# System Variable : performance_schema_accounts_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# Minimum Value : -1 (signifies autoscaling; do not assign this literal value)
# Maximum Value : 1048576
#
# 계정 테이블의 행 수입니다. 이 변수가 0이면 성능 스키마는 accounts 테이블의 연결 통계 또는 status_by_account 테이블의 상태 변수 정보를 유지하지 않습니다.
#
# * Apply Option
# performance_schema_accounts_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_digests_size
# 
# Property : Value
# Command-Line Format : --performance-schema-digests-size=#
# System Variable : performance_schema_digests_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : -1
# Maximum Value : 1048576
# events_statements_summary_by_digest 테이블의 최대 행 수입니다.
# 이 최대 값을 초과하여 다이제스트를 계측 할 수없는 경우 성능 스키마는 Performance_schema_digest_lost 상태 변수를 증가시킵니다.
# 
# 명령문 다이제스트에 대한 자세한 내용은 25.10 절“성능 스키마 구문 요약”을 참조하십시오.
#
# * Apply Option
# performance_schema_digests_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_stages_history_long_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-stages-history-long-size=#
# System Variable : performance_schema_events_stages_history_long_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_stages_history_long 테이블의 행 수입니다.
#
# * Apply Option
# performance_schema_events_stages_history_long_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_stages_history_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-stages-history-size=#
# System Variable : performance_schema_events_stages_history_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_stages_history 테이블에서 스레드 당 행 수입니다.
#
# * Apply Option
# performance_schema_events_stages_history_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_statements_history_long_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-statements-history-long-size=#
# System Variable : performance_schema_events_statements_history_long_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_statements_history_long 테이블의 행 수입니다.
#
# * Apply Option
# performance_schema_events_statements_history_long_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_statements_history_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-statements-history-size=#
# System Variable : performance_schema_events_statements_history_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_statements_history 테이블의 스레드 당 행 수입니다.
#
# * Apply Option
# performance_schema_events_statements_history_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_transactions_history_long_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-transactions-history-long-size=#
# System Variable : performance_schema_events_transactions_history_long_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
#
# events_transactions_history_long 테이블의 행 수입니다.
# 
# * Apply Option
# performance_schema_events_transactions_history_long_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_transactions_history_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-transactions-history-size=#
# System Variable : performance_schema_events_transactions_history_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_transactions_history 테이블에서 스레드 당 행 수입니다.
#
# * Apply Option
# performance_schema_events_transactions_history_size=-1 
# 
# --------------------------------------------
# 
# @ performance_schema_events_waits_history_long_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-waits-history-long-size=#
# System Variable : performance_schema_events_waits_history_long_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# events_waits_history_long 테이블의 행 수입니다.
#
# * Apply Option
# performance_schema_events_waits_history_long_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_events_waits_history_size
# 
# Property : Value
# Command-Line Format : --performance-schema-events-waits-history-size=#
# System Variable : performance_schema_events_waits_history_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
#
# events_waits_history 테이블에서 스레드 당 행 수입니다.
#
# * Apply Option
# performance_schema_events_waits_history_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_hosts_size
# 
# Property : Value
# Command-Line Format : --performance-schema-hosts-size=#
# System Variable : performance_schema_hosts_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# Minimum Value : -1 (signifies autoscaling; do not assign this literal value)
# Maximum Value : 1048576
# 
# hosts 테이블의 행 수입니다. 이 변수가 0 인 경우 성능 스키마는 hosts 테이블의 연결 통계 또는 status_by_host 테이블의 상태 변수 정보를 유지하지 않습니다.
#
# * Apply Option
# performance_schema_hosts_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_cond_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-cond-classes=#
# System Variable : performance_schema_max_cond_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 80
# Minimum Value : 0
# Maximum Value : 256
#
# 최대 조건 계측기 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_cond_classes=80
# 
# --------------------------------------------
# 
# @ performance_schema_max_cond_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-cond-instances=#
# System Variable : performance_schema_max_cond_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# 계측 된 조건 개체의 최대 개수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_cond_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_digest_length
# 
# Property : Value
# Command-Line Format : --performance-schema-max-digest-length=#
# System Variable : performance_schema_max_digest_length
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 1024
# Minimum Value : 0
# Maximum Value : 1048576
#
# 성능 스키마에서 정규화 된 명령문 다이제스트 값을 계산하기 위해 명령문 당 예약 된 최대 메모리 바이트 수입니다.
# 이 변수는 max_digest_length와 관련이 있습니다. 5.1.7 절“서버 시스템 변수”에서 해당 변수에 대한 설명을 참조하십시오.
# 
# 메모리 사용에 대한 고려 사항을 포함하여 명령문 다이제스트에 대한 자세한 내용은 25.10 절“성능 스키마 구문 요약”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_digest_length=1024
# 
# --------------------------------------------
# 
# @ performance_schema_max_file_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-file-classes=#
# System Variable : performance_schema_max_file_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 80
# Minimum Value : 0
# Maximum Value : 256
# 
# 최대 파일 악기 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_file_classes=80
# 
# --------------------------------------------
# 
# @ performance_schema_max_file_handles
# 
# Property : Value
# Command-Line Format : --performance-schema-max-file-handles=#
# System Variable : performance_schema_max_file_handles
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 32768
# 열린 파일 객체의 최대 개수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
# 
# performance_schema_max_file_handles의 값은 open_files_limit의 값보다 커야합니다.
# open_files_limit는 서버가 지원할 수있는 열린 파일 핸들의 최대 수에 영향을 미치고 performance_schema_max_file_handles는 계측 할 수있는 파일 핸들 수에 영향을줍니다.
#
# * Apply Option
# performance_schema_max_file_handles=32768
# 
# --------------------------------------------
# 
# @ performance_schema_max_file_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-file-instances=#
# System Variable : performance_schema_max_file_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# 인스트루먼트 된 파일 오브젝트의 최대 수. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_file_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_index_stat
# 
# Property : Value
# Command-Line Format : --performance-schema-max-index-stat=#
# System Variable : performance_schema_max_index_stat
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# 
# 성능 스키마가 통계를 유지하는 최대 인덱스 수입니다. 이 최대 값을 초과하여 인덱스 통계가 유실되면 Performance Schema는 Performance_schema_index_stat_lost 상태 변수를 증가시킵니다.
# 기본값은 performance_schema_max_table_instances 값을 사용하여 자동 크기 조정됩니다.
#
# * Apply Option
# performance_schema_max_index_stat=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_memory_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-memory-classes=#
# System Variable : performance_schema_max_memory_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 320
#
# 최대 메모리 장치 수 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_memory_classes=320
# 
# --------------------------------------------
# 
# @ performance_schema_max_metadata_locks
# 
# Property : Value
# Command-Line Format : --performance-schema-max-metadata-locks=#
# System Variable : performance_schema_max_metadata_locks
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
#
# 메타 데이터 잠금 장치의 최대 수입니다. 이 값은 metadata_locks 테이블의 크기를 제어합니다.
# 메타 데이터 잠금을 계측 할 수 없도록이 최대 값을 초과하면 성능 스키마가 Performance_schema_metadata_lock_lost 상태 변수를 증가시킵니다.
#
# * Apply Option
# performance_schema_max_metadata_locks=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_mutex_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-mutex-classes=#
# System Variable : performance_schema_max_mutex_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 200
# Minimum Value : 0
# Maximum Value : 256
#
# 최대 뮤텍스 기기 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_mutex_classes=200
# 
# --------------------------------------------
# 
# @ performance_schema_max_mutex_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-mutex-instances=#
# System Variable : performance_schema_max_mutex_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
#
# 계측 된 뮤텍스 객체의 최대 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 내용은 25.7 절“성능 스키마 상태”를 참조하십시오.
#
# * Apply Option
# performance_schema_max_mutex_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_prepared_statements_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-prepared-statements-instances=#
# System Variable : performance_schema_max_prepared_statements_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
#
# ready_statements_instances 테이블의 최대 행 수입니다.
# 이 최대 값을 초과하여 준비된 명령문을 계측 할 수없는 경우 성능 스키마는 Performance_schema_prepared_statements_lost 상태 변수를 증가시킵니다.
# 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
# 
# 이 변수의 기본값은 max_prepared_stmt_count 시스템 변수의 값을 기반으로 자동 크기 조정됩니다.
#
# * Apply Option
# performance_schema_max_prepared_statements_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_rwlock_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-rwlock-classes=#
# System Variable : performance_schema_max_rwlock_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 40
# Minimum Value : 0
# Maximum Value : 256
#
# 최대 rwlock 기기 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_rwlock_classes=40
# 
# --------------------------------------------
# 
# @ performance_schema_max_program_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-program-instances=#
# System Variable : performance_schema_max_program_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
#
# 성능 스키마가 통계를 유지하는 최대 저장된 프로그램 수입니다. 이 최대 값을 초과하면 성능 스키마가 Performance_schema_program_lost 상태 변수를 증가시킵니다.
# 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_program_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_rwlock_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-rwlock-instances=#
# System Variable : performance_schema_max_rwlock_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# 계측 된 rwlock 객체의 최대 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_rwlock_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_socket_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-socket-classes=#
# System Variable : performance_schema_max_socket_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 10
# Minimum Value : 0
# Maximum Value : 256
# 
# 최대 소켓 계측기 수 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_socket_classes=10
# 
# --------------------------------------------
# 
# @ performance_schema_max_socket_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-socket-instances=#
# System Variable : performance_schema_max_socket_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 계측 된 소켓 개체의 최대 수 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_socket_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_sql_text_length
# 
# Property : Value
# Command-Line Format : --performance-schema-max-sql-text-length=#
# System Variable : performance_schema_max_sql_text_length
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 1024
# Minimum Value : 0
# Maximum Value : 1048576
# 
# events_statements_current, events_statements_history 및 events_statements_history_long 명령문 이벤트 테이블의
# SQL_TEXT 컬럼에 SQL 문을 저장하는 데 사용되는 최대 바이트 수입니다.
# performance_schema_max_sql_text_length를 초과하는 바이트는 버려지고 SQL_TEXT 열에 나타나지 않습니다. 이 열에서 많은 초기 바이트를 구분할 수없는 명령문은 구별 할 수 없습니다.
# 
# performance_schema_max_sql_text_length 값을 줄이면 메모리 사용이 줄어들지 만 더 많은 명령문이 끝에서만 다를 경우 구분할 수 없게 됩니다.
# 값을 늘리면 메모리 사용이 증가하지만 더 긴 명령문을 구별 할 수 있습니다.
#
# * Apply Option
# performance_schema_max_sql_text_length=1024
# 
# --------------------------------------------
# 
# @ performance_schema_max_stage_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-stage-classes=#
# System Variable : performance_schema_max_stage_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 150
# Minimum Value : 0
# Maximum Value : 256
#
# 최대 스테이지 악기 수입니다. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_stage_classes=150
# 
# --------------------------------------------
# 
# @ performance_schema_max_statement_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-statement-classes=#
# System Variable : performance_schema_max_statement_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
#
# 최대 명령문 도구 수 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
# 
# 기본값은 클라이언트 / 서버 프로토콜의 명령 수와 서버가 지원하는 SQL 문 유형 수를 기반으로 서버 빌드시 계산됩니다.
# 
# 모든 명령문 인스 트루먼 테이션을 사용하지 않고 연관된 모든 메모리를 저장하기 위해이 변수를 0으로 설정하지 않으면이 변수를 변경해서는 안됩니다.
# 변수를 기본값 이외의 0이 아닌 값으로 설정하면 아무런 이점이 없습니다. 특히, 기본값보다 큰 값은 더 많은 메모리를 할당해야합니다.
#
# * Apply Option
# performance_schema_max_statement_classes=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_statement_stack
# 
# Property : Value
# Command-Line Format : --performance-schema-max-statement-stack=#
# System Variable : performance_schema_max_statement_stack
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 10
# 성능 스키마가 통계를 유지 보수하는 중첩 된 저장 프로그램 호출의 최대 깊이.
# 이 최대 값을 초과하면 성능 스키마는 실행 된 각 저장된 프로그램 명령문에 대해 Performance_schema_nested_statement_lost 상태 변수를 증가시킵니다.
#
# * Apply Option
# performance_schema_max_statement_stack=10
# 
# --------------------------------------------
# 
# @ performance_schema_max_table_handles
# 
# Property : Value
# Command-Line Format : --performance-schema-max-table-handles=#
# System Variable : performance_schema_max_table_handles
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (자동 확장을 나타냅니다.이 리터럴 값을 할당하지 마십시오)
# 
# 열린 테이블 개체의 최대 개수입니다. 이 값은 table_handles 테이블의 크기를 제어합니다.
# 이 최대 값을 초과하여 테이블 핸들을 계측 할 수없는 경우 성능 스키마는 Performance_schema_table_handles_lost 상태 변수를 증가시킵니다.
# 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_table_handles=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_table_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-table-instances=#
# System Variable : performance_schema_max_table_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
#
# 인스트루먼트 된 테이블 오브젝트의 최대 수. 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_table_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_table_lock_stat
# 
# Property : Value
# Command-Line Format : --performance-schema-max-table-lock-stat=#
# System Variable : performance_schema_max_table_lock_stat
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
#
# 성능 스키마가 잠금 통계를 유지하는 최대 테이블 수입니다.
# 이 최대 값을 초과하여 테이블 잠금 통계가 유실되면 성능 스키마는 Performance_schema_table_lock_stat_lost 상태 변수를 증가시킵니다.
#
# * Apply Option
# performance_schema_max_table_lock_stat=-1
# 
# --------------------------------------------
# 
# @ performance_schema_max_thread_classes
# 
# Property : Value
# Command-Line Format : --performance-schema-max-thread-classes=#
# System Variable : performance_schema_max_thread_classes
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 50
# Minimum Value : 0
# Maximum Value : 256
#
# 최대 스레드 악기 수 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
#
# * Apply Option
# performance_schema_max_thread_classes=50
# 
# --------------------------------------------
# 
# @ performance_schema_max_thread_instances
# 
# Property : Value
# Command-Line Format : --performance-schema-max-thread-instances=#
# System Variable : performance_schema_max_thread_instances
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# 계측 된 스레드 객체의 최대 수입니다. 이 값은 스레드 테이블의 크기를 제어합니다.
# 이 최대 값을 초과하여 스레드를 계측 할 수없는 경우 성능 스키마는 Performance_schema_thread_instances_lost 상태 변수를 증가시킵니다.
# 이 변수를 설정하고 사용하는 방법에 대한 자세한 내용은 25.7 절“성능 스키마 상태 모니터링”을 참조하십시오.
# 
# max_connections 시스템 변수는 서버에서 실행할 수있는 스레드 수에 영향을줍니다.
# performance_schema_max_thread_instances는 계측 할 수있는 실행중인 스레드 수에 영향을줍니다.
# 
# variables_by_thread 및 status_by_thread 테이블에는 포 그라운드 스레드에 대한 시스템 및 상태 변수 정보 만 포함됩니다.
# 모든 스레드가 성능 스키마에 의해 계측되지 않으면이 테이블에서 일부 행이 누락됩니다.
# 이 경우 Performance_schema_thread_instances_lost 상태 변수는 0보다 큽니다.
#
# * Apply Option
# performance_schema_max_thread_instances=-1
# 
# --------------------------------------------
# 
# @ performance_schema_session_connect_attrs_size
# 
# Property : Value
# Command-Line Format : --performance-schema-session-connect-attrs-size=#
# System Variable : performance_schema_session_connect_attrs_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autosizing; do not assign this literal value)
# Minimum Value : -1
# Maximum Value : 1048576
#
# 연결 속성 키-값 쌍을 보유하도록 예약 된 스레드 당 사전 할당 된 메모리의 양입니다.
# 클라이언트가 전송 한 연결 속성 데이터의 총 크기가이 양보다 큰 경우 성능 스키마는 속성 데이터를 자르고
# Performance_schema_session_connect_attrs_lost 상태 변수를 증가시키고 log_error_verbosity 시스템 변수 값인 경우
# 잘림이 발생했음을 나타내는 메시지를 오류 로그에 기록합니다. 1보다 큽니다.
# 
# performance_schema_session_connect_attrs_size의 기본값은 서버 시작시 자동 크기 조정됩니다.
# 이 값은 작을 수 있으므로 잘림이 발생하면 (Performance_schema_session_connect_attrs_lost가 0이 아닌 경우)
# performance_schema_session_connect_attrs_size를 명시 적으로 더 큰 값으로 설정할 수 있습니다.
# 
# 허용되는 최대 performance_schema_session_connect_attrs_size 값은 1MB이지만 서버는 허용 할 연결 속성 데이터의 총 크기에 64KB를 제한하므로 유효 최대 값은 64KB입니다.
# 클라이언트가 64KB 이상의 속성 데이터를 보내려고하면 서버가 연결을 거부합니다. 자세한 내용은 25.12.9 절.“성능 스키마 연결 속성 테이블”을 참조하십시오.
#
# * Apply Option
# performance_schema_session_connect_attrs_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_setup_actors_size
# 
# Property : Value
# Command-Line Format : --performance-schema-setup-actors-size=#
# System Variable : performance_schema_setup_actors_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# setup_actors 테이블의 행 수입니다.
#
# * Apply Option
# performance_schema_setup_actors_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_setup_objects_size
# 
# Property : Value
# Command-Line Format : --performance-schema-setup-objects-size=#
# System Variable : performance_schema_setup_objects_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# 
# setup_objects 테이블의 행 수입니다.
#
# * Apply Option
# performance_schema_setup_objects_size=-1
# 
# --------------------------------------------
# 
# @ performance_schema_users_size
# 
# Property : Value
# Command-Line Format : --performance-schema-users-size=#
# System Variable : performance_schema_users_size
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : -1 (signifies autoscaling; do not assign this literal value)
# Minimum Value : -1 (signifies autoscaling; do not assign this literal value)
# Maximum Value : 1048576
#
# users 테이블의 행 수입니다. 이 변수가 0이면 성능 스키마는 users 테이블의 연결 통계 또는 status_by_user 테이블의 상태 변수 정보를 유지하지 않습니다.
#
# * Apply Option
# performance_schema_users_size=-1
#
# ------------------------------------------------------------
# -------------Session & Client Track 관련 옵션들.-------------
# ------------------------------------------------------------
# 
# @ session_track_schema
# 
# Property : Value
# Command-Line Format : --session-track-schema[={OFF|ON}]
# System Variable : session_track_schema
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : ON
# 
# 서버가 기본 세션 (데이터베이스)이 현재 세션 내에 설정되는시기를 추적하고 클라이언트에게 스키마 이름을 사용할 수 있도록 알립니다.
# 스키마 이름 추적기가 사용 가능한 경우, 새 스키마 이름이 이전 이름과 동일하더라도 기본 스키마가 설정 될 때마다 이름 알림이 발생합니다.
# 세션 상태 추적에 대한 자세한 내용은 5.1.14 절“클라이언트 세션 상태 변경에 대한 서버 추적”을 참조하십시오.
#
# * Apply Option
# session_track_schema=ON
# 
# --------------------------------------------
# 
# @ session_track_state_change
# 
# Property : Value
# Command-Line Format : --session-track-state-change[={OFF|ON}]
# System Variable : session_track_state_change
# Scope : Global, Session
# Dynamic : Yes
# Type : Boolean
# Default Value : OFF
# 
# 서버가 현재 세션 상태의 변경 사항을 추적하는지 여부를 제어하고 상태 변경이 발생하면 클라이언트에게 알립니다.
# 클라이언트 세션 상태의 다음 속성에 대한 변경 사항을보고 할 수 있습니다.
# 
# -기본 스키마 (데이터베이스).
# -시스템 변수에 대한 세션 별 값.
# -사용자 정의 변수.
# -임시 테이블.
# -준비된 진술.
# 
# 세션 상태 추적기가 사용 가능한 경우 새 속성 값이 이전과 동일하더라도 추적 된 세션 속성과 관련된 각 변경에 대해 알림이 발생합니다.
# 예를 들어, 사용자 정의 변수를 현재 값으로 설정하면 알림이 생성됩니다.
# 
# session_track_state_change 변수는 변경 내용이 아닌 변경 사항이 발생한시기에 대한 알림 만 제어합니다.
# 예를 들어, 상태 변경 알림은 기본 스키마가 설정되거나 추적 된 세션 시스템 변수가 할당 될 때 발생하지만 알림에는 스키마 이름 또는 변수 값이 포함되지 않습니다.
# 스키마 이름 또는 세션 시스템 변수 값에 대한 알림을 받으려면 각각 session_track_schema 또는 session_track_system_variables 시스템 변수를 사용하십시오.
#
# * Apply Option
# session_track_state_change=OFF
# 
# --------------------------------------------
# 
# @ session_track_system_variables
# 
# Property : Value
# Command-Line Format : --session-track-system-variables=#
# System Variable : session_track_system_variables
# Scope : Global, Session
# Dynamic : Yes
# Type : String
# Default Value : time_zone, autocommit, character_set_client, character_set_results, character_set_connection
# 
# 서버가 세션 시스템 변수에 대한 지정을 추적하고 클라이언트에게 지정된 각 변수의 이름과 값을 통지하는지 여부를 제어합니다. 변수 값은 할당을 추적 할 쉼표로 구분 된 변수 목록입니다.
# 기본적으로 time_zone, 자동 커밋, character_set_client, character_set_results 및 character_set_connection에 대해 알림이 사용됩니다.
# 후자의 세 변수는 SET NAMES의 영향을받는 변수입니다.
# 특수 값 *은 서버가 모든 세션 변수에 대한 지정을 추적하게합니다. 주어진 경우이 값은 특정 시스템 변수 이름없이 자체적으로 지정해야합니다.
# 세션 변수 할당 알림을 비활성화하려면 session_track_system_variables를 빈 문자열로 설정하십시오.
# 세션 시스템 변수 추적이 사용 가능한 경우 새 값이 이전 값과 동일하더라도 추적 된 세션 변수에 대한 모든 지정에 대해 알림이 발생합니다.
# 세션 상태 추적에 대한 자세한 내용은 5.1.14 절“클라이언트 세션 상태 변경에 대한 서버 추적”을 참조하십시오.
#
# * Apply Option
# session_track_system_variables=time_zone, autocommit, character_set_client, character_set_results, character_set_connection
# 
# --------------------------------------------
# 
# @ session_track_transaction_info
# 
# Property : Value
# Command-Line Format : --session-track-transaction-info=value
# System Variable : session_track_transaction_info
# Scope : Global, Session
# Dynamic : Yes
# Type : Enumeration
# Default Value : OFF
# Valid Values	OFF, STATE, CHARACTERISTICS
# 
# 서버가 현재 세션 내 트랜잭션의 상태와 특성을 추적하는지 여부를 제어하고 클라이언트에게이 정보를 제공하도록 알립니다. 다음 session_track_transaction_info 값이 허용됩니다.
# 
# -OFF : 트랜잭션 상태 추적을 비활성화합니다. 이것이 기본값입니다.
# -상태 : 특성 추적없이 트랜잭션 상태 추적을 사용합니다. 상태 추적을 통해 클라이언트는 트랜잭션이 진행 중인지 여부와 롤백하지 않고 다른 세션으로 이동할 수 있는지 여부를 결정할 수 있습니다.
# -특성 : 특성 추적을 포함하여 트랜잭션 상태 추적을 활성화합니다.
# 특성 추적을 통해 클라이언트는 다른 세션에서 트랜잭션을 다시 시작하는 방법을 판별하여 원래 세션과 동일한 특성을 갖도록 할 수 있습니다.
# 다음과 같은 특성이이 목적과 관련이 있습니다.
# ISOLATION LEVEL
# READ ONLY 
# READ WRITE
# WITH CONSISTENT SNAPSHOT
# 
# 클라이언트가 트랜잭션을 다른 세션으로 안전하게 재배치하려면 트랜잭션 상태뿐만 아니라 트랜잭션 특성도 추적해야합니다.
# 또한 클라이언트는 transaction_isolation 및 transaction_read_only 시스템 변수를 추적하여 세션 기본값을 올바르게 결정해야합니다.
# 이러한 변수를 추적하려면 session_track_system_variables 시스템 변수의 값에 변수를 나열하십시오.
# 
# 세션 상태 추적에 대한 자세한 내용은 5.1.14 절“클라이언트 세션 상태 변경에 대한 서버 추적”을 참조하십시오.
#
# * Apply Option
# session_track_transaction_info=OFF

# ===============================================================================
# ========================== full text Parameter  ===============================
# ===============================================================================
# 
# @ ft_boolean_syntax
# 
# Command-Line Format : --ft-boolean-syntax=name
# System Variable : ft_boolean_syntax
# Scope : Global
# Dynamic : Yes
# Type : String
# Default Value : + -><()~*:""&|
# 
# IN BOOLEAN MODE를 사용하여 수행 된 부울 전체 텍스트 검색에서 지원하는 연산자 목록입니다. Section 12.10.2,“부울 전체 텍스트 검색”을 참조하십시오.
# 
# 기본 변수 값은 '+-> <() ~ * : ""& |'입니다. 값을 변경하는 규칙은 다음과 같습니다.
# -연산자 기능은 문자열 내 위치에 따라 결정됩니다.
# -대체 값은 14 자 여야합니다.
# -각 문자는 영숫자가 아닌 ASCII 문자 여야합니다.
# -첫 번째 또는 두 번째 문자는 공백이어야합니다.
# -11 번과 12 번 위치에있는 인용구 연산자를 제외하고는 중복이 허용되지 않습니다. 이 두 문자는 동일 할 필요는 없지만 둘만 있을 수 있습니다.
# -위치 10, 13 및 14 (기본적으로 :, & 및 |로 설정 됨)는 향후 확장을 위해 예약되어 있습니다.
# 
# * Apply Option
# ft_boolean_syntax=NONE
#
# --------------------------------------------
# 
# @ ft_min_word_len
# 
# Command-Line Format : --ft-min-word-len=#
# System Variable : ft_min_word_len
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value ; 4
# Minimum Value : 1
# 
# MyISAM FULLTEXT 인덱스에 포함될 단어의 최소 길이입니다.
# 
# 노트
# MyISAM 테이블의 FULLTEXT 인덱스는이 변수를 변경 한 후에 다시 작성해야합니다. REPAIR TABLE tbl_name QUICK을 사용하십시오.
# 
# * Apply Option
# ft_min_word_len=4
#
# --------------------------------------------
# 
# @ ft_query_expansion_limit
# 
# Command-Line Format : --ft-query-expansion-limit=#
# System Variable : ft_query_expansion_limit
# Scope : Global
# Dynamic : No
# Type : Integer
# Default Value : 20
# Minimum Value : 0
# Maximum Value : 1000
# 
# WITH QUERY EXPANSION을 사용하여 수행 된 전체 텍스트 검색에 사용할 상위 일치 수입니다.
#
# * Apply Option
# ft_query_expansion_limit=20
# 
# --------------------------------------------
# 
# @ ft_stopword_file
# 
# Command-Line Format : --ft-stopword-file=file_name
# System Variable : ft_stopword_file
# Scope : Global
# Dynamic : No
# Type : File name
# 
# MyISAM 테이블에서 전체 텍스트 검색을위한 불용어 목록을 읽을 파일입니다. 
# 다른 디렉토리를 지정하기 위해 절대 경로 이름이 제공되지 않는 한 서버는 데이터 디렉토리에서 파일을 찾습니다.
# 파일의 모든 단어가 사용됩니다. 댓글은 존중되지 않습니다. 기본적으로 내장 불용어 목록이 사용됩니다
# (storage / myisam / ft_static.c 파일에 정의 된대로). 이 변수를 빈 문자열 ('')로 설정하면 불용어 필터링이 비활성화됩니다.
# Section 12.10.4,“전체 텍스트불 용어”도 참조하십시오.
# 
# 노트
# MyISAM 테이블의 FULLTEXT 인덱스는이 변수 나 불용어 파일의 내용을 변경 한 후에 다시 작성해야합니다. REPAIR TABLE tbl_name QUICK을 사용하십시오.
#
# * Apply Option
# ft_stopword_file=<>
# 
